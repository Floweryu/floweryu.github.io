import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,a as i}from"./app-2af0f95a.js";const t={},c=i('<h2 id="xx-useconcmarksweepgc" tabindex="-1"><a class="header-anchor" href="#xx-useconcmarksweepgc" aria-hidden="true">#</a> -XX:+UseConcMarkSweepGC</h2><p>打开此开关后，使用 <strong>CMS + ParNew + Serial Old</strong> 收集器组合来进行内存回收。</p><p><strong>并发标记清除收集器是以获取最短停顿时间为目标。</strong></p><p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 Concurrent Mode Failure ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p><h2 id="xx-useadaptivesizepolicy" tabindex="-1"><a class="header-anchor" href="#xx-useadaptivesizepolicy" aria-hidden="true">#</a> -XX:+UseAdaptiveSizePolicy</h2><p>JDK 1.8 默认使用 UseParallelGC 垃圾回收器，该垃圾回收器默认启动了 AdaptiveSizePolicy，会根据GC的情况自动计算计算 Eden、From 和 To 区的大小。</p><p><strong>注意事项：</strong></p><ol><li>在 JDK 1.8 中，如果使用 CMS，无论 UseAdaptiveSizePolicy 如何设置，都会将 UseAdaptiveSizePolicy 设置为 false</li><li>由于AdaptiveSizePolicy会动态调整 Eden、Survivor 的大小，有些情况存在Survivor 被自动调为很小，比如十几MB甚至几MB的可能，这个时候YGC回收掉 Eden区后，还存活的对象进入Survivor 装不下，就会直接晋升到老年代，导致老年代占用空间逐渐增加，从而触发FULL GC，如果一次FULL GC的耗时很长（比如到达几百毫秒），那么在要求高响应的系统就是不可取的。</li></ol><p><strong>对于面向外部的大流量、低延迟系统，不建议启用此参数，建议关闭该参数</strong>。</p><h2 id="xx-cmsclassunloadingenabled" tabindex="-1"><a class="header-anchor" href="#xx-cmsclassunloadingenabled" aria-hidden="true">#</a> -XX:+CMSClassUnloadingEnabled</h2><p>表示开启 CMS 对永久代的垃圾回收（或元空间），避免由于永久代空间耗尽带来 Full GC。</p><h2 id="xx-usecmscompactatfullcollection" tabindex="-1"><a class="header-anchor" href="#xx-usecmscompactatfullcollection" aria-hidden="true">#</a> -XX:+UseCMSCompactAtFullCollection</h2><p>控制 <strong>Full GC</strong> 的过程中是否进行空间的整理（默认开启，注意是Full GC，不是普通CMS GC）。</p><blockquote><p>和<code>-XX: CMSFullGCsBeforeCompaction=n</code> 配合使用</p></blockquote><h2 id="xx-cmsfullgcsbeforecompaction-n" tabindex="-1"><a class="header-anchor" href="#xx-cmsfullgcsbeforecompaction-n" aria-hidden="true">#</a> -XX: CMSFullGCsBeforeCompaction=n</h2><p>控制多少次 Full GC 后进行一次压缩。</p><h2 id="xx-disableexplicitgc" tabindex="-1"><a class="header-anchor" href="#xx-disableexplicitgc" aria-hidden="true">#</a> -XX:+DisableExplicitGC</h2><p>禁止代码中显示调用GC。</p><h2 id="xx-cmsmaxabortableprecleantime" tabindex="-1"><a class="header-anchor" href="#xx-cmsmaxabortableprecleantime" aria-hidden="true">#</a> -XX:CMSMaxAbortablePrecleanTime</h2><p>控制CMS垃圾回收的<strong>abortable preclean阶段</strong>结束时间。默认值5s。</p><h4 id="cms垃圾回收的6个重要阶段" tabindex="-1"><a class="header-anchor" href="#cms垃圾回收的6个重要阶段" aria-hidden="true">#</a> CMS垃圾回收的6个重要阶段</h4><ol><li><strong>initial-mark 初始标记</strong>（CMS的第一个STW阶段）：标记GC Root直接引用的对象，GC Root直接引用的对象不多，所以很快。</li><li><strong>concurrent-mark 并发标记阶段</strong>：由第一阶段标记过的对象出发，所有可达的对象都在本阶段标记。</li><li><strong>concurrent-preclean 并发预清理阶段</strong>，也是一个并发执行的阶段。在本阶段，会查找前一阶段执行过程中,从新生代晋升或新分配或被更新的对象。通过并发地重新扫描这些对象，预清理阶段可以减少下一个stop-the-world 重新标记阶段的工作量。</li><li><strong>concurrent-abortable-preclean 并发可中止的预清理阶段</strong>：这个阶段其实跟上一个阶段做的东西一样，也是为了减少下一个STW重新标记阶段的工作量。增加这一阶段是为了让我们可以控制这个阶段的结束时机，比如扫描多长时间（默认5秒）或者Eden区使用占比达到期望比例（默认50%）就结束本阶段</li><li><strong>remark 重标记阶段</strong>（CMS的第二个STW阶段），暂停所有用户线程，从GC Root开始重新扫描整堆，标记存活的对象。需要注意的是，虽然CMS只回收老年代的垃圾对象，但是这个阶段依然需要扫描新生代，因为很多GC Root都在新生代，而这些GC Root指向的对象又在老年代，这称为“跨代引用”。</li><li><strong>concurrent-sweep ，并发清理</strong>。</li></ol><h2 id="xx-heapdumponoutofmemoryerror" tabindex="-1"><a class="header-anchor" href="#xx-heapdumponoutofmemoryerror" aria-hidden="true">#</a> -XX:+HeapDumpOnOutOfMemoryError</h2><p>当JVM发生OOM时，自动生成DUMP文件。</p><h2 id="xx-printgcdetails" tabindex="-1"><a class="header-anchor" href="#xx-printgcdetails" aria-hidden="true">#</a> -XX:+PrintGCDetails</h2><p>打印输出详细的GC收集日志的信息。</p><blockquote><p>Heap PSYoungGen total 6144K, used 2058K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 36% used [0x00000000ff980000,0x00000000ffb82950,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 13824K, used 0K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000) object space 13824K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff980000) Metaspace used 3032K, capacity 4494K, committed 4864K, reserved 1056768K class space used 330K, capacity 386K, committed 512K, reserved 1048576K</p></blockquote><h2 id="xx-printgcdatestamps" tabindex="-1"><a class="header-anchor" href="#xx-printgcdatestamps" aria-hidden="true">#</a> -XX:+PrintGCDateStamps</h2><p>格式化GC日志输出时间。</p><h2 id="xx-cmsinitiatingoccupancyfraction-70" tabindex="-1"><a class="header-anchor" href="#xx-cmsinitiatingoccupancyfraction-70" aria-hidden="true">#</a> -XX:CMSInitiatingOccupancyFraction=70</h2><p>在使用CMS收集器的情况下，老年代使用达到指定阈值的内存时，触发FullGC.。</p><h2 id="xx-usecmsinitiatingoccupancyonly" tabindex="-1"><a class="header-anchor" href="#xx-usecmsinitiatingoccupancyonly" aria-hidden="true">#</a> -XX:+UseCMSInitiatingOccupancyOnly</h2><p>指定用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction参数的值)，如果不指定，JVM仅在第一次使用设定值，后续则会根据运行时采集的数据做自动调整。如果指定了该参数，那么每次JVM都会在到达规定设定值时才进行GC。</p>',33),n=[c];function o(s,l){return a(),r("div",null,n)}const x=e(t,[["render",o],["__file","JVM参数详解.html.vue"]]);export{x as default};
