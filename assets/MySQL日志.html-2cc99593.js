import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as l,a as e}from"./app-1262e9b3.js";const n="/assets/image-20231222102126764-62efa2e6.png",g="/assets/image-20231222113416325-6630e61a.png",t={},d=e('<h2 id="为什么需要-undo-log" tabindex="-1"><a class="header-anchor" href="#为什么需要-undo-log" aria-hidden="true">#</a> 为什么需要 undo log</h2><p>在执行「增删改」语句的时候，MySQL 会<strong>隐式开启事务</strong>来执行，执行完成后自动提交事务。该功能由 <code>autocommit</code>参数决定，默认开启。</p><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p><img src="'+n+'" alt="image-20231222102126764" style="zoom:50%;"><p>下面是不同情况下需要记录的 undo log：</p><ul><li><strong>插入</strong>一条记录时，要把这条记录的「主键」记下来，回滚时只需要删除这个主键对应的记录。</li><li><strong>删除</strong>一条记录时，要把这条记录的「内容」记下来，回滚时把这些内容组成记录插入即可。</li><li><strong>更新</strong>一条记录时，要把被更新的「列」记下来，回滚时把这些列更新为旧值即可。</li></ul><p>一条记录的每一次更新产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务 id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的。</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，形成版本链。</li></ul><img src="'+g+'" alt="image-20231222113416325" style="zoom:50%;"><p>通过上图可以看出，undo log 另一个作用是通过 <strong>ReadView + undo log 实现 MVCC（多版本并发控制）</strong>。</p><p>由此可见，undo log 两大作用：</p><ul><li>实现事务回滚，保证事务原子性。</li><li>实现 MVCC。</li></ul><h2 id="为什么要-buffer-pool" tabindex="-1"><a class="header-anchor" href="#为什么要-buffer-pool" aria-hidden="true">#</a> 为什么要 buffer pool</h2><p>Innodb 引擎设计了缓冲池（ buffer pool ）来提高数据读写性能。</p><ul><li>读取数据时：如果数据存在于 buffer pool 中，客户端会直接从 buffer pool 中获取数据，否则再去磁盘中获取。</li><li>修改数据时：如果数据存在于 buffer pool 中，直接修改 buffer pool 中数据所在的页，将其设置为<strong>脏页</strong>（表示该页内存数据和磁盘上的数据不一致），为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适时机再写入到磁盘。</li></ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 buffer pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， buffer pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><p>buffer pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><p>开启事务后，更新记录之前，首先记录相应的 undo log，同时会写入 buffer pool 的 undo 页面。</p><p>当查询一条记录时，会把整个页的数据加载到 buffer pool 中，再通过「页目录」定位到某条具体的记录。</p><h2 id="为什么要-redo-log" tabindex="-1"><a class="header-anchor" href="#为什么要-redo-log" aria-hidden="true">#</a> 为什么要 redo log</h2><p>buffer pool 虽然提高了读写效率，但是基于内存的，不可靠，如果未来的及落盘会造成数据丢失。<strong>redo log 保证了事务四大特性中的持久性</strong>。</p><p>为了防止数据丢失，当有一条记录更新时，InnoDB 会先更新内存（同时标记为脏页），然后将这个页的修改以 redo log 形式记录。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 buffer pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是：MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p>redo log 记录某个数据页做了什么修改，在事务提交时，只需要先将 redo log 持久化到磁盘即可，可以不需要等到将 buffer pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><p><strong>修改 undo 页面，也需要记录对应的 redo log</strong>：</p><p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 undo 页面。<strong>在内存修改该 Undo 页面后，需要记录对应的 redo log</strong>。</p><p><strong>undo log 和 redo log 区别</strong>：</p><ul><li>redo log 记录事务「完成后」的数据状态，记录更新<strong>之后</strong>的值，防止数据丢失。</li><li>undo log 记录事务「开始前」的数据状态，记录更新<strong>之前</strong>的值，事务崩溃可以进行回滚。</li></ul><hr><p>【<strong>问题</strong>】：<strong>数据也要写入磁盘，redo log 也要写入磁盘，为什么多此一举？</strong></p><p>写入 redo log 使用了追加操作，对磁盘操作是<strong>顺序写</strong>；而写入数据需要先找到写入位置，再写磁盘，对磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>从这个方面来说，WAL 技术提升了 SQL 的执行性能，因为 MySQL 写操作并不立即更新到磁盘上，而是先记录到 redo log 日志上，等到合适时间再更新到磁盘上。</p><p>综上，redo log 有两个作用，如下：</p><ul><li><strong>实现事务的持久性</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失。</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><hr><p>【<strong>问题</strong>】：<strong>redo log 是直接写入磁盘吗？</strong></p><blockquote><p>一般都不会直接写入磁盘，都会有一个缓存区。</p></blockquote><p>肯定不是。如果每次执行事务都直接写入磁盘，这样就会产生大量的磁盘 I/O。</p><p>所以，redo log 会先写入到缓存中：<strong>redo log bufer</strong>，每次产生一条 redo log 时，先写入缓存，再持久化到磁盘。</p><p><strong>redo log buffer</strong> 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态调整大小。</p><hr><h3 id="redo-log-何时刷盘" tabindex="-1"><a class="header-anchor" href="#redo-log-何时刷盘" aria-hidden="true">#</a> redo log 何时刷盘</h3><p>既然 redo log 先存在缓存里，那么什么时候开始刷新到磁盘？时机如下：</p><ul><li>MySQL 正常关闭时。</li><li>当 redo log buffer 写入量超过设置 redo log buffer 内存空间一半，触发刷盘。</li><li>后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时，都会将 redo log buffer 里面的 redo log 直接持久化到磁盘。该功能由 <code>innodb_flush_log_at_trx_commit</code> 参数控制。</li></ul><hr><p><strong><code>innodb_flush_log_at_trx_commit</code> 作用</strong></p><p>默认值为 1，可取的值有0、1、2，作用分别如下：</p><ul><li>参数为 0 时：每次提交事务将 redo log 留在 redo log buffer 中，事务提交时不会触发写入磁盘操作。</li><li>参数为 1 时：每次提交事务都将 redo log buffer 中的 redo log 直接持久化到磁盘中，保证 MySQL 重启后数据不会丢失。</li></ul>',52),p=[d];function s(i,u){return r(),l("div",null,p)}const c=o(t,[["render",s],["__file","MySQL日志.html.vue"]]);export{c as default};
