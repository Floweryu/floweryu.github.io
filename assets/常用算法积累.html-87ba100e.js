const l=JSON.parse('{"key":"v-4fa270d2","path":"/posts/algorithm/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF.html","title":"常用算法积累","lang":"zh-CN","frontmatter":{"title":"常用算法积累","date":"2023-07-09T19:00:00.000Z","category":["算法"],"tag":["排序"],"description":"排序算法时间复杂度 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。","head":[["meta",{"property":"og:url","content":"https://floweryu.top/posts/algorithm/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF.html"}],["meta",{"property":"og:site_name","content":"Floweryu"}],["meta",{"property":"og:title","content":"常用算法积累"}],["meta",{"property":"og:description","content":"排序算法时间复杂度 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-14T09:30:42.000Z"}],["meta",{"property":"article:author","content":"Floweryu"}],["meta",{"property":"article:tag","content":"排序"}],["meta",{"property":"article:published_time","content":"2023-07-09T19:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-14T09:30:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常用算法积累\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-07-09T19:00:00.000Z\\",\\"dateModified\\":\\"2023-11-14T09:30:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Floweryu\\",\\"url\\":\\"https://floweryu.top\\",\\"email\\":\\"869830837@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"排序算法时间复杂度","slug":"排序算法时间复杂度","link":"#排序算法时间复杂度","children":[]},{"level":2,"title":"2.1 算法描述","slug":"_2-1-算法描述","link":"#_2-1-算法描述","children":[]},{"level":2,"title":"2.2 代码实现","slug":"_2-2-代码实现","link":"#_2-2-代码实现","children":[]},{"level":2,"title":"2.3 算法分析","slug":"_2-3-算法分析","link":"#_2-3-算法分析","children":[]},{"level":2,"title":"3.1 算法描述","slug":"_3-1-算法描述","link":"#_3-1-算法描述","children":[]},{"level":2,"title":"3.2 代码实现","slug":"_3-2-代码实现","link":"#_3-2-代码实现","children":[]},{"level":2,"title":"3.3 算法分析","slug":"_3-3-算法分析","link":"#_3-3-算法分析","children":[]},{"level":2,"title":"4.1 算法描述","slug":"_4-1-算法描述","link":"#_4-1-算法描述","children":[]},{"level":2,"title":"4.2 代码实现","slug":"_4-2-代码实现","link":"#_4-2-代码实现","children":[]},{"level":2,"title":"4.3 算法分析","slug":"_4-3-算法分析","link":"#_4-3-算法分析","children":[]},{"level":2,"title":"4.4 改进方法","slug":"_4-4-改进方法","link":"#_4-4-改进方法","children":[]},{"level":2,"title":"5.1 算法描述","slug":"_5-1-算法描述","link":"#_5-1-算法描述","children":[]},{"level":2,"title":"5.2 代码实现","slug":"_5-2-代码实现","link":"#_5-2-代码实现","children":[]},{"level":2,"title":"5.2 算法分析","slug":"_5-2-算法分析","link":"#_5-2-算法分析","children":[]},{"level":2,"title":"6.1 算法描述","slug":"_6-1-算法描述","link":"#_6-1-算法描述","children":[]},{"level":2,"title":"6.2 代码实现","slug":"_6-2-代码实现","link":"#_6-2-代码实现","children":[]},{"level":2,"title":"6.3 算法分析","slug":"_6-3-算法分析","link":"#_6-3-算法分析","children":[]},{"level":2,"title":"7.1 算法描述","slug":"_7-1-算法描述","link":"#_7-1-算法描述","children":[]},{"level":2,"title":"7.2 代码实现","slug":"_7-2-代码实现","link":"#_7-2-代码实现","children":[]},{"level":2,"title":"7.3 算法分析","slug":"_7-3-算法分析","link":"#_7-3-算法分析","children":[]},{"level":2,"title":"8.1 算法描述","slug":"_8-1-算法描述","link":"#_8-1-算法描述","children":[]},{"level":2,"title":"8.2 代码实现","slug":"_8-2-代码实现","link":"#_8-2-代码实现","children":[]},{"level":2,"title":"8.3 算法分析","slug":"_8-3-算法分析","link":"#_8-3-算法分析","children":[]},{"level":2,"title":"9.1 算法描述","slug":"_9-1-算法描述","link":"#_9-1-算法描述","children":[]},{"level":2,"title":"9.2 代码实现","slug":"_9-2-代码实现","link":"#_9-2-代码实现","children":[]},{"level":2,"title":"9.3 算法分析","slug":"_9-3-算法分析","link":"#_9-3-算法分析","children":[]},{"level":2,"title":"10.1 算法描述","slug":"_10-1-算法描述","link":"#_10-1-算法描述","children":[]},{"level":2,"title":"10.2 代码实现","slug":"_10-2-代码实现","link":"#_10-2-代码实现","children":[]},{"level":2,"title":"10.3 算法分析","slug":"_10-3-算法分析","link":"#_10-3-算法分析","children":[]},{"level":2,"title":"11.1 算法描述","slug":"_11-1-算法描述","link":"#_11-1-算法描述","children":[]},{"level":2,"title":"11.2 代码实现","slug":"_11-2-代码实现","link":"#_11-2-代码实现","children":[]},{"level":2,"title":"11.3 算法分析","slug":"_11-3-算法分析","link":"#_11-3-算法分析","children":[]}],"git":{"createdTime":1699954242000,"updatedTime":1699954242000,"contributors":[{"name":"zhangjunfeng","email":"im.zhangjunfeng@qq.com","commits":1}]},"readingTime":{"minutes":17.52,"words":5255},"filePathRelative":"posts/algorithm/常用算法积累.md","localizedDate":"2023年7月9日","excerpt":"<h2> 排序算法时间复杂度</h2>\\n<ul>\\n<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>\\n<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>\\n<li><strong>内排序</strong>：所有排序操作都在内存中完成；</li>\\n<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>\\n<li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li>\\n<li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li>\\n</ul>","autoDesc":true}');export{l as data};
