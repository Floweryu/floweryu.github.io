import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as s,c as n,b as e,d as l,e as t,a as r}from"./app-9eed816a.js";const d="/assets/E4HCGBaewbSxVRr-50ff3e2f.png",c="/assets/vekDjwJ2NSBxWhX-0cf94f3c.png",g="/assets/9NOaQTfyestWui5-9e2f2bf3.png",p="/assets/tJAg5TUEKbZx1oS-bf9fb9dd.png",m={},u=r(`<h2 id="索引的类型" tabindex="-1"><a class="header-anchor" href="#索引的类型" aria-hidden="true">#</a> 索引的类型</h2><p>索引分为两大类：聚簇索引和非聚簇索引。</p><ul><li><p><strong>聚簇索引</strong>：按照数据存放的物理位置为顺序的，聚簇索引能够提高多行检索的速度。</p></li><li><p><strong>非聚簇索引</strong>：索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。对单行的检索速度很快。</p></li><li><p><strong>组合索引</strong>：在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时<strong>遵循最左前缀集合</strong></p></li><li><p><strong>UNIQUE（唯一索引）</strong>：索引列的值必须唯一，但允许有空值。若是组合索引，则列值的组合必须唯一。</p></li><li><p><strong>PRIMARY（主键索引）</strong>：一种特殊的唯一索引，不允许有空值。</p></li><li><p><strong>Key（普通索引）</strong>：是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值.</p></li><li><p><strong>FULLTEXT（全文索引）</strong>：全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在<strong>CHAR</strong>、<strong>VARCHAR</strong>或者<strong>TEXT</strong>类型的列上创建.</p></li><li><p><strong>SPATIAL（空间索引）</strong>：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是<strong>GEOMETRY</strong>、<strong>POINT</strong>、<strong>LINESTRING</strong>和<strong>POLYGON</strong>。MySQL使用<strong>SPATIAL</strong>关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列必须声明为<strong>NOT NULL</strong>.</p></li></ul><h3 id="最左前缀原则" tabindex="-1"><a class="header-anchor" href="#最左前缀原则" aria-hidden="true">#</a> 最左前缀原则</h3><p>在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：</p><p>对列col1、列col2和列col3建一个联合索引：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>KEY test_col1_col2_col3 on test(col1,col2,col3);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>联合索引 <code>test_col1_col2_col3 </code>实际建立了<code>(col1)、(col1,col2)、(col,col2,col3)</code>三个索引。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引<code>(col1,col2)</code>进行数据匹配。</p><p><strong>注意</strong>：索引的字段可以是任意顺序的，如：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>SELECT * FROM test WHERE col1=“1” AND clo2=“2”
SELECT * FROM test WHERE col2=“2” AND clo1=“1”
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个查询语句都会用到索引<code>(col1,col2)</code>.</p><p>mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段<code>col1</code>的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段<code>col2</code>进行排序。其实就相当于实现了类似 <code>order by col1 col2</code>这样一种排序规则。</p><h2 id="建立索引的原则" tabindex="-1"><a class="header-anchor" href="#建立索引的原则" aria-hidden="true">#</a> 建立索引的原则</h2><ol><li><p><strong>最左前缀匹配原则</strong>，非常重要的原则，<code>mysql</code>会一直向右匹配直到遇到范围查询<code>(&gt;、&lt;、between、like)</code>就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4 </code>如果建立<code>(a,b,c,d)</code>顺序的索引，<code>d</code>是用不到索引的，如果建立<code>(a,b,d,c)</code>的索引则都可以用到，<code>a,b,d</code>的顺序可以任意调整。</p></li><li><p><strong>等于<code>（=）</code>和<code>in</code> 可以乱序</strong>。比如，<code>a = 1 AND b = 2 AND c = 3 </code>建立（a,b,c）索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的模式。</p></li><li><p><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是 <code>COUNT(DISTINCT col) / COUNT(*)</code>。表示字段不重复的比率，比率越大我们扫描的记录数就越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度是0。</p></li><li><p><strong>索引列不能参与计算</strong>，尽量保持列“干净”。比如，<code>FROM_UNIXTIME(create_time) = &#39;2016-06-06&#39;</code> 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： <code>create_time = UNIX_TIMESTAMP(&#39;2016-06-06&#39;)</code>。</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有<code>a</code>的索引，现在要加<code>(a,b)</code>的索引，那么只需要修改原来的索引即可。</p></li></ol><h2 id="索引的数据结构" tabindex="-1"><a class="header-anchor" href="#索引的数据结构" aria-hidden="true">#</a> 索引的数据结构</h2><h3 id="b-tree-b树" tabindex="-1"><a class="header-anchor" href="#b-tree-b树" aria-hidden="true">#</a> B-Tree（B树）</h3><figure><img src="`+d+'" alt="image-20210313144029222" tabindex="0" loading="lazy"><figcaption>image-20210313144029222</figcaption></figure><p>每个节点维护两个数据，并指向最多 3 个子节点。如图 3 个子节点的数据分别为：小于 17， 17 ~ 35 ，大于 35。</p><p>假设，从上图中查找 10 这个数，步骤如下：</p><ol><li>找到根节点，对比 10 与 17 和 35 的大小，发现 10 &lt; 17 在左子节点，也就是第 2 层节点；</li><li>从根节点的指针，找到左子节点，对比 10 与 8 和 12 的大小，发现<code>8 &lt; 10 &lt; 12</code>，数据在当前节点的中间子节点，也就是第 3 层节点；</li><li>通过上步节点的指针，找到中间子节点（第 3 层节点），对比 10 与 9 和 10 的大小，发现 <code>9 &lt; 10 == 10</code>，因此找到当前节点的第二数即为结果。</li></ol><p>加上忽略的 12 个数据，从 26 个数据中查找一个数字 10，仅仅用了 <code>log3(26)≈ 3</code>次，而如果用平衡二叉树,则需要<code>log2(26)≈ 5</code> 次，事实证明，多叉树确实可以再次提高查找性能。</p><p><strong>优点</strong>：二叉平衡树的基础上，使加载一次节点，可以加载更多路径数据，同时把查询范围缩减到更小。</p><p><strong>缺点</strong>：业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及 CPU 高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，现在却要多次才能加载完。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃。</p><figure><img src="'+c+'" alt="image-20210313144151082" tabindex="0" loading="lazy"><figcaption>image-20210313144151082</figcaption></figure><h3 id="b-tree-b-树" tabindex="-1"><a class="header-anchor" href="#b-tree-b-树" aria-hidden="true">#</a> B+Tree (B+树)</h3><p>鉴于磁盘 I/O 的性能问题，以及每次 I/O 获取数据量上限所限，提高索引本身 I/O 的方法最好是，减少 I/O 次数和每次获取有用的数据。</p><p>B-tree 已经大大改进了树家族的性能，它把多个数据集中存储在一个节点中，本身就可能减少了 I/O 次数或者寻道次数。</p><p>但是仍然有一个致命的缺陷，那就是它的<strong>索引数据与业务绑定在一块</strong>，而业务数据的大小很有可能远远超过了索引数据，这会大大减小一次 I/O 有用数据的获取，间接的增加 I/O 次数去获取有用的索引数据。</p><p>因为<strong>业务数据才是我们查询最终的目的</strong>，<strong>但是它又是在「二分」查找中途过程无用的数据</strong>，因此，如果只把业务数据存储在最终查询到的那个节点是不是就可以了？</p><p>B+tree 横空出世，<strong>B+ 树就是为了拆分索引数据与业务数据的平衡多叉树</strong>。</p><figure><img src="'+g+'" alt="image-20210313144350213" tabindex="0" loading="lazy"><figcaption>image-20210313144350213</figcaption></figure><p><strong>B+ 树中，非叶子节点只保存索引数据，叶子节点保存索引数据与业务数据</strong>。这样即保证了叶子节点的简约干净，数据量大大减小，又保证了最终能查到对应的业务数。既提高了单次 I/O 数据的有效性，又减少了 I/O 次数，还实现了业务。</p><p>但是，在数据中索引与数据是分离的，不像示例那样的？</p><p>如图：我们只需要把真实的业务数据，换成数据所在地址就可以了，此时，业务数据所在的地址在 B+ 树中充当业务数据。</p><figure><img src="'+p+`" alt="image-20210313144438880" tabindex="0" loading="lazy"><figcaption>image-20210313144438880</figcaption></figure><h2 id="索引的优化方法" tabindex="-1"><a class="header-anchor" href="#索引的优化方法" aria-hidden="true">#</a> 索引的优化方法</h2><ol><li><strong>索引不会包含有NULL值的列</strong>：只要列中包含有NULL值，都将不会被包含在索引中，组合索引中只要有一列有NULL值，那么这一列对于此条组合索引就是无效的。所以我们在数据库设计时，不要让索引字段的默认值为NULL。</li><li><strong>使用短索引</strong>：假设，如果有一个数据类型为CHAR(255)的列，在前10个或20个字符内，绝大部分数据的值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省I/O操作。</li><li><strong>索引列排序</strong>：MySQL查询只使用一个索引，因此如果WHERE子句中已经使用了索引的话，那么ORDER BY中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下，不要使用排序操作；尽量不要包含多个列的排序，如果需要，最好给这些列也创建组合索引。</li><li><strong>LIKE语句操作</strong>：一般情况下，不建议使用LIKE操作；如果非使用不可，如何使用也是一个研究的课题。LIKE &quot;%aaaaa%&quot;不会使用索引，但是LIKE &quot;aaa%&quot;却可以使用索引。</li><li><strong>不要在索引列上进行运算</strong>：在建立索引的原则中，提到了索引列不能进行运算，这里就不再赘述了。</li></ol><h2 id="慢查询优化" tabindex="-1"><a class="header-anchor" href="#慢查询优化" aria-hidden="true">#</a> 慢查询优化</h2><p>以下面慢查询为例：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>select
   count(*) 
from
   task 
where
   status=2 
   and operator_id=20839 
   and operate_time&gt;1371169729 
   and operate_time&lt;1371174603 
   and type=2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据最左匹配原则，最开始的sql语句的索引应该是<code>status、operator_id、type、operate_time</code>的联合索引；其中<code>status、operator_id、type</code>的顺序可以颠倒.</p><p>如果还有以下查询：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>select * from task where status = 0 and type = 12 limit 10;
select count(*) from task where status = 0 ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>么索引建立成<code>(status,type,operator_id,operate_time)</code>就是非常正确的，因为可以覆盖到所有情况。这个就是利用了索引的最左匹配的原则。</p><h3 id="慢查询优化基本步骤" tabindex="-1"><a class="header-anchor" href="#慢查询优化基本步骤" aria-hidden="true">#</a> 慢查询优化基本步骤</h3><ol><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li><code>where</code>条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li><li><code>explain</code>查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li><li><code>order by limit </code>形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建索引的几大原则</li><li>观察结果，不符合预期继续从1分析</li></ol><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,49),h={href:"https://tech.meituan.com/2014/06/30/mysql-index.html",target:"_blank",rel:"noopener noreferrer"},b=e("li",null,[e("p",null,"https://blog.csdn.net/mysteryhaohao/article/details/51719871")],-1),v=e("li",null,[e("p",null,"https://segmentfault.com/a/1190000015416513")],-1);function _(f,y){const o=a("ExternalLinkIcon");return s(),n("div",null,[u,e("ul",null,[e("li",null,[e("p",null,[e("a",h,[l("MySQL索引原理及慢查询优化"),t(o)])])]),b,v])])}const x=i(m,[["render",_],["__file","MySQL索引详解.html.vue"]]);export{x as default};
