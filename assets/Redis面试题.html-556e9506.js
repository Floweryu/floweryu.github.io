const l=JSON.parse('{"key":"v-1d7a53d0","path":"/redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Redis面试题","lang":"zh-CN","frontmatter":{"title":"Redis面试题","category":["Redis"],"tag":["后端","中间件"],"date":"2023-11-09T19:05:00.000Z","headerDepth":6,"description":"缓存击穿/缓存穿透/缓存雪崩 缓存穿透 缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。 如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。 布隆过滤器 布隆过滤器「Bloom Filter，简称BF...","head":[["meta",{"property":"og:url","content":"https://floweryu.top/redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"Floweryu"}],["meta",{"property":"og:title","content":"Redis面试题"}],["meta",{"property":"og:description","content":"缓存击穿/缓存穿透/缓存雪崩 缓存穿透 缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。 如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。 布隆过滤器 布隆过滤器「Bloom Filter，简称BF..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://floweryu.top/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-01T09:52:52.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Redis面试题"}],["meta",{"property":"article:author","content":"Floweryu"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:published_time","content":"2023-11-09T19:05:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-01T09:52:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis面试题\\",\\"image\\":[\\"https://floweryu.top/\\"],\\"datePublished\\":\\"2023-11-09T19:05:00.000Z\\",\\"dateModified\\":\\"2023-12-01T09:52:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Floweryu\\",\\"url\\":\\"https://github.com/Floweryu/floweryu.github.io\\",\\"email\\":\\"869830837@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"缓存击穿/缓存穿透/缓存雪崩","slug":"缓存击穿-缓存穿透-缓存雪崩","link":"#缓存击穿-缓存穿透-缓存雪崩","children":[{"level":3,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[{"level":4,"title":"布隆过滤器","slug":"布隆过滤器","link":"#布隆过滤器","children":[]},{"level":4,"title":"缓存空对象","slug":"缓存空对象","link":"#缓存空对象","children":[]}]},{"level":3,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[{"level":4,"title":"使用互斥锁「mutex key」","slug":"使用互斥锁「mutex-key」","link":"#使用互斥锁「mutex-key」","children":[]},{"level":4,"title":"热点数据永不过期","slug":"热点数据永不过期","link":"#热点数据永不过期","children":[]}]},{"level":3,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[{"level":4,"title":"均匀过期","slug":"均匀过期","link":"#均匀过期","children":[]},{"level":4,"title":"加互斥锁","slug":"加互斥锁","link":"#加互斥锁","children":[]},{"level":4,"title":"缓存永不过期","slug":"缓存永不过期","link":"#缓存永不过期","children":[]},{"level":4,"title":"双层缓存策略","slug":"双层缓存策略","link":"#双层缓存策略","children":[]}]},{"level":3,"title":"缓存预热","slug":"缓存预热","link":"#缓存预热","children":[{"level":4,"title":"缓存预热的操作方法","slug":"缓存预热的操作方法","link":"#缓存预热的操作方法","children":[]}]},{"level":3,"title":"缓存降级","slug":"缓存降级","link":"#缓存降级","children":[]}]},{"level":2,"title":"Redis 线程模型","slug":"redis-线程模型","link":"#redis-线程模型","children":[{"level":3,"title":"Redis 单线程为什么还这么快","slug":"redis-单线程为什么还这么快","link":"#redis-单线程为什么还这么快","children":[]},{"level":3,"title":"Redis 6.0 之后为什么引入了多线程","slug":"redis-6-0-之后为什么引入了多线程","link":"#redis-6-0-之后为什么引入了多线程","children":[]}]},{"level":2,"title":"Redis 持久化","slug":"redis-持久化","link":"#redis-持久化","children":[{"level":3,"title":"如何实现数据不丢失","slug":"如何实现数据不丢失","link":"#如何实现数据不丢失","children":[]},{"level":3,"title":"AOF 持久化","slug":"aof-持久化","link":"#aof-持久化","children":[{"level":4,"title":"AOF持久化的实现","slug":"aof持久化的实现","link":"#aof持久化的实现","children":[]},{"level":4,"title":"AOF 写回策略","slug":"aof-写回策略","link":"#aof-写回策略","children":[]},{"level":4,"title":"AOF 文件过大重写","slug":"aof-文件过大重写","link":"#aof-文件过大重写","children":[]}]},{"level":3,"title":"RDB持久化","slug":"rdb持久化","link":"#rdb持久化","children":[{"level":4,"title":"RDB 快照会阻塞主线程吗","slug":"rdb-快照会阻塞主线程吗","link":"#rdb-快照会阻塞主线程吗","children":[]},{"level":4,"title":"RDB 执行快照时，数据能修改吗","slug":"rdb-执行快照时-数据能修改吗","link":"#rdb-执行快照时-数据能修改吗","children":[]},{"level":4,"title":"SAVE命令执行时服务器状态","slug":"save命令执行时服务器状态","link":"#save命令执行时服务器状态","children":[]},{"level":4,"title":"BGSAVE命令执行时服务器状态","slug":"bgsave命令执行时服务器状态","link":"#bgsave命令执行时服务器状态","children":[]},{"level":4,"title":"RDB文件载入时服务器状态","slug":"rdb文件载入时服务器状态","link":"#rdb文件载入时服务器状态","children":[]},{"level":4,"title":"自动间隔性保存","slug":"自动间隔性保存","link":"#自动间隔性保存","children":[{"level":5,"title":"dirty 计数器和 lastsave 属性","slug":"dirty-计数器和-lastsave-属性","link":"#dirty-计数器和-lastsave-属性","children":[]}]},{"level":4,"title":"检查保存条件是否满足","slug":"检查保存条件是否满足","link":"#检查保存条件是否满足","children":[]},{"level":4,"title":"RDB文件结构","slug":"rdb文件结构","link":"#rdb文件结构","children":[{"level":5,"title":"databases部分","slug":"databases部分","link":"#databases部分","children":[]},{"level":5,"title":"key_value_pairs部分","slug":"key-value-pairs部分","link":"#key-value-pairs部分","children":[]}]}]},{"level":3,"title":"混合持久化","slug":"混合持久化","link":"#混合持久化","children":[]},{"level":3,"title":"大 key 对持久化的影响","slug":"大-key-对持久化的影响","link":"#大-key-对持久化的影响","children":[{"level":4,"title":"对 AOF 持久化的影响","slug":"对-aof-持久化的影响","link":"#对-aof-持久化的影响","children":[]},{"level":4,"title":"对 AOF 文件重写和 RDB 的影响","slug":"对-aof-文件重写和-rdb-的影响","link":"#对-aof-文件重写和-rdb-的影响","children":[]},{"level":4,"title":"其他影响","slug":"其他影响","link":"#其他影响","children":[]}]}]},{"level":2,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[{"level":3,"title":"初次同步","slug":"初次同步","link":"#初次同步","children":[{"level":4,"title":"第一阶段","slug":"第一阶段","link":"#第一阶段","children":[]},{"level":4,"title":"第二阶段","slug":"第二阶段","link":"#第二阶段","children":[]},{"level":4,"title":"第三阶段","slug":"第三阶段","link":"#第三阶段","children":[]}]},{"level":3,"title":"命令传播","slug":"命令传播","link":"#命令传播","children":[]},{"level":3,"title":"分摊主服务器压力","slug":"分摊主服务器压力","link":"#分摊主服务器压力","children":[]},{"level":3,"title":"增量复制","slug":"增量复制","link":"#增量复制","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]},{"level":3,"title":"主从异步复制丢失解决方案","slug":"主从异步复制丢失解决方案","link":"#主从异步复制丢失解决方案","children":[]},{"level":3,"title":"集群脑裂导致数据丢失","slug":"集群脑裂导致数据丢失","link":"#集群脑裂导致数据丢失","children":[]},{"level":3,"title":"面试题链接","slug":"面试题链接","link":"#面试题链接","children":[]}]},{"level":2,"title":"哨兵模式","slug":"哨兵模式","link":"#哨兵模式","children":[{"level":3,"title":"哨兵机制","slug":"哨兵机制","link":"#哨兵机制","children":[]},{"level":3,"title":"如何判断节点真的故障？","slug":"如何判断节点真的故障","link":"#如何判断节点真的故障","children":[]},{"level":3,"title":"如何进行主从故障转移？","slug":"如何进行主从故障转移","link":"#如何进行主从故障转移","children":[{"level":4,"title":"如何选举哨兵 Leader","slug":"如何选举哨兵-leader","link":"#如何选举哨兵-leader","children":[]},{"level":4,"title":"为何哨兵至少要有3个","slug":"为何哨兵至少要有3个","link":"#为何哨兵至少要有3个","children":[]}]},{"level":3,"title":"小结","slug":"小结-1","link":"#小结-1","children":[]},{"level":3,"title":"主从故障转移的过程","slug":"主从故障转移的过程","link":"#主从故障转移的过程","children":[{"level":4,"title":"步骤一：选出新主节点","slug":"步骤一-选出新主节点","link":"#步骤一-选出新主节点","children":[{"level":5,"title":"选举优先级","slug":"选举优先级","link":"#选举优先级","children":[]}]},{"level":4,"title":"步骤二：将从节点指向新主节点","slug":"步骤二-将从节点指向新主节点","link":"#步骤二-将从节点指向新主节点","children":[]},{"level":4,"title":"步骤三：通知客户端更换主节点","slug":"步骤三-通知客户端更换主节点","link":"#步骤三-通知客户端更换主节点","children":[]},{"level":4,"title":"步骤四：将旧主节点该为从节点","slug":"步骤四-将旧主节点该为从节点","link":"#步骤四-将旧主节点该为从节点","children":[]}]},{"level":3,"title":"哨兵集群如何组成","slug":"哨兵集群如何组成","link":"#哨兵集群如何组成","children":[]},{"level":3,"title":"参考","slug":"参考","link":"#参考","children":[]}]},{"level":2,"title":"Redis 过期删除","slug":"redis-过期删除","link":"#redis-过期删除","children":[{"level":3,"title":"惰性删除策略","slug":"惰性删除策略","link":"#惰性删除策略","children":[]},{"level":3,"title":"定期删除策略","slug":"定期删除策略","link":"#定期删除策略","children":[]},{"level":3,"title":"持久化时处理过期键","slug":"持久化时处理过期键","link":"#持久化时处理过期键","children":[{"level":4,"title":"RDB 持久化处理过期 key","slug":"rdb-持久化处理过期-key","link":"#rdb-持久化处理过期-key","children":[]},{"level":4,"title":"AOF 持久化处理过期 key","slug":"aof-持久化处理过期-key","link":"#aof-持久化处理过期-key","children":[]}]}]},{"level":2,"title":"Redis 内存淘汰","slug":"redis-内存淘汰","link":"#redis-内存淘汰","children":[]}],"git":{"createdTime":1699954242000,"updatedTime":1701424372000,"contributors":[{"name":"zhangjunfeng","email":"im.zhangjunfeng@qq.com","commits":9},{"name":"Floweryu","email":"im.zhangjunfeng@qq.com","commits":4}]},"readingTime":{"minutes":55.4,"words":16621},"filePathRelative":"redis/Redis面试题.md","localizedDate":"2023年11月9日","autoDesc":true}');export{l as data};
