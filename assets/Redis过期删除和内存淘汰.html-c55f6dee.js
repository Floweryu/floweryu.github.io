import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as l,a as r}from"./app-cdfe8373.js";const a={},s=r('<h2 id="redis-过期删除" tabindex="-1"><a class="header-anchor" href="#redis-过期删除" aria-hidden="true">#</a> Redis 过期删除</h2><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><p>当查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在：则正常读取键值。</li><li>如果存在：则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p><h3 id="惰性删除策略" tabindex="-1"><a class="header-anchor" href="#惰性删除策略" aria-hidden="true">#</a> 惰性删除策略</h3><p>惰性删除策略的做法是：<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p>『 优点』</p><ul><li>每次访问时，才会检查 key 是否过期，只会使用很少的系统资源，节省 CPU 资源。</li></ul><p>『 缺点』</p><ul><li>浪费内存。当一个 key 过期，只要还没有被访问，占用的内存就不会被释放。</li></ul><h3 id="定期删除策略" tabindex="-1"><a class="header-anchor" href="#定期删除策略" aria-hidden="true">#</a> 定期删除策略</h3><p>定期删除策略的做法是：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p>定期删除流程：</p><ol><li>从过期字典中随机抽取 20 个 key。</li><li>检查这 20 个 Key 是否过期，并删除已经过期的 key。</li><li>如果本轮检查的已过期 key 的数量，超过 5 个，也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。最大程度节约 CPU 资源。</li></ol><p>定期删除是一个循环，为了保证线程循环卡死，定期删除循环流程上限默认不超过 25 ms。</p><p>『 优点』</p><ul><li>通过限制删除执行时长时间和频率，减少删除操作对 CPU 的影响，同时也清除了一部分过期数据。</li></ul><p>『 缺点』</p><ul><li>不容易确定删除操作执行时长和频率。执行太频繁对 CPU 不友好，执行不频繁跟惰性删除没区别，过期 key 占用的内存不能释放。</li></ul><h3 id="持久化时处理过期键" tabindex="-1"><a class="header-anchor" href="#持久化时处理过期键" aria-hidden="true">#</a> 持久化时处理过期键</h3><h4 id="rdb-持久化处理过期-key" tabindex="-1"><a class="header-anchor" href="#rdb-持久化处理过期-key" aria-hidden="true">#</a> RDB 持久化处理过期 key</h4><p>【RDB 文件生产阶段】</p><p>从内存态转化为 RDB 文件时，会对 key 进行过期检查，过期的键不会被保存到新 RDB 文件中，所以过期键不会对新生成的 RDB 文件产生任何影响。</p><p>【RDB 文件加载阶段】</p><p>分下面两种情况：</p><ul><li>「主服务器」运行：在载入 RDB 文件时会对文件中保存的键进行检查，过期键「不会」被载入到数据库中。</li><li>「从服务器」运行：在载入 RDB 文件时，无论 key 是否过期都会载入到数据库中。但在主从复制时，从服务器数据会被清空。</li></ul><h4 id="aof-持久化处理过期-key" tabindex="-1"><a class="header-anchor" href="#aof-持久化处理过期-key" aria-hidden="true">#</a> AOF 持久化处理过期 key</h4><p>【AOF 文件写入阶段】</p><p>在以 AOF 持久化的过程中，如果数据库某个过期 key 还没有被删除，AOF 文件会保留此过期 key。然后在过期 key 被删除后，向 AOF 文件中追加一条 DEL 命令显示删除过期 key。</p><p>【AOF 重写阶段】</p><p>在执行 AOF 重写时，已经过期的 key 不会被保存到重写后的 AOF 文件中。</p><h2 id="redis-内存淘汰" tabindex="-1"><a class="header-anchor" href="#redis-内存淘汰" aria-hidden="true">#</a> Redis 内存淘汰</h2><ul><li><strong>noeviction</strong>：当运行内存超过设置的最大内存后，不淘汰任何数据，而是不再提供服务，直接返回错误。</li><li><strong>volatile-ttl</strong>：优先淘汰最早过期的 key。</li><li><strong>allkeys-lru</strong>：淘汰「整个键值」中最久未使用的 key。</li><li><strong>allkeys-lfu</strong>：淘汰「整个键值」中最少「最近使用频率少」使用的 key。</li><li><strong>volatile-lru</strong>：淘汰「设置了过期时间」的 key 中，最久未使用的 key。</li><li><strong>volatile-lfu</strong>：淘汰「设置了过期时间」的 key 中，最少「最近使用频率少」使用的 key。</li><li><strong>allkeys-random</strong>：「整个键值」中随机淘汰任意键值。</li><li><strong>volatile-random</strong>：「设置了过期时间」的 key 随机淘汰。</li></ul>',34),t=[s];function n(o,d){return i(),l("div",null,t)}const y=e(a,[["render",n],["__file","Redis过期删除和内存淘汰.html.vue"]]);export{y as default};
