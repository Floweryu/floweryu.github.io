import{_ as a,a as c,b as r,c as s,d as l,e as t,f as n,g as p,h as g,i as h,j as u,k as b}from"./OiWZSKRYubopGBf-ae9e398e.js";import{_ as A}from"./plugin-vue_export-helper-c27b6911.js";import{r as f,o as R,c as m,b as e,d as o,e as O,a as d}from"./app-c589b14c.js";const F={},_=d('<h2 id="redis-持久化" tabindex="-1"><a class="header-anchor" href="#redis-持久化" aria-hidden="true">#</a> Redis 持久化</h2><h3 id="如何实现数据不丢失" tabindex="-1"><a class="header-anchor" href="#如何实现数据不丢失" aria-hidden="true">#</a> 如何实现数据不丢失</h3><blockquote><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p></blockquote><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里。</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘。</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点。</li></ul><h3 id="aof-持久化" tabindex="-1"><a class="header-anchor" href="#aof-持久化" aria-hidden="true">#</a> AOF 持久化</h3><p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><blockquote><p>优点：</p><ol><li>每一次修改都同步，文件完成性更好</li><li>每秒同步一次，可能会丢失一秒数据</li></ol><p>缺点：</p><ol><li>相对于文件大小，aof远远大于rdb，修复速度也比rdb慢</li><li>aof运行效率比rdb慢</li></ol></blockquote><h4 id="aof持久化的实现" tabindex="-1"><a class="header-anchor" href="#aof持久化的实现" aria-hidden="true">#</a> AOF持久化的实现</h4><figure><img src="'+a+'" alt="image-20231115203225347" tabindex="0" loading="lazy"><figcaption>image-20231115203225347</figcaption></figure><p><strong>命令追加</strong></p><p>AOF打开后，服务器在写完一个命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区末尾。</p><p><strong>先执行命令，再写入日志</strong></p><p><strong>好处</strong>：</p><ul><li><strong>避免额外检查开销</strong>。假如先写入 AOF 日志，再执行命令，如果该命令语法有问题，不进行语法检查的话，在使用日志恢复数据时就会出错。</li><li><strong>不会因写入日志阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p><strong>风险</strong>：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><h4 id="aof-写回策略" tabindex="-1"><a class="header-anchor" href="#aof-写回策略" aria-hidden="true">#</a> AOF 写回策略</h4><p>Redis 写入 AOF 过程如下图：</p><img src="'+c+'" alt="image-20231115205550491" style="zoom:50%;"><p>通过配置<code>appendfsync</code>选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>值为<code>always</code>时，服务器每个事件循环都要将<code>aof_buf</code>缓冲区中的内容写入到AOF文件，并且同步AOF文件。<code>always</code>的效率最低，但是安全性最高。</li><li>值为<code>everysec</code>时，服务器在每个事件循环都将<code>aof_buf</code>缓冲区中所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。效率上足够快，就算故障，<strong>最多会丢失2秒数据</strong>。</li><li>值为<code>no</code>时，服务器在每个事件循环都将<code>aof_buf</code>缓冲区中所有内容写入到AOF文件，至于何时同步，就有操作系统控制。</li></ul><p><strong>为什么最多会丢失2秒数据呢</strong></p><p>除了首次命令写入操作之外，后面所有写入操作，Redis 主线程会负责对比上次 AOF 同步时间：</p><ul><li>如果距上次同步成功时间在 2 秒内：主线程直接返回。</li><li>如果距上次同步成功时间超过 2 秒：主线程将调用 AOF 磁盘同步线程进行阻塞，直到磁盘同步操作完成，此时 Redis 不可用。</li></ul><p>按照上面规则，主线程在命令写入后会调用系统的<code>write</code>操作，<code>write</code>执行完成后主线程返回。然后文件同步<code>fsync</code>线程每秒调用一次将命令写入磁盘。</p><p>问题在于：如果硬盘负载过高，同步操作可能会超过 1 秒，这时如果主线程仍然继续向缓冲区写入命令，硬盘负载会越来越大（<code>fsync</code>线程处理不过来）。如果在第 2 秒时 Redis 停机，则最近两秒内的数据将不会写入磁盘，就会丢失。</p><figure><img src="'+r+'" alt="image-20231119131028701" tabindex="0" loading="lazy"><figcaption>image-20231119131028701</figcaption></figure><h4 id="aof-文件过大重写" tabindex="-1"><a class="header-anchor" href="#aof-文件过大重写" aria-hidden="true">#</a> AOF 文件过大重写</h4><p>随着写操作命令越来越多，AOF 文件也会越来越大，就会带来性能问题，重启 Redis 恢复数据就会很慢。</p><p>为了避免 AOF 文件过大，使用了 AOF 重写机制：当 AOF 文件大小超过阈值，就会对 AOF 文件进行压缩。</p><p><strong>原理</strong>：在重写时，读取当前数据库中所有键值对，将每个键值对用一条命令记录到<strong>新 AOF 文件</strong>，全部记录完成后，用新的 AOF 文件替换掉现有的 AOF 文件。</p><blockquote><p>示例：</p><p>在没有重写前，假如执行：<code>set example a</code> 和 <code>set example b</code>这两个命令，就会将这两个命令写入到 AOF 文件。</p><p>重写后：AOF 文件中只有 <code>set example b</code> 这一条命令。由此可见进行了压缩。</p></blockquote><p>重写过程是由<strong>子进程</strong>完成的，主进程可以继续处理命令请求。</p><blockquote><p>为什么不用线程？</p><p>因为多线程会共享内存，修改数据时需要加锁保证数据安全，就会降低性能。</p><p>而父子进程是共享内存数据的，共享的内存只能以<strong>只读</strong>方式，当父子进程任意一方修改共享内存，就会发生<strong>写时复制</strong>，父子进行就有独立的数据副本，不需要加锁来保证数据安全。简记：<strong>读时共享，写时复制</strong>。</p></blockquote><p><strong>重写过程中，主进程依然可以正常处理命令</strong>。所以对于同一个 key ，可能会存在主进程和子进程内存数据不一致的情况。</p><p>Redis 通过设置 <strong>AOF 重写缓冲区</strong> 来解决上面问题，这个缓冲区在重写子进程创建后使用。</p><p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><figure><img src="'+s+'" alt="image-20231119135006679" tabindex="0" loading="lazy"><figcaption>image-20231119135006679</figcaption></figure><p>也就是说，在重写子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到 「AOF 缓冲区」。</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」。</li></ul><p>子进程完成 AOF 重写工作，会向主进程发送一条信号。<strong>主进程</strong>收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 <strong>AOF 重写缓冲区</strong>中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致。</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul>',43),B={href:"https://xiaolincoding.com/redis/storage/aof.html",target:"_blank",rel:"noopener noreferrer"},v=d('<h3 id="rdb持久化" tabindex="-1"><a class="header-anchor" href="#rdb持久化" aria-hidden="true">#</a> RDB持久化</h3><blockquote><p>上面介绍的 AOF 持久化记录的是操作命令，在恢复数据时需要将命令再执行一遍，当命令量大时，很耗费时间，恢复数据就很慢。</p></blockquote><p>RDB持久化是把<strong>实际数据生成快照保存到硬盘的过程</strong>，触发RDB持久化过程分为手动触发和自动触发。</p><p>在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><h4 id="rdb-快照会阻塞主线程吗" tabindex="-1"><a class="header-anchor" href="#rdb-快照会阻塞主线程吗" aria-hidden="true">#</a> RDB 快照会阻塞主线程吗</h4><p>有两个 Redis 命令可以用于生成 RDB 文件，一个是 <code>SAVE</code>，另一个是 <code>BGSAVE</code>。<strong>区别在于是否在主线程里面执行</strong>。</p><ul><li><p><code>SAVE</code> 命令会阻塞Redis服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，<strong>会阻塞主线程</strong>。</p></li><li><p><code>BGSAVE </code>命令会派生出一个子进程，然后由子进程负责创建 RDB 文件。服务器进程（父进程）继续处理命令请求，<strong>不会阻塞主线程</strong>。</p></li></ul><p>RDB 文件的载入工作是在服务器启动时自动执行的，Redis 没有专门用于载入 RDB 文件的命令，只要 Redis 服务器在启动时检测到 RDB 文件存在，它就会自动载入RDB 文件。</p><blockquote><p>💡因为 AFO文件的更新频率通常比RDB文件更新频率更高，所以：</p><ul><li>如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态。</li><li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</li></ul></blockquote><figure><img src="'+l+'" alt="image-20210305104729387" tabindex="0" loading="lazy"><figcaption>image-20210305104729387</figcaption></figure><blockquote><p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p></blockquote><h4 id="rdb-执行快照时-数据能修改吗" tabindex="-1"><a class="header-anchor" href="#rdb-执行快照时-数据能修改吗" aria-hidden="true">#</a> RDB 执行快照时，数据能修改吗</h4><p>执行 <code>bgsave</code> 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>执行 <code>bgsave</code> 命令的时候，会通过 <code>fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 <code>bgsave</code> 子进程互相不影响。</p><img src="'+t+'" alt="image-20231119144608138" style="zoom:50%;"><p>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 <code>bgsave</code> 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><img src="'+n+`" alt="image-20231119144642033" style="zoom:50%;"><h4 id="save命令执行时服务器状态" tabindex="-1"><a class="header-anchor" href="#save命令执行时服务器状态" aria-hidden="true">#</a> <code>SAVE</code>命令执行时服务器状态</h4><p>当<code>SAVE</code>命令执行时，Redis服务器会被阻塞，这时服务器不能处理任何命令请求。</p><h4 id="bgsave命令执行时服务器状态" tabindex="-1"><a class="header-anchor" href="#bgsave命令执行时服务器状态" aria-hidden="true">#</a> <code>BGSAVE</code>命令执行时服务器状态</h4><p><code>BGSAVE</code>命令执行期间，服务器仍可以处理客户端的命令请求。但是，对<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code>这三个命令方式和平时有所不同。</p><p>在<code>BGSAVE</code>命令执行期间，<code>SAVE</code>命令会被服务器拒绝，这是为了避免父进程和子进程同时执行两个<code>rdbSave</code>调用，防止产生竞争条件。</p><p>在<code>BGSAVE</code>命令执行期间，<code>BGSAVE</code>命令也会被服务器拒绝，因为通知执行两个<code>BGSAVE</code>命令也会产生竞争条件。</p><p>最后，<code>BGREWRITEAOF</code>和<code>BGSAVE</code>两个命令不能同时运行：</p><ul><li>如果<code>BGSAVE</code>命令正在执行，那么客户端发送的<code>BGREWRITEAOF</code>命令会被延迟到<code>BGSAVE</code>命令执行完毕之后执行。</li><li>如果<code>BGREWRITEAOF</code>命令正在执行，那么客户端发送的<code>BGSAVE</code>命令会被服务器拒绝。</li></ul><h4 id="rdb文件载入时服务器状态" tabindex="-1"><a class="header-anchor" href="#rdb文件载入时服务器状态" aria-hidden="true">#</a> RDB文件载入时服务器状态</h4><p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完毕为止。</p><h4 id="自动间隔性保存" tabindex="-1"><a class="header-anchor" href="#自动间隔性保存" aria-hidden="true">#</a> 自动间隔性保存</h4><p>因为<code>BGSAVE</code>可以在不阻塞服务器进程下执行，所以允许设置<code>save</code>选项，让服务器每隔一段时间自动执行一次<code>BGSAVE</code>命令。</p><p>可以通过<code>save</code>选项设置多个保存条件，但只要其中一个条件被满足，服务器就会执行<code>BGSAVE</code>命令。</p><blockquote><p>比如下面例子：</p><ul><li><code>save 900 1</code> ：服务器在900秒内，对数据库进行了至少1次修改</li></ul></blockquote><p>『<code>saveparams</code>属性 』</p><p><code>saveparams</code> 属性是一个数组，数组中的每个元素都是一个 <code>saveparam</code> 结构，每个 <code>saveparam</code> 结构都保存了一个 <code>save</code> 选项设置的保存条件：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>struct saveparam {
    time_t seconds; // 秒数
    int changes;  // 修改数
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="dirty-计数器和-lastsave-属性" tabindex="-1"><a class="header-anchor" href="#dirty-计数器和-lastsave-属性" aria-hidden="true">#</a> <code>dirty</code> 计数器和 <code>lastsave</code> 属性</h5><ul><li><code>dirty</code> 计数器记录距离上一次成功执行 <code>SAVE</code> 命令或者 <code>BGSAVE </code>命令后，服务器对数据库状态（所有数据库）进行了多少次修改（删除，更新，写入等）</li><li><code>lastsave</code> 属性是一个 <code>UNIX</code> 时间戳，记录了服务器上一次成功执行 <code>SAVE</code> 或者 <code>BGSAVE</code> 命令的时间。</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>struct redisServer {
    long long dirty;  // 修改计数器
    time_t lastsave;  // 上一次执行保存的时间
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="检查保存条件是否满足" tabindex="-1"><a class="header-anchor" href="#检查保存条件是否满足" aria-hidden="true">#</a> 检查保存条件是否满足</h4><p>Redis周期性操作函数 <code>serverCron</code> 默认每隔100毫秒就会执行一次，该函数用于对正在允许的服务器进行维护，它的一项工作就是检查<code>save</code>选项所设置的保存条件是否已经满足，如果满足，就会执行 <code>BGSAVE</code> 命令。</p><h4 id="rdb文件结构" tabindex="-1"><a class="header-anchor" href="#rdb文件结构" aria-hidden="true">#</a> RDB文件结构</h4><figure><img src="`+p+'" alt="image-20210305135556398" tabindex="0" loading="lazy"><figcaption>image-20210305135556398</figcaption></figure><ul><li><code>REDIS</code> 部分长度为5个字节，保存着<code>REDIS</code>五个字符。通过这五个字符，程序在载入文件时，快速检查所载入的文件是否RDB文件。</li><li><code>db_version</code> 长度为4个字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号。比如<code>0006</code>代表RDB文件版本为第六版。</li><li><code>database </code>部分包含零个或任意多个数据库，以及各个数据库中的键值对数据。 <ul><li>如果服务器数据库状态为空，这个部分也为空，长度为0字节。</li><li>如果服务器数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空。根据数据库保存的键值对的数量、类型和内容的不同，这个部分长度也会有所不同。</li></ul></li><li><code>EOF</code> 常量的长度为1字节，标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，表明所有数据库的所有键值对都已经载入完毕了。</li><li><code>check_sum</code> 是一个8字节长的无符号整数、保存着一个校验和，这个校验和是程序通过对<code>REDIS</code>、<code>db_version</code>、<code>databases</code>、<code>EOF</code>四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与<code>check_sum</code>所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</li></ul><h5 id="databases部分" tabindex="-1"><a class="header-anchor" href="#databases部分" aria-hidden="true">#</a> <strong><code>databases</code>部分</strong></h5><p>一个RDB文件的<code>databases</code>部分可以保存任意多个非空数据库。</p><p>例如，如果服务器的0号和3号数据库非空，则将创建以下结构RDB文件：</p><figure><img src="'+g+'" alt="image-20210305141958845" tabindex="0" loading="lazy"><figcaption>image-20210305141958845</figcaption></figure><p>每个<code>database</code>都包含数据库所有键值对。</p><p>每个非空数据库在RDB文件中都可以保存为<code>SELECTDB</code>、<code>db_number</code>、<code>key_value_pairs</code>三个部分。</p><figure><img src="'+h+'" alt="image-20210305142202954" tabindex="0" loading="lazy"><figcaption>image-20210305142202954</figcaption></figure><ul><li><code>SELECTDB</code>常量的长度为1字节，标示将要读入的数据库号码。</li><li><code>db_number</code>保存着一个数据库号码，根据号码大小不同，这个部分长度可以是1字节、2字节、5字节等。当程序读入<code>db_number</code>部分后，服务器会调用<code>SELECT</code>命令，根据读入的数据库号码进行数据库的切换，使得读入的键值对可以正确载入到数据库中。</li><li><code>key_value_pairs</code>部分保存了数据库中所有键值对数据，如果键值对带有过期时间，则过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，<code>key_value_pairs</code>部分的长度也会有所不同。</li></ul><h5 id="key-value-pairs部分" tabindex="-1"><a class="header-anchor" href="#key-value-pairs部分" aria-hidden="true">#</a> <code>key_value_pairs</code>部分</h5><p>RDB文件中的每个<code>key_value_pairs</code>部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p><p>不带过期时间的键值对如下：</p><figure><img src="'+u+'" alt="image-20210305202119931" tabindex="0" loading="lazy"><figcaption>image-20210305202119931</figcaption></figure><ul><li><code>TYPE</code>记录了<code>value</code>类型，长度为1字节。</li><li><code>KEY</code>总是一个字符串对象。</li><li>根据<code>TYPE</code>类型不同，以及保存内容长度的不同，保存<code>value</code>的结构和长度也会有所不同</li></ul><p>带有过期时间的键值对如下：</p><figure><img src="'+b+'" alt="image-20210305202032401" tabindex="0" loading="lazy"><figcaption>image-20210305202032401</figcaption></figure><ul><li><code>EXPIRETIME_MS</code>常量的长度为1字节，它告知读入程序，接下来要读入的是一个以毫秒为单位的过期时间。</li><li><code>ms</code>是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h3 id="混合持久化" tabindex="-1"><a class="header-anchor" href="#混合持久化" aria-hidden="true">#</a> 混合持久化</h3><p>先看看 AOF 和 RDB 各自优点：</p><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p><p><strong>思考</strong>：AOF 恢复数据过程中导致性能慢的地方在于要重新执行一遍命令，那么在恢复数据时能不能不重新执行命令呢？</p><p><strong>混合持久化</strong>发生在 AOF 重写过程中，由于重写过程由子进程执行，不会阻塞主进程，所以子进程现将与主进程共享的内存数据以 RDB 方式写入 AOF 文件，而不是执行命令。然后主进程在该阶段执行的命令会写到<strong>重写缓冲区</strong>，重写缓冲区里面的增量命令仍以 AOF 方式写入 AOF 文件，最后通知主进程将含有 RDB 格式和 AOF 格式的新 AOF 文件替换旧的 AOF 文件。</p><blockquote><p>为什么增量命令仍以 AOF 方式写入呢？</p><p>因为增量命令写入 AOF 文件这一过程是主进程执行的，直接追加命令的效率比转为 RDB 快照效率更高。</p></blockquote><p>混合持久化后，<strong>AOF 文件前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p><strong>优点</strong>：</p><ul><li>AOF 文件前半部分是 RDB 快照，所以恢复数据更快，Redis 启动更快。</li><li>AOF 文件后半部分是命令，但这部分命令是子进程重写 AOF 期间主进程产生的，命令少，这样数据丢失也少。</li></ul><p>缺点：</p><ul><li>AOF 文件可读性变差，前后部分内容格式不一样。</li><li>兼容性差， Redis 4.0 之前版本无法使用。</li></ul><h3 id="大-key-对持久化的影响" tabindex="-1"><a class="header-anchor" href="#大-key-对持久化的影响" aria-hidden="true">#</a> 大 key 对持久化的影响</h3><h4 id="对-aof-持久化的影响" tabindex="-1"><a class="header-anchor" href="#对-aof-持久化的影响" aria-hidden="true">#</a> 对 AOF 持久化的影响</h4><ul><li><strong>Always 策略</strong>：主线程在执行完命令后，会把数据写入到 AOF 日志文件，如果写入是一个大 key，主线程执行 <code>fsync() </code>函数将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回，阻塞的时间会比较久，当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。</li><li><strong>Everysec 策略</strong>：由于是异步执行 <code>fsync() </code>函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。</li><li><strong>No 策略</strong>：由于永不执行 <code>fsync() </code>函数，所以大 Key 持久化的过程不会影响主线程。</li></ul><h4 id="对-aof-文件重写和-rdb-的影响" tabindex="-1"><a class="header-anchor" href="#对-aof-文件重写和-rdb-的影响" aria-hidden="true">#</a> 对 AOF 文件重写和 RDB 的影响</h4><p>AOF 文件在重写和 RDB 执行 <code>bgsave</code> 命令的时候时，子进程会和父进程共享内存数据，当大 key 越来越多时，就会占用更多内存，对应的页表就会很大。</p><p>在子进程 <code>fork()</code> 函数重写时，内核会把父进程的页表复制一份给子进程，如果页表很大，复制过程会很耗时，在进行重写时就会发生阻塞现象。这样就会阻塞 Redis 主进程，从而无法处理客户端发来的命令。</p><p>可以根据以下条件优化调整子进程耗时：</p><ul><li>单个实例内存占用控制在 10GB 以下，这样子进程 <code>fork()</code> 函数能快速返回。</li><li>如果 Redis 只是当作纯缓存使用，不关心 Redis 数据安全性问题，可以考虑关闭 AOF 和 AOF 重写，这样就不会调用 <code>fork()</code> 函数。</li><li>在主从架构中，要适当调大 <code>repl-backlog-size</code>，避免因为 <code>repl_backlog_buffer</code> 不够大，导致主节点频繁地使用全量同步的方式，全量同步的时候，是会创建 RDB 文件的，也就是会调用 <code>fork()</code> 函数。</li></ul><h4 id="其他影响" tabindex="-1"><a class="header-anchor" href="#其他影响" aria-hidden="true">#</a> 其他影响</h4><p>大 key 除了会影响持久化之外，还会有以下的影响。</p><ul><li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul>',82);function E(k,y){const i=f("ExternalLinkIcon");return R(),m("div",null,[_,e("blockquote",null,[e("p",null,[o("参考："),e("a",B,[o("AOF 持久化是怎么实现的"),O(i)])])]),v])}const V=A(F,[["render",E],["__file","Redis持久化.html.vue"]]);export{V as default};
