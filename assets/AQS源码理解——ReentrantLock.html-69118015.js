const n=JSON.parse(`{"key":"v-6960e60e","path":"/java/AQS%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94ReentrantLock.html","title":"AQS源码理解——ReentrantLock","lang":"zh-CN","frontmatter":{"title":"AQS源码理解——ReentrantLock","date":"2023-10-10T20:25:00.000Z","category":["Java"],"tag":["后端","源码"],"description":"公平锁策略 ReentrantLock类中 FairSync 类源码解读： static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; // 公平锁入口 // 不响应中断的加锁 final void lock() { acquire(1);\\t\\t// （1） } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. * 抢占成功：返回true, 包含重入锁 * 抢占失败：返回false */ protected final boolean tryAcquire(int acquires) { // 获取当前线程 final Thread current = Thread.currentThread(); // 获取AQS中当前status状态 int c = getState(); // 条件成立: c == 0 表示 当前AQS处于无锁的状态 if (c == 0) { // 条件一: hasQueuedPredecessors() // 因为FairSync是公平锁，任何时候获取锁都需要检查一下队列中在当前需要获取锁的线程前有无等待者 // hasQueuedPredecessors()方法返回true表示当前线程前面有等待者, 当前线程需要入队等待 // hasQueuedPredecessors()方法返回false表示当前线程前面无等待者, 直接可以获取锁 // 条件二: compareAndSetState(0, acquires) CAS设置state值, 由于是从条件一进入的此处, 队列中没有线程, CAS的预期值是0 // 成功: 说明当前线程抢占锁成功 // 失败: 说明存在竞争, 且当前线程竞争锁失败 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { // 如果当前线程前面没有等待线程, 并且成功获取到锁 // 设置当前线程为独占锁的线程 setExclusiveOwnerThread(current); return true; } } // 执行到此处的情况：c != 0 或 c &gt; 0 // 这种情况需要判断当前线程是不是独占锁的线程, 因为ReentrantLock是可重入锁 else if (current == getExclusiveOwnerThread()) { // 可重入锁的逻辑 // nextc 是更新AQS的state的值 int nextc = c + acquires; // 越界判断, 当重入的深度很深时, 会导致nextc&lt;0, state的最大值是int, int值达到最大之后 再+1...变负数.. if (nextc &lt; 0) throw new Error(\\"Maximum lock count exceeded\\"); // 设置state的值 setState(nextc); return true; } // 执行到这里的情况 // 1. c==0时, CAS失败, CAS修改state时未抢过其他线程 // 2. c!=0或c&gt;0时, 当前线程不是独占锁线程 return false; } } public final boolean hasQueuedPredecessors() { // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; // 条件一: h!=t 成立, 说明队列中有节点, 既然有节点, 为什么会出现条件二的判断呢？ // 条件二: h.next == null, 在向空队列中新插入节点时, 新插入的节点的前驱与前置节点(这里就是tail)建立了关联，但在head.next还未与新节点连接之前, b会出现这种情况 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); }","head":[["meta",{"property":"og:url","content":"https://floweryu.top/java/AQS%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94ReentrantLock.html"}],["meta",{"property":"og:site_name","content":"Floweryu"}],["meta",{"property":"og:title","content":"AQS源码理解——ReentrantLock"}],["meta",{"property":"og:description","content":"公平锁策略 ReentrantLock类中 FairSync 类源码解读： static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; // 公平锁入口 // 不响应中断的加锁 final void lock() { acquire(1);\\t\\t// （1） } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. * 抢占成功：返回true, 包含重入锁 * 抢占失败：返回false */ protected final boolean tryAcquire(int acquires) { // 获取当前线程 final Thread current = Thread.currentThread(); // 获取AQS中当前status状态 int c = getState(); // 条件成立: c == 0 表示 当前AQS处于无锁的状态 if (c == 0) { // 条件一: hasQueuedPredecessors() // 因为FairSync是公平锁，任何时候获取锁都需要检查一下队列中在当前需要获取锁的线程前有无等待者 // hasQueuedPredecessors()方法返回true表示当前线程前面有等待者, 当前线程需要入队等待 // hasQueuedPredecessors()方法返回false表示当前线程前面无等待者, 直接可以获取锁 // 条件二: compareAndSetState(0, acquires) CAS设置state值, 由于是从条件一进入的此处, 队列中没有线程, CAS的预期值是0 // 成功: 说明当前线程抢占锁成功 // 失败: 说明存在竞争, 且当前线程竞争锁失败 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { // 如果当前线程前面没有等待线程, 并且成功获取到锁 // 设置当前线程为独占锁的线程 setExclusiveOwnerThread(current); return true; } } // 执行到此处的情况：c != 0 或 c &gt; 0 // 这种情况需要判断当前线程是不是独占锁的线程, 因为ReentrantLock是可重入锁 else if (current == getExclusiveOwnerThread()) { // 可重入锁的逻辑 // nextc 是更新AQS的state的值 int nextc = c + acquires; // 越界判断, 当重入的深度很深时, 会导致nextc&lt;0, state的最大值是int, int值达到最大之后 再+1...变负数.. if (nextc &lt; 0) throw new Error(\\"Maximum lock count exceeded\\"); // 设置state的值 setState(nextc); return true; } // 执行到这里的情况 // 1. c==0时, CAS失败, CAS修改state时未抢过其他线程 // 2. c!=0或c&gt;0时, 当前线程不是独占锁线程 return false; } } public final boolean hasQueuedPredecessors() { // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; // 条件一: h!=t 成立, 说明队列中有节点, 既然有节点, 为什么会出现条件二的判断呢？ // 条件二: h.next == null, 在向空队列中新插入节点时, 新插入的节点的前驱与前置节点(这里就是tail)建立了关联，但在head.next还未与新节点连接之前, b会出现这种情况 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-14T09:30:42.000Z"}],["meta",{"property":"article:author","content":"Floweryu"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:tag","content":"源码"}],["meta",{"property":"article:published_time","content":"2023-10-10T20:25:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-14T09:30:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AQS源码理解——ReentrantLock\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-10T20:25:00.000Z\\",\\"dateModified\\":\\"2023-11-14T09:30:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Floweryu\\",\\"url\\":\\"https://floweryu.top\\",\\"email\\":\\"869830837@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"公平锁策略","slug":"公平锁策略","link":"#公平锁策略","children":[]}],"git":{"createdTime":1699954242000,"updatedTime":1699954242000,"contributors":[{"name":"zhangjunfeng","email":"im.zhangjunfeng@qq.com","commits":1}]},"readingTime":{"minutes":12.91,"words":3874},"filePathRelative":"java/AQS源码理解——ReentrantLock.md","localizedDate":"2023年10月10日","excerpt":"<h2> 公平锁策略</h2>\\n<p><strong>ReentrantLock</strong>类中 <strong>FairSync</strong> 类源码解读：</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">final</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">FairSync</span> <span class=\\"token keyword\\">extends</span> <span class=\\"token class-name\\">Sync</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">private</span> <span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">final</span> <span class=\\"token keyword\\">long</span> serialVersionUID <span class=\\"token operator\\">=</span> <span class=\\"token operator\\">-</span><span class=\\"token number\\">3000897897090466540L</span><span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">// 公平锁入口</span>\\n    <span class=\\"token comment\\">// 不响应中断的加锁</span>\\n    <span class=\\"token keyword\\">final</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">lock</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token function\\">acquire</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\t\\t<span class=\\"token comment\\">// （1）</span>\\n    <span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token doc-comment comment\\">/**\\n         * Fair version of tryAcquire.  Don't grant access unless\\n         * recursive call or no waiters or is first.\\n         * 抢占成功：返回true, 包含重入锁\\n         * 抢占失败：返回false\\n         */</span>\\n    <span class=\\"token keyword\\">protected</span> <span class=\\"token keyword\\">final</span> <span class=\\"token keyword\\">boolean</span> <span class=\\"token function\\">tryAcquire</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> acquires<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token comment\\">// 获取当前线程</span>\\n        <span class=\\"token keyword\\">final</span> <span class=\\"token class-name\\">Thread</span> current <span class=\\"token operator\\">=</span> <span class=\\"token class-name\\">Thread</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">currentThread</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token comment\\">// 获取AQS中当前status状态</span>\\n        <span class=\\"token keyword\\">int</span> c <span class=\\"token operator\\">=</span> <span class=\\"token function\\">getState</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n\\n        <span class=\\"token comment\\">// 条件成立: c == 0 表示  当前AQS处于无锁的状态</span>\\n        <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>c <span class=\\"token operator\\">==</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n            <span class=\\"token comment\\">// 条件一: hasQueuedPredecessors()</span>\\n            <span class=\\"token comment\\">// 因为FairSync是公平锁，任何时候获取锁都需要检查一下队列中在当前需要获取锁的线程前有无等待者</span>\\n            <span class=\\"token comment\\">// hasQueuedPredecessors()方法返回true表示当前线程前面有等待者, 当前线程需要入队等待</span>\\n            <span class=\\"token comment\\">// hasQueuedPredecessors()方法返回false表示当前线程前面无等待者, 直接可以获取锁</span>\\n\\n            <span class=\\"token comment\\">// 条件二: compareAndSetState(0, acquires) CAS设置state值, 由于是从条件一进入的此处, 队列中没有线程, CAS的预期值是0</span>\\n            <span class=\\"token comment\\">// 成功: 说明当前线程抢占锁成功</span>\\n            <span class=\\"token comment\\">// 失败: 说明存在竞争, 且当前线程竞争锁失败</span>\\n            <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span><span class=\\"token operator\\">!</span><span class=\\"token function\\">hasQueuedPredecessors</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">&amp;&amp;</span>\\n                <span class=\\"token function\\">compareAndSetState</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">0</span><span class=\\"token punctuation\\">,</span> acquires<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n                <span class=\\"token comment\\">// 如果当前线程前面没有等待线程, 并且成功获取到锁</span>\\n                <span class=\\"token comment\\">// 设置当前线程为独占锁的线程</span>\\n                <span class=\\"token function\\">setExclusiveOwnerThread</span><span class=\\"token punctuation\\">(</span>current<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n                <span class=\\"token keyword\\">return</span> <span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">;</span>\\n            <span class=\\"token punctuation\\">}</span>\\n        <span class=\\"token punctuation\\">}</span>\\n        <span class=\\"token comment\\">// 执行到此处的情况：c != 0 或 c &gt; 0</span>\\n        <span class=\\"token comment\\">// 这种情况需要判断当前线程是不是独占锁的线程, 因为ReentrantLock是可重入锁</span>\\n        <span class=\\"token keyword\\">else</span> <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>current <span class=\\"token operator\\">==</span> <span class=\\"token function\\">getExclusiveOwnerThread</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n            <span class=\\"token comment\\">// 可重入锁的逻辑</span>\\n            <span class=\\"token comment\\">// nextc 是更新AQS的state的值</span>\\n            <span class=\\"token keyword\\">int</span> nextc <span class=\\"token operator\\">=</span> c <span class=\\"token operator\\">+</span> acquires<span class=\\"token punctuation\\">;</span>\\n            <span class=\\"token comment\\">// 越界判断, 当重入的深度很深时, 会导致nextc&lt;0, state的最大值是int, int值达到最大之后 再+1...变负数..</span>\\n            <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>nextc <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span>\\n                <span class=\\"token keyword\\">throw</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Error</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"Maximum lock count exceeded\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n            <span class=\\"token comment\\">// 设置state的值</span>\\n            <span class=\\"token function\\">setState</span><span class=\\"token punctuation\\">(</span>nextc<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n            <span class=\\"token keyword\\">return</span> <span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token punctuation\\">}</span>\\n\\n        <span class=\\"token comment\\">// 执行到这里的情况</span>\\n        <span class=\\"token comment\\">// 1. c==0时, CAS失败, CAS修改state时未抢过其他线程</span>\\n        <span class=\\"token comment\\">// 2. c!=0或c&gt;0时, 当前线程不是独占锁线程</span>\\n        <span class=\\"token keyword\\">return</span> <span class=\\"token boolean\\">false</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">final</span> <span class=\\"token keyword\\">boolean</span> <span class=\\"token function\\">hasQueuedPredecessors</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">// The correctness of this depends on head being initialized</span>\\n    <span class=\\"token comment\\">// before tail and on head.next being accurate if the current</span>\\n    <span class=\\"token comment\\">// thread is first in queue.</span>\\n    <span class=\\"token class-name\\">Node</span> t <span class=\\"token operator\\">=</span> tail<span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// Read fields in reverse initialization order</span>\\n    <span class=\\"token class-name\\">Node</span> h <span class=\\"token operator\\">=</span> head<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token class-name\\">Node</span> s<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">// 条件一: h!=t 成立, 说明队列中有节点, 既然有节点, 为什么会出现条件二的判断呢？</span>\\n    <span class=\\"token comment\\">// 条件二: h.next == null, 在向空队列中新插入节点时, 新插入的节点的前驱与前置节点(这里就是tail)建立了关联，但在head.next还未与新节点连接之前, b会出现这种情况</span>\\n    <span class=\\"token keyword\\">return</span> h <span class=\\"token operator\\">!=</span> t <span class=\\"token operator\\">&amp;&amp;</span>\\n        <span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">(</span>s <span class=\\"token operator\\">=</span> h<span class=\\"token punctuation\\">.</span>next<span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">==</span> <span class=\\"token keyword\\">null</span> <span class=\\"token operator\\">||</span> s<span class=\\"token punctuation\\">.</span>thread <span class=\\"token operator\\">!=</span> <span class=\\"token class-name\\">Thread</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">currentThread</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{n as data};
