import{_ as s,o as n,c as a,d as e}from"./app-75652abe.js";const t="/assets/2dnSaYf8ELbZwvJ-83e40e64.png",p="/assets/oJ8tYES64POIUGk-cb73f132.png",c="/assets/dTis4hCSugZoXyn-57f70e8f.png",o="/assets/E1YPyZ5Tjpk8CIH-00df61fc.png",i={},l=e(`<h2 id="简单动态字符串-sds" tabindex="-1"><a class="header-anchor" href="#简单动态字符串-sds" aria-hidden="true">#</a> 简单动态字符串（SDS）</h2><h3 id="sds的定义" tabindex="-1"><a class="header-anchor" href="#sds的定义" aria-hidden="true">#</a> SDS的定义</h3><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>struct sdshdr {
    int len; // 记录buf数组中已使用的字节两，等于SDS所保存的字符串长度
    int free;	// 记录buf数组中未使用的字节数量
    char buf[]; // 字节数组，用于保存字符串
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+t+`" alt="image-20210306123735804"></p><h3 id="sds与c字符串的区别" tabindex="-1"><a class="header-anchor" href="#sds与c字符串的区别" aria-hidden="true">#</a> SDS与C字符串的区别</h3><ul><li><strong>常数复杂度获取字符串长度</strong></li><li><strong>杜绝缓存区溢出</strong>：当SDS进行修改时，会先检查SDS的空间是否满足修改所需的要求，若不满足，会自动扩容，然后再执行修改。</li><li><strong>减少修改字符串时带来的内存重分配次数</strong>：每次修改字符串都会重新分配空间，会对性能造成影响。 <ul><li>空间预分配：用于优化SDS字符串增长操作。</li><li>惰性空间释放：用于优化SDS字符串缩短操作。</li></ul></li></ul><h2 id="linkedlist链表" tabindex="-1"><a class="header-anchor" href="#linkedlist链表" aria-hidden="true">#</a> LinkedList链表</h2><h3 id="链表和链表节点的实现" tabindex="-1"><a class="header-anchor" href="#链表和链表节点的实现" aria-hidden="true">#</a> 链表和链表节点的实现</h3><p><code>adlist.h/listNode</code>结构如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> listNode<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>adlist.h/list</code>结构如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">{</span>
    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>	<span class="token comment">// 表头节点</span>
    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>	<span class="token comment">// 表尾节点</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>	<span class="token comment">// 链表所包含的节点数量</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 节点值复制函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 节点释放函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 节点值对比函数</span>
<span class="token punctuation">}</span> list<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis实现的链表特性如下：</p><ul><li>双端：获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头指针和表尾指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针</li><li>带链表长度计数器</li><li>多态：链表节点使用<code>void*</code>指针来保存节点值，并且可以通过<code>list</code>结构的<code>dup、free、match</code>三个属性为节点值设置类型特定函数，链表可以用于保存不同类型的值。</li></ul><h2 id="字典-dict" tabindex="-1"><a class="header-anchor" href="#字典-dict" aria-hidden="true">#</a> 字典(Dict)</h2><h3 id="字典的实现" tabindex="-1"><a class="header-anchor" href="#字典的实现" aria-hidden="true">#</a> 字典的实现</h3><p>Redis底层字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>
    dictRntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>	<span class="token comment">// 哈希表数组</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>	<span class="token comment">// 哈希表大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span> <span class="token comment">//哈希表大小掩码，用于计算索引值，总是等于size=1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>	<span class="token comment">//哈希表已有节点的数量</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="哈希表节点" tabindex="-1"><a class="header-anchor" href="#哈希表节点" aria-hidden="true">#</a> 哈希表节点</h4><p>使用<code>dictEntry</code>结构表示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        uint64_tu64<span class="token punctuation">;</span>
        int64_ts64<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>key</code>保存键，<code>v</code>保存值，<code>next</code>指针指向下一个节点.</p><h4 id="字典" tabindex="-1"><a class="header-anchor" href="#字典" aria-hidden="true">#</a> 字典</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>	<span class="token comment">// 类型特定函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>	<span class="token comment">// 私有数据</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 哈希表</span>
    <span class="token keyword">int</span> trehashidx<span class="token punctuation">;</span> <span class="token comment">// rehash索引，当rehash值不在，值为1</span>
<span class="token punctuation">}</span> dict<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="哈希算法" tabindex="-1"><a class="header-anchor" href="#哈希算法" aria-hidden="true">#</a> 哈希算法</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 使用字典设置的哈希函数，计算键key的哈希值</span>
hash <span class="token operator">=</span> dict<span class="token operator">-&gt;</span>type<span class="token operator">-&gt;</span><span class="token function">hashFunction</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用哈希表的sizemask属性和哈希值，计算出索引值</span>
index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> dict<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="解决键冲突" tabindex="-1"><a class="header-anchor" href="#解决键冲突" aria-hidden="true">#</a> 解决键冲突</h4><p>链地址法：总是将新节点添加到链表表头的位置。</p><p><img src="`+p+'" alt="image-20210306143633380"></p><h2 id="跳跃表-skip-list" tabindex="-1"><a class="header-anchor" href="#跳跃表-skip-list" aria-hidden="true">#</a> 跳跃表(Skip List)</h2><p><img src="'+c+`" alt="image-20210306181234657"></p><p>图片最左侧是跳跃表结构：</p><ul><li><code>header</code>：跳跃表头节点</li><li><code>tail</code>：指向跳跃表的表头节点</li><li><code>level</code>：记录目前跳跃表内，层数最大的那个节点的层数（表头节点层数不计算再内）</li><li><code>length</code>：记录跳跃表的长度，即跳跃表目前包含节点的数量（表头节点不计算在内）</li><li>后退指针<code>BW</code>：指向位于当前节点的前一个节点</li><li>分值<code>score</code>：节点按照各自保存的分支从小到大排列</li></ul><h3 id="跳跃表节点" tabindex="-1"><a class="header-anchor" href="#跳跃表节点" aria-hidden="true">#</a> 跳跃表节点</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>
    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span> <span class="token comment">//后向指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span><span class="token comment">//每一层中的前向指针</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span><span class="token comment">//x.level[i].span 表示节点x在第i层到其下一个节点需跳过的节点数。注：两个相邻节点span为1</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>level</code>数组可以包含多个元素，每个元素都包含一个指向其它节点的指针。</p><p>每次创建一个新的跳跃表节点的时候，程序根据幂次定律(越大的数出现的而概率越小)随机生成一个介于1和32之间的值作为<code>level</code>数组的大小。</p><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个节点保存的分值可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序。</p><h2 id="整数集合-intset" tabindex="-1"><a class="header-anchor" href="#整数集合-intset" aria-hidden="true">#</a> 整数集合(intset)</h2><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span>	<span class="token comment">// 编码方式</span>
    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>	<span class="token comment">// 包含元素数量</span>
    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 保存元素的数组</span>
<span class="token punctuation">}</span> intset<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>contents</code>中的数据是从小到大排列，并且数组中不包含重复项</li><li><code>length</code>记录包含元素数量，也是<code>contents</code>数组的长度</li></ul><p><strong>升级</strong></p><p>当新元素类型比现在集合中元素类型要长时，需要对集合进行升级。</p><ol><li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放到正确的位置上，需要维持有序性不变。</li></ol><h2 id="压缩列表-ziplist" tabindex="-1"><a class="header-anchor" href="#压缩列表-ziplist" aria-hidden="true">#</a> 压缩列表(ziplist)</h2><p><img src="`+o+'" alt="image-20210306204120032"></p>',46),d=[l];function r(u,k){return n(),a("div",null,d)}const m=s(i,[["render",r],["__file","Redisshujujiegouyuduixiang.html.vue"]]);export{m as default};
