import{_ as a}from"./LPN9gcpd58yJAsG-0bea4885.js";import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as r,a as h}from"./app-998b7412.js";const d={},p=h('<h2 id="缓存击穿-缓存穿透-缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存击穿-缓存穿透-缓存雪崩" aria-hidden="true">#</a> 缓存击穿/缓存穿透/缓存雪崩</h2><h3 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h3><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。</p><p>如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。</p><h4 id="布隆过滤器" tabindex="-1"><a class="header-anchor" href="#布隆过滤器" aria-hidden="true">#</a> 布隆过滤器</h4><p>布隆过滤器「Bloom Filter，简称BF」由Burton Howard Bloom在1970年提出，是一种空间效率高的概率型数据结构。</p><p>布隆过滤器专门用来检测集合中是否存在特定的元素。</p><p>如果在平时我们要判断一个元素是否在一个集合中，通常会采用查找比较的方法，下面分析不同的数据结构查找效率：</p><ul><li>采用线性表存储，查找时间复杂度为 <code>O(N)</code></li><li>采用平衡二叉排序树「AVL、红黑树」存储，查找时间复杂度为 <code>O(logN)</code></li><li>采用哈希表存储，考虑到哈希碰撞，整体时间复杂度也要 <code>O[log(n/m)]</code></li></ul><p>当需要判断一个元素是否存在于海量数据集合中，不仅查找时间慢，还会占用大量存储空间。接下来看一下布隆过滤器如何解决这个问题。</p><p><strong>布隆过滤器设计思想</strong></p><p>布隆过滤器由一个长度为 m 比特的位数组「bit array」与k个哈希函数「hash function」组成的数据结构。位数组初始化均为 0，所有的哈希函数都可以分别把输入数据尽量均匀地散列。</p><p>当要向布隆过滤器中插入一个元素时，该元素经过 k 个哈希函数计算产生 k 个哈希值，以哈希值作为位数组中的下标，将所有 k 个对应的比特值由 0 置为 1 。</p><p>当要查询一个元素时，同样将其经过哈希函数计算产生哈希值，然后检查对应的 k 个比特值：如果有任意一个比特为 0，表明该元素一定不在集合中；如果所有比特均为 1 ，表明该集合有可能性在集合中。</p><p>『 为什么不是一定在集合中呢？』</p><p>因为不同的元素计算的哈希值有可能一样，会出现哈希碰撞，导致一个不存在的元素有可能对应的比特位为 1，这就是所谓「假阳性」。相对地，「假阳性」在 BF 中是绝不会出现的。</p><p>总结一下：<strong>布隆过滤器认为不在的，一定不会在集合中；布隆过滤器认为在的，可能在也可能不在集合中。</strong></p><p>『 <strong>例子</strong> 』</p><p>举个例子：下图是一个布隆过滤器，共有18个比特位，3个哈希函数。集合中三个元素x，y，z通过三个哈希函数散列到不同的比特位，并将比特位置为1。当查询元素w时，通过三个哈希函数计算，发现有一个比特位的值为0，可以肯定认为该元素不在集合中。</p><figure><img src="'+a+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>『<strong>布隆过滤器优缺点</strong> 』</p><p>优点：</p><ul><li>节省空间：不需要存储数据本身，只需要存储数据对应 <code>hash</code> 比特位。</li><li>时间复杂度低：插入和查找的时间复杂度都为 <code>O(k)</code>，k 为哈希函数的个数。</li></ul><p>缺点：</p><ul><li>存在假阳性：布隆过滤器判断存在，可能出现元素不在集合中；判断准确率取决于哈希函数的个数。</li><li>不能删除元素：如果一个元素被删除，但是却不能从布隆过滤器中删除，这也是造成假阳性的原因了。</li></ul><p>『<strong>布隆过滤器适用场景</strong> 』</p><ul><li>爬虫系统 url 去重</li><li>垃圾邮件过滤</li><li>黑名单</li></ul><h4 id="缓存空对象" tabindex="-1"><a class="header-anchor" href="#缓存空对象" aria-hidden="true">#</a> 缓存空对象</h4><p>当缓存未命中，查询持久层也为空，可以将返回的空对象写到缓存中，这样下次请求该 key 时直接从缓存中查询返回空对象，请求不会落到持久层数据库。为了避免存储过多空对象，通常会给空对象设置一个过期时间。</p><p>这种方法会存在两个问题：</p><ul><li>如果有大量的 key 穿透，缓存空对象会占用宝贵的内存空间。</li><li>空对象的 key 设置了过期时间，在这段时间可能会存在缓存和持久层数据不一致的场景。可以参考这篇文章保证缓存和数据库的一致性: https://juejin.cn/post/7246365103783329847</li></ul><h3 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h3><p>缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p><strong>缓存击穿危害</strong>：数据库瞬时压力骤增，造成大量请求阻塞。</p><h4 id="使用互斥锁「mutex-key」" tabindex="-1"><a class="header-anchor" href="#使用互斥锁「mutex-key」" aria-hidden="true">#</a> 使用互斥锁「mutex key」</h4><p>让一个线程回写缓存，其他线程等待回写缓存线程执行完，重新读缓存即可。</p><p>同一时间只有一个线程读数据库然后回写缓存，其他线程都处于阻塞状态。如果是高并发场景，大量线程阻塞势必会降低吞吐量。</p><h4 id="热点数据永不过期" tabindex="-1"><a class="header-anchor" href="#热点数据永不过期" aria-hidden="true">#</a> 热点数据永不过期</h4><p>永不过期实际包含两层意思：</p><ul><li>物理不过期，针对热点 key 不设置过期时间</li><li>逻辑过期，把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li></ul><p>不足的就是构建缓存时候，其余线程「非构建缓存的线程」可能访问的是老数据，对于不追求严格强一致性的系统是可以接受的。</p><h3 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h3><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。</p><p>和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><h4 id="均匀过期" tabindex="-1"><a class="header-anchor" href="#均匀过期" aria-hidden="true">#</a> 均匀过期</h4><p>设置不同的过期时间，让缓存失效的时间点尽量均匀。通常可以为有效期增加随机值或者统一规划有效期。</p><h4 id="加互斥锁" tabindex="-1"><a class="header-anchor" href="#加互斥锁" aria-hidden="true">#</a> 加互斥锁</h4><p>跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。</p><h4 id="缓存永不过期" tabindex="-1"><a class="header-anchor" href="#缓存永不过期" aria-hidden="true">#</a> 缓存永不过期</h4><p>跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。</p><h4 id="双层缓存策略" tabindex="-1"><a class="header-anchor" href="#双层缓存策略" aria-hidden="true">#</a> 双层缓存策略</h4><p>使用主备两层缓存：</p><p>主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。</p><p>备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。</p><h3 id="缓存预热" tabindex="-1"><a class="header-anchor" href="#缓存预热" aria-hidden="true">#</a> 缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据回写到缓存。</p><p>如果不进行预热， 那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p><h4 id="缓存预热的操作方法" tabindex="-1"><a class="header-anchor" href="#缓存预热的操作方法" aria-hidden="true">#</a> 缓存预热的操作方法</h4><ul><li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li><li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</li><li>数据量太大的时候，优先保证热点数据进行提前加载到缓存。</li></ul><h3 id="缓存降级" tabindex="-1"><a class="header-anchor" href="#缓存降级" aria-hidden="true">#</a> 缓存降级</h3><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。</p><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p><p>降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p>',63),l=[p];function n(t,o){return i(),r("div",null,l)}const _=e(d,[["render",n],["__file","缓存击穿、缓存穿透、缓存雪崩.html.vue"]]);export{_ as default};
