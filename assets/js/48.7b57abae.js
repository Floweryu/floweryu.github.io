(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{457:function(_,e,v){"use strict";v.r(e);var t=v(2),a=Object(t.a)({},(function(){var _=this,e=_._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),e("p",[e("code",[_._v("FlowSlot")]),_._v(" 会根据预设的规则，结合前面 "),e("code",[_._v("NodeSelectorSlot")]),_._v("、"),e("code",[_._v("ClusterNodeBuilderSlot")]),_._v("、"),e("code",[_._v("StatistcSlot")]),_._v(" 统计出来的实时信息进行流量控制。")]),_._v(" "),e("p",[_._v("限流的直接表现是在执行 "),e("code",[_._v("Entry nodeA = SphU.entry(资源名字)")]),_._v(" 的时候抛出 "),e("code",[_._v("FlowException")]),_._v(" 异常。"),e("code",[_._v("FlowException")]),_._v(" 是 "),e("code",[_._v("BlockException")]),_._v(" 的子类，您可以捕捉 "),e("code",[_._v("BlockException")]),_._v(" 来自定义被限流之后的处理逻辑。")]),_._v(" "),e("p",[_._v("同一个资源可以对应多条限流规则。"),e("code",[_._v("FlowSlot")]),_._v(" 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。")]),_._v(" "),e("p",[_._v("一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("resource")]),_._v("：资源名，即限流规则的作用对象")]),_._v(" "),e("li",[e("code",[_._v("count")]),_._v(": 限流阈值")]),_._v(" "),e("li",[e("code",[_._v("grade")]),_._v(": 限流阈值类型，QPS 或线程数")]),_._v(" "),e("li",[e("code",[_._v("strategy")]),_._v(": 根据调用关系选择策略")])]),_._v(" "),e("h2",{attrs:{id:"基于qps-并发数的流量控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于qps-并发数的流量控制"}},[_._v("#")]),_._v(" 基于QPS/并发数的流量控制")]),_._v(" "),e("p",[_._v("流量控制主要有两种统计类型，一种是"),e("strong",[_._v("统计线程数")]),_._v("，另外一种则是统计 QPS。类型由 "),e("code",[_._v("FlowRule.grade")]),_._v(" 字段来定义。其中，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。其中线程数、QPS 值，都是由 "),e("code",[_._v("StatisticSlot")]),_._v(" 实时统计获取的。")]),_._v(" "),e("p",[_._v("内容格式如下：")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("idx id   thread  pass  blocked   success  total Rt   1m-pass   1m-block   1m-all   exeption\n2   abc647 0     46     0           46     46   1       2763      0         2763     0\n")])])]),e("p",[_._v("其中：")]),_._v(" "),e("ul",[e("li",[_._v("thread： 代表当前处理该资源的线程数；")]),_._v(" "),e("li",[_._v("pass： 代表一秒内到来到的请求；")]),_._v(" "),e("li",[_._v("blocked： 代表一秒内被流量控制的请求数量；")]),_._v(" "),e("li",[_._v("success： 代表一秒内成功处理完的请求；")]),_._v(" "),e("li",[_._v("total： 代表到一秒内到来的请求以及被阻止的请求总和；")]),_._v(" "),e("li",[_._v("RT： 代表一秒内该资源的平均响应时间；")]),_._v(" "),e("li",[_._v("1m-pass： 则是一分钟内到来的请求；")]),_._v(" "),e("li",[_._v("1m-block： 则是一分钟内被阻止的请求；")]),_._v(" "),e("li",[_._v("1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；")]),_._v(" "),e("li",[_._v("exception： 则是一秒内业务本身异常的总和。")])]),_._v(" "),e("h3",{attrs:{id:"_2-1-并发线程数流量控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-并发线程数流量控制"}},[_._v("#")]),_._v(" 2.1 并发线程数流量控制")]),_._v(" "),e("p",[_._v("线程数限流用于保护业务线程数不被耗尽。")]),_._v(" "),e("p",[_._v("Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。")]),_._v(" "),e("h3",{attrs:{id:"_2-2-qps流量控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-qps流量控制"}},[_._v("#")]),_._v(" 2.2 QPS流量控制")]),_._v(" "),e("p",[_._v("当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 "),e("code",[_._v("FlowRule")]),_._v(" 中的 "),e("code",[_._v("controlBehavior")]),_._v(" 字段：")]),_._v(" "),e("h4",{attrs:{id:"直接拒绝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接拒绝"}},[_._v("#")]),_._v(" 直接拒绝")]),_._v(" "),e("p",[_._v("直接拒绝（"),e("code",[_._v("RuleConstant.CONTROL_BEHAVIOR_DEFAULT")]),_._v("）方式。该方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出"),e("code",[_._v("FlowException")]),_._v("。")]),_._v(" "),e("h4",{attrs:{id:"冷启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#冷启动"}},[_._v("#")]),_._v(" 冷启动")]),_._v(" "),e("p",[_._v("冷启动（"),e("code",[_._v("RuleConstant.CONTROL_BEHAVIOR_WARM_UP")]),_._v('）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。')]),_._v(" "),e("h4",{attrs:{id:"匀速排队"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#匀速排队"}},[_._v("#")]),_._v(" 匀速排队")]),_._v(" "),e("p",[_._v("匀速器（"),e("code",[_._v("RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER")]),_._v("）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。")]),_._v(" "),e("p",[_._v("这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。")]),_._v(" "),e("blockquote",[e("p",[_._v("注意：匀速排队模式暂时不支持 QPS > 1000 的场景。")])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022335925.png",alt:"image-20230702223524513"}})]),_._v(" "),e("h2",{attrs:{id:"基于调用关系的流量控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于调用关系的流量控制"}},[_._v("#")]),_._v(" 基于调用关系的流量控制")]),_._v(" "),e("p",[_._v("调用关系包括调用方、被调用方；一个方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 "),e("code",[_._v("NodeSelectorSlot")]),_._v(" 建立不同资源间的调用的关系，并且通过 "),e("code",[_._v("ClusterBuilderSlot")]),_._v(" 记录每个资源的实时统计信息。")]),_._v(" "),e("h3",{attrs:{id:"_3-1-根据调用方限流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-根据调用方限流"}},[_._v("#")]),_._v(" 3.1 根据调用方限流")]),_._v(" "),e("p",[e("code",[_._v("ContextUtil.enter(resourceName, origin)")]),_._v(" 方法中的 "),e("code",[_._v("origin")]),_._v(" 参数标明了调用方身份。这些信息会在 "),e("code",[_._v("ClusterBuilderSlot")]),_._v(" 中被统计。")]),_._v(" "),e("p",[_._v("调用数据示例：")]),_._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[_._v("id: nodeA\nidx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total \n"),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v("   caller1 "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("         "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("         "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("          "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("        "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("     "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("         "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("          "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("2")]),_._v("   caller2 "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("         "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("         "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("          "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("        "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("     "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("         "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("          "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),_._v("\n")])])]),e("p",[_._v("上面这个命令展示了资源名为 "),e("code",[_._v("nodeA")]),_._v(" 的资源被两个不同的调用方调用的统计。")]),_._v(" "),e("p",[_._v("流控规则中的 "),e("code",[_._v("limitApp")]),_._v(" 字段用于根据调用来源进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("default")]),_._v("：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。")]),_._v(" "),e("li",[e("code",[_._v("{some_origin_name}")]),_._v("：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 "),e("code",[_._v("NodeA")]),_._v(" 配置了一条针对调用者"),e("code",[_._v("caller1")]),_._v("的规则，那么当且仅当来自 "),e("code",[_._v("caller1")]),_._v(" 对 "),e("code",[_._v("NodeA")]),_._v(" 的请求才会触发流量控制。")]),_._v(" "),e("li",[e("code",[_._v("other")]),_._v("：表示针对除 "),e("code",[_._v("{some_origin_name}")]),_._v(" 以外的其余调用方的流量进行流量控制。例如，资源"),e("code",[_._v("NodeA")]),_._v("配置了一条针对调用者 "),e("code",[_._v("caller1")]),_._v(" 的限流规则，同时又配置了一条调用者为 "),e("code",[_._v("other")]),_._v(" 的规则，那么任意来自非 "),e("code",[_._v("caller1")]),_._v(" 对 "),e("code",[_._v("NodeA")]),_._v(" 的调用，都不能超过 "),e("code",[_._v("other")]),_._v(" 这条规则定义的阈值。")])]),_._v(" "),e("p",[_._v("同一个资源名可以配置多条规则，规则的生效顺序为："),e("strong",[_._v("{some_origin_name}>other>default")])]),_._v(" "),e("blockquote",[e("p",[_._v("注意：调用来源的数目不要太多（一般不要超过几百个），否则内存占用会非常多（调用来源的统计节点最大数目=资源数目*来源数目）。")])]),_._v(" "),e("h3",{attrs:{id:"_3-2-根据调用链路入口限流-链路限流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-根据调用链路入口限流-链路限流"}},[_._v("#")]),_._v(" 3.2 根据调用链路入口限流：链路限流")]),_._v(" "),e("p",[e("code",[_._v("NodeSelectorSlot")]),_._v(" 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 "),e("code",[_._v("machine-root")]),_._v(" 的虚拟节点，调用链的入口都是这个虚节点的子节点。")]),_._v(" "),e("p",[_._v("一棵典型的调用树如下图所示：")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("     \t          machine-root\n                    /       \\\n                   /         \\\n             Entrance1     Entrance2\n                /             \\\n               /               \\\n      DefaultNode(nodeA)   DefaultNode(nodeA)\n")])])]),e("p",[_._v("上图中来自入口 "),e("code",[_._v("Entrance1")]),_._v(" 和 "),e("code",[_._v("Entrance2")]),_._v(" 的请求都调用到了资源 "),e("code",[_._v("NodeA")]),_._v("，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 "),e("code",[_._v("strategy")]),_._v(" 为 "),e("code",[_._v("RuleConstant.STRATEGY_CHAIN")]),_._v("，同时设置 "),e("code",[_._v("refResource")]),_._v(" 为 "),e("code",[_._v("Entrance1")]),_._v(" 来表示只有从入口 "),e("code",[_._v("Entrance1")]),_._v(" 的调用才会记录到 "),e("code",[_._v("NodeA")]),_._v(" 的限流统计当中，而不关心经 "),e("code",[_._v("Entrance2")]),_._v(" 到来的调用。")]),_._v(" "),e("p",[_._v("调用链的入口（上下文）是通过 API 方法 "),e("code",[_._v("ContextUtil.enter(contextName)")]),_._v(" 定义的，其中 contextName 即对应调用链路入口名称。")]),_._v(" "),e("h3",{attrs:{id:"_3-3-具有关系的资源流量控制-关联流量控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-具有关系的资源流量控制-关联流量控制"}},[_._v("#")]),_._v(" 3.3 具有关系的资源流量控制：关联流量控制")]),_._v(" "),e("p",[_._v("当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，"),e("code",[_._v("read_db")]),_._v(" 和 "),e("code",[_._v("write_db")]),_._v(" 这两个资源分别代表数据库读写，我们"),e("strong",[_._v("可以给 "),e("code",[_._v("read_db")]),_._v(" 设置限流规则来达到写优先的目的：设置 "),e("code",[_._v("strategy")]),_._v(" 为 "),e("code",[_._v("RuleConstant.STRATEGY_RELATE")]),_._v(" 同时设置 "),e("code",[_._v("refResource")]),_._v(" 为 "),e("code",[_._v("write_db")]),_._v("。这样当写库操作过于频繁时，读数据的请求会被限流")]),_._v("。")])])}),[],!1,null,null,null);e.default=a.exports}}]);