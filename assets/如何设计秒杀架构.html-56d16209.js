import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as p,c as e,b as n,d as o,e as c,a as i}from"./app-2588ae75.js";const l="/assets/image-20240128172456528-98d22d30.png",u="/assets/image-20240128172615866-927197c9.png",r="/assets/image-20240128172627896-b6e1d509.png",d={},k=i('<h2 id="瞬时高并发简述" tabindex="-1"><a class="header-anchor" href="#瞬时高并发简述" aria-hidden="true">#</a> 瞬时高并发简述</h2><p>一般在秒杀时间点（比如：12点整）前几分钟，用户并发量才开始徒增，到达时间点时，并发量达到顶峰。</p><p>这种活动是大量用户抢少量商品的场景（比如京东抢茅台），大部分用户秒杀会失败，只有极少用户秒杀会成功。</p><p>在正常情况下，当商品被抢完后，大部分用户会收到商品已抢完的提醒，收到提醒后，用户并发量会急剧下降。所以流量峰值持续的时间非常短。</p><p>针对这种 <strong>瞬时高并发</strong> 的场景，可以从从下面几点进行系统设计：</p><ul><li>页面静态化</li><li>CDN加速</li><li>缓存</li><li>MQ</li><li>限流</li><li>分布式锁</li></ul><h2 id="页面静态化" tabindex="-1"><a class="header-anchor" href="#页面静态化" aria-hidden="true">#</a> 页面静态化</h2><p>活动页面是并发量最大的地方，如果流量都能直接访问服务端，服务端恐怕承受不住这么大压力，而直接挂掉。</p><p>活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少服务端请求，通常会对活动页面做静态化处理。用户浏览商品等常规操作，不会请求到服务端，只有到秒杀时间点，用户点击秒杀按钮才允许访问服务端。这样就能过滤掉大部分请求。</p><h3 id="cdn加速" tabindex="-1"><a class="header-anchor" href="#cdn加速" aria-hidden="true">#</a> CDN加速</h3><p>用户分布在全国各地，比如：北京、深圳、成都、新疆。网速各不相同。</p><p>【<strong>问题</strong>】：<strong>如何让用户最快访问到页面呢？</strong></p><p>这就需要使用 CDN（Content Delivery Network），内容分发网络。使用户就近获取所需内容，降低网络阻塞。</p><h2 id="秒杀按钮设计" tabindex="-1"><a class="header-anchor" href="#秒杀按钮设计" aria-hidden="true">#</a> 秒杀按钮设计</h2><p>大部分用户怕错过秒杀时间点，会提前进入到活动页面。但此时秒杀按钮是<strong>置灰</strong>的，不可点击。但此时用户会不停的刷新页面，希望第一时间看到秒杀按钮点亮。</p><p>【<strong>问题</strong>】：<strong>如何控制秒杀按钮呢？</strong></p><p>可以使用 js 文件控制。</p><p>一般 css、js 和图片资源都会提前存到 CDN 上，但 CDN 上 js 文件如何更新呢？</p><p>秒杀开始时，系统会生成一个新的 js 文件，标志为 true，但需要对 CDN 进行配置，让其保证标志的<strong>及时性</strong>。</p><p>此外，还可以让前端增加一个控制，让用户每隔 3s 发送一次请求。</p><h2 id="读多写少" tabindex="-1"><a class="header-anchor" href="#读多写少" aria-hidden="true">#</a> 读多写少</h2><p>在秒杀过程中，系统会先检查库存是否足够，如果足够才允许下单，写数据库。如果不够，直接返回商品已抢完。</p><p>由于只有少部分用户能够抢到商品，所以大部分情况下都是<strong>读数据库</strong>，典型的<strong>读多写少</strong>场景。</p><p>如果有数十万请求过来，同时通过数据库查询库存是否足够，数据库可能会挂掉（数据库连接资源有限）。所以需要应用缓存 Redis。当然 Redis 也需要多节点部署。</p><h2 id="缓存问题" tabindex="-1"><a class="header-anchor" href="#缓存问题" aria-hidden="true">#</a> 缓存问题</h2><p>通常情况下，在 redis 中保存商品的基础信息，比如：商品id、商品名称、商品属性、库存等信息，数据库中也会保存对应的信息，毕竟只依赖缓存并不可靠。</p><p>用户在点击秒杀按钮时，在请求秒杀接口中，会传入商品id参数，然后服务端需要校验该商品是否合法。如果存在则放入缓存中，否则秒杀失败。</p><h3 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h3><p>举个例子：商品A第一次秒杀时，缓存中是没有数据的，但数据库中有。在前面也说到，如果从数据库中查询到数据，就会存入缓存。</p><p>但是，在高并发场景下，同一时刻会有大量的请求，都在秒杀同一件商品，万一这时该商品缓存失效，这些请求同时去查询缓存中没有数据，然后又同时访问数据库，很可能导致数据库挂掉。</p><p><strong>解决方法一：加锁</strong></p><figure><img src="'+l+`" alt="image-20240128172456528" tabindex="0" loading="lazy"><figcaption>image-20240128172456528</figcaption></figure><p><strong>解决方法二：设置缓存用不过期</strong></p><p>即使如此，还是需要进行加锁，多加一份保险。</p><h3 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h3><p>如果有大量请求传入商品id，在缓存和数据库中都不存在数据，这些请求每次都会穿透缓存，直接访问数据库。由于前面已经加了锁，所以并发量并不会很大，但是会降低请求处理性能。</p><p>解决方法如下，这里就不详细叙述：</p><ul><li>布隆过滤器（数据更新不频繁场景）</li><li>缓存不存在的数据</li></ul><h2 id="库存问题" tabindex="-1"><a class="header-anchor" href="#库存问题" aria-hidden="true">#</a> 库存问题</h2><p>库存扣完后，在用户未支付的情况下，扣减的库存是要加回去的。要特别注意<strong>库存不足</strong>和<strong>超卖</strong>问题。</p><h3 id="数据库扣减库存" tabindex="-1"><a class="header-anchor" href="#数据库扣减库存" aria-hidden="true">#</a> 数据库扣减库存</h3><p>最简单的实现如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">update</span> product <span class="token keyword">set</span> stock<span class="token operator">=</span>stock<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是如何控制库存不足的情况下，不让用户操作呢？</p><p>可以在<code>update</code>前检查一下库存即可：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> stock <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getStockById</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>stock <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">updateStock</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，上面并没有解决并发场景下的问题，仍会出现超卖的情况。</p><p>最简单的方式是<strong>加锁</strong>，比如<code>synchronized</code>关键字，但这样性能不好。</p><p>优雅点的方式：基于数据库的<strong>乐观锁</strong>，少一次数据查询，还能保证数据操作的原子性。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">update</span> product <span class="token keyword">set</span> stock<span class="token operator">=</span>stock<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span>product <span class="token operator">and</span> stock <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 sql 后面添加 <code>stock &gt; 0</code>就能保证不会出现超卖现象。</p><p>但是这样会频繁访问数据库，造成行锁竞争，高并发情况下对数据库造成压力。</p><h3 id="redis-扣减库存" tabindex="-1"><a class="header-anchor" href="#redis-扣减库存" aria-hidden="true">#</a> redis 扣减库存</h3><p>redis 的<code>incr</code>方法是原子性的，可以用来扣减库存：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">checkStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> exist <span class="token operator">=</span> redisClient<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>productId<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>exist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> stock <span class="token operator">=</span> redisClient<span class="token punctuation">.</span><span class="token function">queryStock</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>stock <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    redisClient<span class="token punctuation">.</span><span class="token function">incrby</span><span class="token punctuation">(</span>productId<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    redisClient<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>productId<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码流程如下：</p><ol><li>先判断该用户是否已经秒杀过该商品，秒杀过的用户不能再参与。</li><li>查询库存，如果小于等于0，则表示库存不足。</li><li>如果库存充足，则扣减库存，然后记录本次秒杀用户。</li></ol><p>但是上面流程在高并发的情况下还是存在问题，因为<strong>查询库存</strong>和<strong>扣减库存</strong>不是「原子操作」，会出现库存为负数的情况，即库存超卖。</p><p>同样，上面代码也可以加锁，但也会造成性能降低的问题。</p><p>可以将上述代码优化如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">checkStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> exist <span class="token operator">=</span> redisClient<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>productId<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>exist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>redisClient<span class="token punctuation">.</span><span class="token function">incrby</span><span class="token punctuation">(</span>productId<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    redisClient<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>productId<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但该方案也会存在问题：多个请求同时扣减库存，大多数请求<code>incrby</code>后结果都会小于0，虽然库存为负数不会造成超卖问题，但在<strong>退库存</strong>的时候就会导致库存不准。</p><h3 id="lua脚本扣减库存" tabindex="-1"><a class="header-anchor" href="#lua脚本扣减库存" aria-hidden="true">#</a> lua脚本扣减库存</h3><p>lua 脚本能够保证原子性，跟 redis 结合能很好解决上面问题。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">StringBuilder</span> lua <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 1) then&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;    local stock = tonumber(redis.call(&#39;get&#39;, KEYS[1]));&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;    if (stock == -1) then&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;        return 1;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;    end;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;    if (stock &gt; 0) then&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;        redis.call(&#39;incrby&#39;, KEYS[1], -1);&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;        return stock;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;    end;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;    return 0;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;end;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lua<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;return -1;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该代码的主要流程如下：</p><ol><li>先判断商品 id 是否存在，如果不存在则直接返回。</li><li>获取该商品 id 的库存，判断库存如果是-1，则直接返回，表示不限制库存。</li><li>如果库存大于 0，则扣减库存。</li><li>如果库存等于 0，是直接返回，表示库存不足。</li></ol><h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h2><h3 id="setnx-加锁" tabindex="-1"><a class="header-anchor" href="#setnx-加锁" aria-hidden="true">#</a> setNx 加锁</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   jedis<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但该方法加锁不是原子性的。</p><h3 id="set-加锁" tabindex="-1"><a class="header-anchor" href="#set-加锁" aria-hidden="true">#</a> set 加锁</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;PX&quot;</span><span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;OK&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中：</p><ul><li><code>lockKey</code>：锁的标识。</li><li><code>requestId</code>：请求 id。</li><li><code>NX</code>：只在键不存在时，才对键进行设置操作。</li><li><code>PX</code>：设置键的过期时间为 millisecond 毫秒。</li><li><code>expireTime</code>：过期时间</li></ul><p>由于该命令只有一步，所以它是原子操作。</p><h3 id="释放锁" tabindex="-1"><a class="header-anchor" href="#释放锁" aria-hidden="true">#</a> 释放锁</h3><p>【<strong>问题</strong>】：在加锁时，已经有了<code>lockKey</code>锁标识，为什么还需要记录<code>requestId</code>呢？</p><p>作用在于<strong>释放锁</strong>时使用。保证释放的是自己加的锁，而不是别人加的锁。</p><p>【<strong>问题</strong>】：为什么要用<code>requestId</code>，而不是<code>userId</code>？</p><p>假设使用<code>userId</code>，本次请求流程在第5s走完，锁的过期时间设置为3s，假设在第5s正准备删除锁时。而第4s时另一个请求刚好使用相同的<code>userId</code>加锁，会成功。所以在第5s删除锁时，会删除别人的锁。</p><h3 id="自旋锁" tabindex="-1"><a class="header-anchor" href="#自旋锁" aria-hidden="true">#</a> 自旋锁</h3><p>如果有1w个请求同时竞争一把锁，只有一个请求时成功的，其余9999个请求都会失败。这在秒杀场景下会出现下面问题：</p><p>每1w个请求中只有1个成功，如此下去直到库存不足，这样的秒杀就没有意义了。</p><p>解决上面问题可以使用<strong>自旋锁</strong>。在规定的时间窗口内，比如500ms，自选不断尝试加锁。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token class-name">Long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;PX&quot;</span><span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;OK&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     
     <span class="token keyword">long</span> time <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;=</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span>requestId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="mq异步处理" tabindex="-1"><a class="header-anchor" href="#mq异步处理" aria-hidden="true">#</a> MQ异步处理</h2><p>秒杀有三个核心流程：<strong>秒杀、下单、支付</strong>。</p><p>并发量最大的是<strong>秒杀</strong>，下单和支付实际并发量很小。所以在设计秒杀系统时，需要将下单和支付从主流程中抽取出来，做成<strong>异步</strong>处理。 <img src="`+u+'" alt="image-20240128172615866" loading="lazy"> 使用MQ需要关注下面几个问题，这里就不详细介绍：</p><ul><li>消息丢失问题</li><li>重复消费问题</li><li>垃圾消息问题</li><li>延迟消费问题</li></ul><h3 id="订单取消" tabindex="-1"><a class="header-anchor" href="#订单取消" aria-hidden="true">#</a> 订单取消</h3><p>通常情况下，用户秒杀成功，下单后，在15分钟之内还未完成支付的话，订单会自动取消，回退库存。</p><p><strong>15分钟未支付订单自动取消功能，如何实现</strong>？</p><p>首先可以想到使用<strong>Job</strong>，优点是简单，但实时性不好。</p><p>更好的方案是使用<strong>延迟队列</strong>。 <img src="'+r+'" alt="image-20240128172627896" loading="lazy"></p><h2 id="如何限流" tabindex="-1"><a class="header-anchor" href="#如何限流" aria-hidden="true">#</a> 如何限流</h2><p>真实用户手动点击的情况下，1秒只能点击一次秒杀按钮。但是服务器1秒可以请求上千次。</p><p>所以需要做一下限制，处理这些非法请求。</p><p>两种常用的限流方式：</p><ul><li>基于 Nginx 限流</li><li>基于 Redis 限流</li></ul><h3 id="对同一用户限流" tabindex="-1"><a class="header-anchor" href="#对同一用户限流" aria-hidden="true">#</a> 对同一用户限流</h3><p>限制同一用户 id 请求次数频率，比如每分钟不超过5次。</p><h3 id="对同一ip限流" tabindex="-1"><a class="header-anchor" href="#对同一ip限流" aria-hidden="true">#</a> 对同一ip限流</h3><p>限制同一ip的请求频率，但这种可能存在误杀情况，比如：一个公司出口ip相同，里面如果有多个用户同时发起请求，有些用户可能会把限制住。</p><h3 id="对接口限流" tabindex="-1"><a class="header-anchor" href="#对接口限流" aria-hidden="true">#</a> 对接口限流</h3><p>有些高手使用<strong>代理</strong>，这样对ip限流就无效了。</p><p>可以对接口进行限流，但这样可能会影响一些正常用户的访问，得不偿失。</p><h3 id="增加验证码" tabindex="-1"><a class="header-anchor" href="#增加验证码" aria-hidden="true">#</a> 增加验证码</h3><p>用户每次请求前，需要先输入验证码，每个验证码一次性使用，现在大部分使用的是<strong>移动滑块</strong>验证码。</p><h3 id="提高业务门槛" tabindex="-1"><a class="header-anchor" href="#提高业务门槛" aria-hidden="true">#</a> 提高业务门槛</h3><p>比如只有会员才能参与活动，或者只有指定等级用户才能参与等等。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',112),v={href:"https://juejin.cn/post/7044032901662375949#heading-17",target:"_blank",rel:"noopener noreferrer"};function h(m,b){const s=t("ExternalLinkIcon");return p(),e("div",null,[k,n("ul",null,[n("li",null,[n("a",v,[o("如何设计一个高并发的秒杀架构？ - 掘金"),c(s)])])])])}const y=a(d,[["render",h],["__file","如何设计秒杀架构.html.vue"]]);export{y as default};
