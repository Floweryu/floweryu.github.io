import{_ as a,a as n,b as t,c as i,d as p,e as l,f as d}from"./image-20231129142644340-4443db25.js";import{_ as g}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as h,c as u,b as e,d as r,e as m,a as o}from"./app-23e86fbc.js";const f={},_=o('<h2 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式" aria-hidden="true">#</a> 哨兵模式</h2><p>在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。</p><p>为了解决这个问题，Redis 增加了哨兵模式<strong>Redis Sentinel</strong>，因为哨兵模式做到了可以监控主从服务器，并且提供<strong>主从节点故障转移的功能。</strong></p><figure><img src="'+a+'" alt="image-20231119160133493" tabindex="0" loading="lazy"><figcaption>image-20231119160133493</figcaption></figure><h3 id="哨兵机制" tabindex="-1"><a class="header-anchor" href="#哨兵机制" aria-hidden="true">#</a> 哨兵机制</h3><p>哨兵主要职责：</p><ul><li><strong>监控</strong>：如何监控？如何判断主节点是否真的故障？</li><li><strong>选主</strong>：根据什么规则切换主节点？</li><li><strong>通知</strong>：如何把新主节点信息通知给从节点和客户端？</li></ul><p>下面一个个来回答上面问题。</p><h3 id="如何判断节点真的故障" tabindex="-1"><a class="header-anchor" href="#如何判断节点真的故障" aria-hidden="true">#</a> 如何判断节点真的故障？</h3><img src="'+n+'" alt="image-20231127171535035" style="zoom:50%;"><p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p><p>【<strong>客观下线呢？</strong>】</p><p><strong>主观下线</strong>：主节点可能并没有故障，有可能是因为压力大或者网络不稳定，导致在规定时间内没有响应哨兵的 PING 命令。</p><p>所以为了防止误杀主节点，哨兵就不能是一个节点，而是需要多个哨兵部署成<strong>哨兵集群</strong>（最少需要三台机器）。通过多个哨兵来判断主节点是否真的下线，就可以避免一个哨兵的误判断。</p><p><strong>客观下线</strong>：</p><p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p><img src="'+t+'" alt="image-20231127193121956" style="zoom:50%;"><p>当这个哨兵的赞同票数达到哨兵配置文件中的 <strong>quorum</strong> 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p><p>例如：现在有 3 个哨兵，<strong>quorum</strong> 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为<strong>客观下线</strong>了。这 2 张赞成票包括自己的一票。</p><blockquote><p>💡 quorum 的值一般设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2。</p></blockquote><p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。</p><h3 id="如何进行主从故障转移" tabindex="-1"><a class="header-anchor" href="#如何进行主从故障转移" aria-hidden="true">#</a> 如何进行主从故障转移？</h3><p>前面已经讲到哨兵是以集群方式存在，那么由哪个哨兵来进行主从故障转移呢？</p><p>所以需要在哨兵集群中选举一个 <strong>Leader</strong>，让 <strong>Leader</strong> 执行主从切换。</p><h4 id="如何选举哨兵-leader" tabindex="-1"><a class="header-anchor" href="#如何选举哨兵-leader" aria-hidden="true">#</a> 如何选举哨兵 Leader</h4><p><strong>第一步：先成为候选者：</strong></p><p>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 <strong>Leader</strong> 的哨兵。</p><p>【示例】：假设有三个哨兵。当哨兵 B 先判断到主节点「主观下线后」，就会给其他实例发送 <strong>is-master-down-by-addr</strong> 命令。接着，其他哨兵会根据自己和主节点的网络连接情况，做出赞成投票或者拒绝投票的响应。</p><img src="'+i+'" alt="image-20231127202009571" style="zoom:50%;"><p>当哨兵 B 收到赞成票数达到哨兵配置文件中的 <strong>quorum</strong> 配置项设定的值后，就会将主节点标记为「客观下线」，此时的哨兵 B 就是一个 Leader 候选者。</p><p><strong>第二步：成为 Leader</strong></p><p>候选者会向其他哨兵发送命令，表明希望成为 <strong>Leader</strong> 来执行主从切换，并让所有其他哨兵对它进行投票。</p><p>哨兵投票限制条件：</p><ul><li>每个哨兵只有一次投票机会。</li><li>可以投给自己或投给别人，但是只有候选者才能把票投给自己。</li></ul><p>在投票过程中，任何一个「候选者」，要满足两个条件：</p><ul><li>拿到半数以上的赞成票。</li><li>拿到的票数同时还需要大于等于哨兵配置文件中的 <strong>quorum</strong> 值。</li></ul><p>【示例】：假设哨兵节点有 3 个，<strong>quorum</strong> 设置为 2，那么任何一个想成为 <strong>Leader</strong> 的哨兵只要拿到 2 张赞成票，就可以选举成功了。如果没有满足条件，就需要重新进行选举。</p><blockquote><p>问题：如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时不就有两个候选者了？这时该如何决定谁是 Leader 呢？</p><ol><li><p>每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。</p></li><li><p>如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。</p></li><li><p>这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。</p></li></ol></blockquote><h4 id="为何哨兵至少要有3个" tabindex="-1"><a class="header-anchor" href="#为何哨兵至少要有3个" aria-hidden="true">#</a> 为何哨兵至少要有3个</h4><p>如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票。</p><p>所以，如果哨兵集群中有个哨兵挂掉了，那么就只剩一个哨兵了，如果这个哨兵想要成为 Leader，这时票数就没办法达到 2 票，就无法成功成为 Leader，这时是无法进行主从节点切换的。</p><p>因此，通常我们至少会配置 3 个哨兵节点。这时，如果哨兵集群中有个哨兵挂掉了，那么还剩下两个哨兵，如果这个哨兵想要成为 Leader，这时还是有机会达到 2 票的，所以还是可以选举成功的，不会导致无法进行主从节点切换。</p><p>如果 3 个哨兵节点，挂了 2 个怎么办？这个时候得人为介入了，或者增加多一点哨兵节点。</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><ul><li><p>判断主节点下线的票数只需要大于等于 <strong>quorum</strong> 即可。</p></li><li><p>哨兵选举为 Leader 的票数要超过半数，并且大于等于 <strong>quorum</strong>。</p></li><li><p><strong>quorum 的值建议设置为哨兵个数的二分之一加 1</strong>，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且<strong>哨兵节点的数量应该是奇数</strong>。</p></li></ul><h3 id="主从故障转移的过程" tabindex="-1"><a class="header-anchor" href="#主从故障转移的过程" aria-hidden="true">#</a> 主从故障转移的过程</h3><p>在哨兵集群中通过投票的方式，选举出了哨兵 Leader 后，就可以进行主从故障转移。</p><p>主从故障转移操作包含以下四个步骤：</p><ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li><li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」。</li><li>第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端。</li><li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点。</li></ul><h4 id="步骤一-选出新主节点" tabindex="-1"><a class="header-anchor" href="#步骤一-选出新主节点" aria-hidden="true">#</a> 步骤一：选出新主节点</h4><p>【<strong>问题：到底选择哪个从节点作为新主节点</strong>】</p><p>随机方式：实现简单，但万一又选取到一个网络状态不好的节点，又得需要进行故障转移。</p><p>所以，在选举之前，需要先把网络状态不好的节点和音下线的节点过滤掉。</p><p>【<strong>如何判断节点网络连接状态不好呢</strong>】</p><p>根据 <code>down-after-milliseconds</code> 配置主从节点断连的最大超时时间，在规定毫秒内，主从节点没有连接上，就认为主从节点断开连接。如果断连发生超过<strong>10</strong> 次，就认为该从节点网络状况不好，不适合作为新主节点。</p><figure><img src="'+p+'" alt="image-20231128200514544" tabindex="0" loading="lazy"><figcaption>image-20231128200514544</figcaption></figure><h5 id="选举优先级" tabindex="-1"><a class="header-anchor" href="#选举优先级" aria-hidden="true">#</a> 选举优先级</h5><p>从三个步骤进行选举主节点：<strong>优先级</strong>、<strong>主从复制进度</strong>、<strong>Run ID号</strong></p><ul><li>第一步：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前。优先级由 <code>slave-priority</code> 配置。</li><li>第二步：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。</li><li>第三步：如果优先级和下标都相同，就选择从节点 ID 较小的那个。</li></ul><p>【<strong>第一步：优先级高的节点胜出</strong>】</p><p>Redis 有个叫 <code>slave-priority</code> 配置项，可以给从节点设置优先级。</p><p>每一台从节点的服务器配置不一定是相同的，可以根据服务器性能配置（内存、CPU等）来设置从节点的优先级。</p><p>【<strong>第二步：复制进度靠前节点胜出</strong>】</p><p>在第一步中，如果两个节点的优先级一致，则比较从主节点同步数据的进度。</p><p>在主从架构中，主节点会用 <strong>master_repl_offset</strong> 记录当前的最新写操作在 <strong>repl_backlog_buffer</strong> 中的位置（如下图中的「主服务器已经写入的数据」的位置），而从节点会用 <strong>slave_repl_offset</strong> 这个值记录当前的复制进度（如下图中的「从服务器要读的位置」的位置）。</p><figure><img src="'+l+'" alt="image-20231128203722066" tabindex="0" loading="lazy"><figcaption>image-20231128203722066</figcaption></figure><p>如果某个从节点的 <strong>slave_repl_offset</strong> 最接近 <strong>master_repl_offset</strong>，说明它的复制进度是最靠前的，于是就可以将它选为新主节点。</p><p>【第三步：ID 号小的节点胜出】</p><p>在第二步中，如果两个节点的复制进度是一致的，则比较两个节点的 ID 号，小的 ID 号胜出。</p><p>ID 号就是每个从节点的编号。</p><p>【总结一下上述步骤】</p><img src="'+d+'" alt="image-20231129142644340" style="zoom:50%;"><p>在选举出从节点后，哨兵 leader 向被选中的从节点发送 <code>SLAVEOF no one</code> 命令，让这个从节点解除从节点的身份，将其变为新主节点。</p><p>在发送 <code>SLAVEOF no one</code> 命令之后，哨兵 leader 会以每秒一次的频率向被升级的从节点发送 <code>INFO</code> 命令（没进行故障转移之前，<code>INFO</code> 命令的频率是每十秒一次），并观察命令回复中的角色信息，当被升级节点的角色信息从原来的 slave 变为 master 时，哨兵 leader 就知道被选中的从节点已经顺利升级为主节点了。</p><h4 id="步骤二-将从节点指向新主节点" tabindex="-1"><a class="header-anchor" href="#步骤二-将从节点指向新主节点" aria-hidden="true">#</a> 步骤二：将从节点指向新主节点</h4><p>新主节点出现后，哨兵 Leader 下一步需要将「从节点」指向新的「主节点」。可以通过向「从节点」发送 <code>SLAVEOF</code> 命令实现。</p><h4 id="步骤三-通知客户端更换主节点" tabindex="-1"><a class="header-anchor" href="#步骤三-通知客户端更换主节点" aria-hidden="true">#</a> 步骤三：通知客户端更换主节点</h4><p>前面两步已经选举出主节点，并且已经将从节点指向新的主节点。下面如何将新节点的信息通知给客户端呢？</p><p>主要通过 Redis 的「发布者/订阅者」机制来实现。每个哨兵节点提供「发布者/订阅者」机制，客户端可以从哨兵订阅信息。</p><blockquote><p>💡 具体可以订阅的信息可以参考官方文档： https://redis.io/docs/management/sentinel/#pubsub-messages</p></blockquote><p>下面列举一些常见的信息：</p><ul><li><strong>+reset-master</strong> ：重置主节点。</li><li><strong>+slave</strong> ： 新从节点被检测到。</li><li><strong>+slave-reconf-sent</strong>：哨兵 Leader 发送 <code>REPLICAOF</code> 命令配置从节点。</li><li><strong>+slave-reconf-inprog</strong>：从节点配置了新的主节点，但是还未同步。</li><li><strong>+slave-reconf-done</strong> ：从节点配置新节点，并已经同步完成。</li><li><strong>+sdown</strong>：实例进入『主观下线 』状态。</li><li><strong>-sdown</strong>：实例退出『 主观下线』状态。</li><li><strong>+odown</strong>：实例进入『 客观下线』状态。</li><li><strong>-odown</strong>：实例退出『 客观下线』状态。</li><li><strong>switch-master</strong>：主节点地址发生变化。</li></ul><p>客户端和哨兵建立连接后，客户端会订阅哨兵提供的频道。<strong>主从切换完成后，哨兵就会向 <code>+switch-master</code> 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了</strong>。</p><p>通过「发布者/订阅者」机制，客户端就可以监控到主从节点切换过程中发送的各个事件。</p><h4 id="步骤四-将旧主节点该为从节点" tabindex="-1"><a class="header-anchor" href="#步骤四-将旧主节点该为从节点" aria-hidden="true">#</a> 步骤四：将旧主节点该为从节点</h4><p>哨兵继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 <code>SLAVEOF</code> 命令，让它成为新主节点的从节点。</p><h3 id="哨兵集群如何组成" tabindex="-1"><a class="header-anchor" href="#哨兵集群如何组成" aria-hidden="true">#</a> 哨兵集群如何组成</h3>',87),b={href:"https://redis.io/docs/management/sentinel/#sentinels-and-replicas-auto-discovery",target:"_blank",rel:"noopener noreferrer"},x=o(`<p>设置哨兵的命令如下，并不需要设置其他哨兵的信息，那么哨兵集群之间是如何感知异常的呢？</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>sentinel monitor <span class="token operator">&lt;</span>master-name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>ip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>quorum<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在「发布者/订阅者」机制中，有这个消息：<code>__sentinel__:hello</code>，每个新哨兵都会把自己的 IP 和端口信息发布到该频道上，其他的哨兵订阅这个频道，然后与新哨兵建立连接。</p><p>『 哨兵如何知道从节点信息？』</p><p>哨兵通过 <code>PING</code> 命令来探活主节点和其他哨兵节点。</p><p>通过 <code>INFO</code> 命令从主节点和其他哨兵中获取详细的节点信息：</p><ul><li>对于主节点，<code>INFO</code> 命令的输出包括关于「主节点」自身的信息，以及关于连接到它的所有从节点的信息。</li><li>对于从节点，<code>INFO</code> 命令的输出包括有关「从节点」自身的信息，以及关于它的主节点的信息。</li></ul><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3><ul><li>[为什么要有哨兵](</li></ul>`,9);function L(k,I){const s=c("ExternalLinkIcon");return h(),u("div",null,[_,e("blockquote",null,[e("p",null,[r("官方文档："),e("a",b,[r("Sentinels and replicas auto discovery"),m(s)])])]),x])}const N=g(f,[["render",L],["__file","Redis哨兵模式.html.vue"]]);export{N as default};
