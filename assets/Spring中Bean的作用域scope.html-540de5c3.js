import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as e,a as s}from"./app-feb6715b.js";const t={},i=s(`<h2 id="五种模式" tabindex="-1"><a class="header-anchor" href="#五种模式" aria-hidden="true">#</a> 五种模式</h2><h3 id="singleton-单例模式" tabindex="-1"><a class="header-anchor" href="#singleton-单例模式" aria-hidden="true">#</a> Singleton 单例模式</h3><p>Spring 默认的 scope，表示 Spring 容器只创建一个 bean 的实例，Spring 在创建第一次后会缓存起来，之后不再创建，就是设计模式中的单例模式。</p><h4 id="单例-bean-优势" tabindex="-1"><a class="header-anchor" href="#单例-bean-优势" aria-hidden="true">#</a> 单例 Bean 优势</h4><ul><li>减少了新生成实例的消耗</li><li>减少jvm垃圾回收</li><li>可以快速获取到bean</li></ul><h4 id="单例-bean-的劣势" tabindex="-1"><a class="header-anchor" href="#单例-bean-的劣势" aria-hidden="true">#</a> 单例 Bean 的劣势</h4><blockquote><p>在并发环境下线程不安全？</p></blockquote><p>单例 bean 存在线 程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。</p><p>常⻅的有两种解决办法：</p><ol><li>在 Bean 对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义⼀个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。</li></ol><h3 id="prototype" tabindex="-1"><a class="header-anchor" href="#prototype" aria-hidden="true">#</a> Prototype</h3><p>每次请求都会创建⼀个新的 bean 实例。</p><h3 id="request" tabindex="-1"><a class="header-anchor" href="#request" aria-hidden="true">#</a> Request</h3><p>每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p><h3 id="session" tabindex="-1"><a class="header-anchor" href="#session" aria-hidden="true">#</a> Session</h3><p>每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP session 内有效。</p><h3 id="globalsession" tabindex="-1"><a class="header-anchor" href="#globalsession" aria-hidden="true">#</a> GlobalSession</h3><p>同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经不存在了。</p><h2 id="在创建bean的时候如何指定呢" tabindex="-1"><a class="header-anchor" href="#在创建bean的时候如何指定呢" aria-hidden="true">#</a> 在创建bean的时候如何指定呢？</h2><h3 id="xml-方式" tabindex="-1"><a class="header-anchor" href="#xml-方式" aria-hidden="true">#</a> xml 方式</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>student<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Student<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prototype<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="注解方式" tabindex="-1"><a class="header-anchor" href="#注解方式" aria-hidden="true">#</a> 注解方式</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">&quot;prototype&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,23),o=[i];function p(l,r){return n(),e("div",null,o)}const u=a(t,[["render",p],["__file","Spring中Bean的作用域scope.html.vue"]]);export{u as default};
