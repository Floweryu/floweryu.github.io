const e=JSON.parse('{"key":"v-bd33ee7e","path":"/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80.html","title":"JVM垃圾回收基础","lang":"zh-CN","frontmatter":{"title":"JVM垃圾回收基础","category":["Java"],"tag":["后端","JVM"],"date":"2023-10-21T23:00:00.000Z","description":"如何判断对象需要回收？ 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。 缺点：两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。 因为循环引用的存在，所以 Java 虚拟机不适用引用计数算法。 可达性分析算法 通过一系列的称为GC Roots的对象...","head":[["meta",{"property":"og:url","content":"https://floweryu.top/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"Floweryu"}],["meta",{"property":"og:title","content":"JVM垃圾回收基础"}],["meta",{"property":"og:description","content":"如何判断对象需要回收？ 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。 缺点：两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。 因为循环引用的存在，所以 Java 虚拟机不适用引用计数算法。 可达性分析算法 通过一系列的称为GC Roots的对象..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-18T12:50:13.000Z"}],["meta",{"property":"article:author","content":"Floweryu"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2023-10-21T23:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-18T12:50:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM垃圾回收基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-21T23:00:00.000Z\\",\\"dateModified\\":\\"2023-11-18T12:50:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Floweryu\\",\\"url\\":\\"https://github.com/Floweryu/floweryu.github.io\\",\\"email\\":\\"869830837@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"如何判断对象需要回收？","slug":"如何判断对象需要回收","link":"#如何判断对象需要回收","children":[{"level":3,"title":"引用计数算法","slug":"引用计数算法","link":"#引用计数算法","children":[]},{"level":3,"title":"可达性分析算法","slug":"可达性分析算法","link":"#可达性分析算法","children":[]},{"level":3,"title":"引用类型","slug":"引用类型","link":"#引用类型","children":[{"level":4,"title":"强引用","slug":"强引用","link":"#强引用","children":[]},{"level":4,"title":"软引用","slug":"软引用","link":"#软引用","children":[]},{"level":4,"title":"弱引用","slug":"弱引用","link":"#弱引用","children":[]},{"level":4,"title":"虚引用","slug":"虚引用","link":"#虚引用","children":[]},{"level":4,"title":"1.4 方法区的回收","slug":"_1-4-方法区的回收","link":"#_1-4-方法区的回收","children":[]},{"level":4,"title":"1.5  finalize()","slug":"_1-5-finalize","link":"#_1-5-finalize","children":[]}]}]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":3,"title":"垃圾收集性能","slug":"垃圾收集性能","link":"#垃圾收集性能","children":[]},{"level":3,"title":"标记 - 清除（Mark-Sweep）算法","slug":"标记-清除-mark-sweep-算法","link":"#标记-清除-mark-sweep-算法","children":[]},{"level":3,"title":"标记 - 整理（Mark-Compact）算法","slug":"标记-整理-mark-compact-算法","link":"#标记-整理-mark-compact-算法","children":[]},{"level":3,"title":"复制（Copying）算法","slug":"复制-copying-算法","link":"#复制-copying-算法","children":[]},{"level":3,"title":"分代收集","slug":"分代收集","link":"#分代收集","children":[{"level":4,"title":"新生代（Young generation）","slug":"新生代-young-generation","link":"#新生代-young-generation","children":[]},{"level":4,"title":"老年代（Old generation）","slug":"老年代-old-generation","link":"#老年代-old-generation","children":[]},{"level":4,"title":"永久代（Permanent generation）","slug":"永久代-permanent-generation","link":"#永久代-permanent-generation","children":[{"level":5,"title":"永久代问题","slug":"永久代问题","link":"#永久代问题","children":[]}]},{"level":4,"title":"元空间（Metaspace）","slug":"元空间-metaspace","link":"#元空间-metaspace","children":[]}]}]},{"level":2,"title":"JVM参数","slug":"jvm参数","link":"#jvm参数","children":[]},{"level":2,"title":"内存分配与回收策略","slug":"内存分配与回收策略","link":"#内存分配与回收策略","children":[{"level":3,"title":"Minor GC","slug":"minor-gc","link":"#minor-gc","children":[]},{"level":3,"title":"Full GC","slug":"full-gc","link":"#full-gc","children":[]},{"level":3,"title":"内存分配策略","slug":"内存分配策略","link":"#内存分配策略","children":[{"level":4,"title":"对象优先在 Eden 分配","slug":"对象优先在-eden-分配","link":"#对象优先在-eden-分配","children":[]},{"level":4,"title":"大对象直接进入老年代","slug":"大对象直接进入老年代","link":"#大对象直接进入老年代","children":[]},{"level":4,"title":"长期存活的对象进入老年代","slug":"长期存活的对象进入老年代","link":"#长期存活的对象进入老年代","children":[]},{"level":4,"title":"动态对象年龄判定","slug":"动态对象年龄判定","link":"#动态对象年龄判定","children":[]},{"level":4,"title":"空间分配担保","slug":"空间分配担保","link":"#空间分配担保","children":[]}]},{"level":3,"title":"Full GC 的触发条件","slug":"full-gc-的触发条件","link":"#full-gc-的触发条件","children":[{"level":4,"title":"调用 System.gc()","slug":"调用-system-gc","link":"#调用-system-gc","children":[]},{"level":4,"title":"老年代空间不足","slug":"老年代空间不足","link":"#老年代空间不足","children":[]},{"level":4,"title":"方法区空间不足","slug":"方法区空间不足","link":"#方法区空间不足","children":[]},{"level":4,"title":"Minor GC 的平均晋升空间大小大于老年代可用空间","slug":"minor-gc-的平均晋升空间大小大于老年代可用空间","link":"#minor-gc-的平均晋升空间大小大于老年代可用空间","children":[]},{"level":4,"title":"对象大小大于 To 区和老年代的可用内存","slug":"对象大小大于-to-区和老年代的可用内存","link":"#对象大小大于-to-区和老年代的可用内存","children":[]}]}]}],"git":{"createdTime":1700311813000,"updatedTime":1700311813000,"contributors":[{"name":"Floweryu","email":"im.zhangjunfeng@qq.com","commits":1}]},"readingTime":{"minutes":18.39,"words":5516},"filePathRelative":"java/jvm/JVM垃圾回收基础.md","localizedDate":"2023年10月21日","autoDesc":true}');export{e as data};
