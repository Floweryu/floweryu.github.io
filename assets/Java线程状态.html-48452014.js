import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as n,a as o}from"./app-2f8d6fc8.js";const a="/assets/image-20240311200606013-54d6ec78.png",r={},t=o('<h2 id="六种线程状态及转化关系" tabindex="-1"><a class="header-anchor" href="#六种线程状态及转化关系" aria-hidden="true">#</a> 六种线程状态及转化关系</h2><p><code>java.lang.Thread.State</code>枚举类中定义了六种线程的状态，可以调用线程 Thread 中的<code>getState()</code>方法<strong>获取当前线程的状态</strong>。</p><ul><li>New：尚未启动</li><li>Runnable：<strong>可运行</strong>或者<strong>正在等待分配资源</strong></li><li>Blocked：被阻塞（没抢到 monitor 锁）</li><li>Waiting：等待（等待某个条件，比如 join 线程执行完毕）</li><li>Timed Waiting：计时等待</li><li>Terminated：被终止</li></ul><figure><img src="'+a+'" alt="image-20240311200606013" tabindex="0" loading="lazy"><figcaption>image-20240311200606013</figcaption></figure><h2 id="new-新建" tabindex="-1"><a class="header-anchor" href="#new-新建" aria-hidden="true">#</a> New 新建</h2><p>即用<strong>new关键字</strong>新建一个线程，这个线程就处于<strong>新建状态</strong>。</p><h2 id="runnable-可运行" tabindex="-1"><a class="header-anchor" href="#runnable-可运行" aria-hidden="true">#</a> Runnable 可运行</h2><p>操作系统中的<strong>就绪 Ready</strong> 和<strong>运行 Running</strong> 两种状态，在 Java 中统称为 Runnable。</p><p>Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。</p><p>如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。</p><h3 id="running-运行" tabindex="-1"><a class="header-anchor" href="#running-运行" aria-hidden="true">#</a> <strong>Running</strong> 运行</h3><p>处于就绪状态的线程获得了 CPU 之后，<strong>真正开始执行 run() 方法的线程执行体时</strong>，意味着该线程就已经处于<strong>运行状态</strong>。需要注意的是，<strong>对于单处理器，一个时刻只能有一个线程处于运行状态。</strong></p><p>对于抢占式策略的系统来说，系统会给每个线程一小段时间处理各自的任务。时间用完之后，系统负责夺回线程占用的资源。下一段时间里，系统会根据一定规则，再次进行调度。</p><p><strong>运行状态转变为就绪状态</strong>的情形：</p><ul><li>线程失去处理器资源。线程不一定完整执行的，执行到一半，说不定就被别的线程抢走了。</li><li>调用 <code>yield()</code> 静态方法，暂时暂停当前线程，让系统的线程调度器重新调度一次，它自己完全有可能再次运行。</li></ul><p>yield方法的官方解释：</p><blockquote><p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p></blockquote><p>提示调度程序，当前线程愿意放弃当前对处理器的使用。这时，<strong>当前线程将会被置为就绪状态</strong>，和其他线程一样等待调度，这时候根据不同<strong>优先级</strong>决定的<strong>概率</strong>，当前线程完全有可能再次抢到处理器资源。</p><h2 id="blocked-被阻塞" tabindex="-1"><a class="header-anchor" href="#blocked-被阻塞" aria-hidden="true">#</a> Blocked 被阻塞</h2><p>阻塞状态表示线程<strong>正等待监视器锁</strong>，而陷入的状态。</p><p>以下场景线程将会阻塞：</p><ul><li>线程等待进入 synchronized 同步方法。</li><li>线程等待进入 synchronized 同步代码块。</li></ul><p>线程取得锁，就会从阻塞状态转变为就绪状态。</p><h2 id="waiting-等待" tabindex="-1"><a class="header-anchor" href="#waiting-等待" aria-hidden="true">#</a> Waiting 等待</h2><p>进入该状态表示<strong>当前线程需要等待其他线程做出一些的特定的动作</strong>（通知或中断）。</p><p>Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 <code>notify()/notifyAll()</code> 。</p><h3 id="运行-等待" tabindex="-1"><a class="header-anchor" href="#运行-等待" aria-hidden="true">#</a> 运行-&gt;等待</h3><ul><li>当前线程运行过程中，其他线程调用<code>join</code>方法，当前线程将会进入等待状态。</li><li>当前线程对象调用<code>wait()</code>方法。</li><li><code>LockSupport.park()</code>：出于线程调度的目的<strong>禁用当前线程</strong>。</li></ul><h3 id="等待-就绪" tabindex="-1"><a class="header-anchor" href="#等待-就绪" aria-hidden="true">#</a> 等待-&gt;就绪</h3><ul><li>等待的线程<strong>被其他线程对象唤醒</strong>，<code>notify()</code>和<code>notifyAll()</code>。</li><li><code>LockSupport.unpark(Thread)</code>，与上面park方法对应，给出许可证，<strong>解除等待状态</strong>。</li></ul><p>【<strong>问题</strong>】：如果其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 来唤醒它，它会直接进入 Blocked 状态。为什么呢？</p><p>因为唤醒 Waiting 线程的线程如果调用 <code>notify()</code> 或 <code>notifyAll()</code>，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 <code>notify()/notifyAll()</code> 的<strong>唤醒它的线程</strong>执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。</p><h2 id="timed-waiting-超时等待" tabindex="-1"><a class="header-anchor" href="#timed-waiting-超时等待" aria-hidden="true">#</a> Timed Waiting** **超时等待</h2><p>区别于 <code>Waiting</code>，它可以在<strong>指定的时间</strong>自行返回。</p><h3 id="运行-超时等待" tabindex="-1"><a class="header-anchor" href="#运行-超时等待" aria-hidden="true">#</a> 运行-&gt;超时等待</h3><ul><li>调用静态方法，<code>Thread.sleep(long)</code></li><li>线程对象调用<code>wait(long)</code>方法</li><li>其他线程调用指定时间的<code>join(long)</code>。</li><li><code>LockSupport.parkNanos()</code>。</li><li><code>LockSupport.parkUntil()</code>。</li></ul><h3 id="超时等待-就绪" tabindex="-1"><a class="header-anchor" href="#超时等待-就绪" aria-hidden="true">#</a> 超时等待-&gt;就绪</h3><ul><li>同样的，等待的线程被其他线程对象唤醒，<code>notify()</code>和<code>notifyAll()</code>。</li><li><code>LockSupport.unpark(Thread)</code>。</li></ul><h2 id="消亡状态" tabindex="-1"><a class="header-anchor" href="#消亡状态" aria-hidden="true">#</a> 消亡状态</h2><p>即<strong>线程的终止</strong>，表示线程已经执行完毕。前面已经说了，已经消亡的线程不能通过start再次唤醒。</p><ul><li>run()和call()线程执行体中顺利执行完毕，<strong>线程正常终止</strong>。</li><li>线程抛出一个没有捕获的Exception或Error。</li></ul><p>需要注意的是：主线成和子线程互不影响，子线程并不会因为主线程结束就结束。</p><h2 id="sleep-和-yield-的区别" tabindex="-1"><a class="header-anchor" href="#sleep-和-yield-的区别" aria-hidden="true">#</a> sleep 和 yield 的区别：</h2><ul><li>sleep(long)方法会<strong>使线程转入超时等待状态</strong>，时间到了之后才会转入就绪状态。而yield()方法不会将线程转入等待，而是强制线程进入就绪状态。</li><li>使用sleep(long)方法<strong>需要处理异常</strong>，而yield()不用。</li></ul>',44),d=[t];function l(c,s){return i(),n("div",null,d)}const p=e(r,[["render",l],["__file","Java线程状态.html.vue"]]);export{p as default};
