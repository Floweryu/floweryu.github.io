const e=JSON.parse('{"key":"v-1d7a53d0","path":"/redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Redis面试题","lang":"zh-CN","frontmatter":{"title":"Redis面试题","category":["Redis"],"tag":["后端","中间件"],"date":"2023-11-09T19:05:00.000Z","description":"缓存击穿/缓存穿透/缓存雪崩 缓存穿透 缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。 如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。 布隆过滤器 布隆过滤器「Bloom Filter，简称BF...","head":[["meta",{"property":"og:url","content":"https://floweryu.top/redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"Floweryu"}],["meta",{"property":"og:title","content":"Redis面试题"}],["meta",{"property":"og:description","content":"缓存击穿/缓存穿透/缓存雪崩 缓存穿透 缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。 如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。 布隆过滤器 布隆过滤器「Bloom Filter，简称BF..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://floweryu.top/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-29T08:50:32.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Redis面试题"}],["meta",{"property":"article:author","content":"Floweryu"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:published_time","content":"2023-11-09T19:05:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-29T08:50:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis面试题\\",\\"image\\":[\\"https://floweryu.top/\\"],\\"datePublished\\":\\"2023-11-09T19:05:00.000Z\\",\\"dateModified\\":\\"2023-11-29T08:50:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Floweryu\\",\\"url\\":\\"https://github.com/Floweryu/floweryu.github.io\\",\\"email\\":\\"869830837@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"缓存击穿/缓存穿透/缓存雪崩","slug":"缓存击穿-缓存穿透-缓存雪崩","link":"#缓存击穿-缓存穿透-缓存雪崩","children":[{"level":3,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[]},{"level":3,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[]},{"level":3,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[]},{"level":3,"title":"缓存预热","slug":"缓存预热","link":"#缓存预热","children":[]},{"level":3,"title":"缓存降级","slug":"缓存降级","link":"#缓存降级","children":[]}]},{"level":2,"title":"Redis 线程模型","slug":"redis-线程模型","link":"#redis-线程模型","children":[{"level":3,"title":"Redis 单线程为什么还这么快","slug":"redis-单线程为什么还这么快","link":"#redis-单线程为什么还这么快","children":[]},{"level":3,"title":"Redis 6.0 之后为什么引入了多线程","slug":"redis-6-0-之后为什么引入了多线程","link":"#redis-6-0-之后为什么引入了多线程","children":[]}]},{"level":2,"title":"Redis 持久化","slug":"redis-持久化","link":"#redis-持久化","children":[{"level":3,"title":"如何实现数据不丢失","slug":"如何实现数据不丢失","link":"#如何实现数据不丢失","children":[]},{"level":3,"title":"AOF 持久化","slug":"aof-持久化","link":"#aof-持久化","children":[]},{"level":3,"title":"RDB持久化","slug":"rdb持久化","link":"#rdb持久化","children":[]},{"level":3,"title":"混合持久化","slug":"混合持久化","link":"#混合持久化","children":[]}]},{"level":2,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[{"level":3,"title":"初次同步","slug":"初次同步","link":"#初次同步","children":[]},{"level":3,"title":"命令传播","slug":"命令传播","link":"#命令传播","children":[]},{"level":3,"title":"分摊主服务器压力","slug":"分摊主服务器压力","link":"#分摊主服务器压力","children":[]},{"level":3,"title":"增量复制","slug":"增量复制","link":"#增量复制","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]},{"level":3,"title":"主从异步复制丢失解决方案","slug":"主从异步复制丢失解决方案","link":"#主从异步复制丢失解决方案","children":[]},{"level":3,"title":"集群脑裂导致数据丢失","slug":"集群脑裂导致数据丢失","link":"#集群脑裂导致数据丢失","children":[]},{"level":3,"title":"面试题链接","slug":"面试题链接","link":"#面试题链接","children":[]}]},{"level":2,"title":"哨兵模式","slug":"哨兵模式","link":"#哨兵模式","children":[{"level":3,"title":"哨兵机制","slug":"哨兵机制","link":"#哨兵机制","children":[]},{"level":3,"title":"如何判断节点真的故障？","slug":"如何判断节点真的故障","link":"#如何判断节点真的故障","children":[]},{"level":3,"title":"如何进行主从故障转移？","slug":"如何进行主从故障转移","link":"#如何进行主从故障转移","children":[]},{"level":3,"title":"小结","slug":"小结-1","link":"#小结-1","children":[]},{"level":3,"title":"主从故障转移的过程","slug":"主从故障转移的过程","link":"#主从故障转移的过程","children":[]},{"level":3,"title":"哨兵集群如何组成","slug":"哨兵集群如何组成","link":"#哨兵集群如何组成","children":[]},{"level":3,"title":"参考","slug":"参考","link":"#参考","children":[]}]}],"git":{"createdTime":1699954242000,"updatedTime":1701247832000,"contributors":[{"name":"zhangjunfeng","email":"im.zhangjunfeng@qq.com","commits":5},{"name":"Floweryu","email":"im.zhangjunfeng@qq.com","commits":4}]},"readingTime":{"minutes":49.4,"words":14819},"filePathRelative":"redis/Redis面试题.md","localizedDate":"2023年11月9日","autoDesc":true}');export{e as data};
