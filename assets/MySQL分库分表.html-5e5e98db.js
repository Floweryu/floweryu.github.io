import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,a as e}from"./app-c461ad57.js";const p="/assets/image-20240221105331377-1d68272d.png",t="/assets/image-20240221105344488-072bac0d.png",o="/assets/image-20240221110124864-7cec4b1e.png",i="/assets/image-20240221110141607-056aefb7.png",c="/assets/image-20240221110157679-6611a84c.png",l={},u=e('<h2 id="分库分表背景" tabindex="-1"><a class="header-anchor" href="#分库分表背景" aria-hidden="true">#</a> 分库分表背景</h2><h3 id="从性能上看" tabindex="-1"><a class="header-anchor" href="#从性能上看" aria-hidden="true">#</a> 从性能上看</h3><h4 id="数据量限制" tabindex="-1"><a class="header-anchor" href="#数据量限制" aria-hidden="true">#</a> 数据量限制</h4><p>单表数据量过大，导致读写性能差。</p><blockquote><p>一般建议单表行数超过 500w 行或者单表容量超过 2GB，才推荐分库分表。 根据 B+树索引存储计算，单表不建议超过 2000w 行，因为当 B+树为三层时，存储量约 2.45kw（在一条数据为 1k 的情况下计算），数据量太大会导致 B+树层级更高，影响查询性能。</p></blockquote><h4 id="数据库性能瓶颈" tabindex="-1"><a class="header-anchor" href="#数据库性能瓶颈" aria-hidden="true">#</a> 数据库性能瓶颈</h4><p>有以下几种情况：</p><ul><li>磁盘空间不足，无法扩容。</li><li>数据库服务器 CPU 压力过大，导致读写性能较慢。</li><li>数据库服务器内存不足、网络带宽不足，导致读写性能瓶颈。</li><li>数据库连接数过多，导致客户端连接超时。</li></ul><h3 id="从可用性上看" tabindex="-1"><a class="header-anchor" href="#从可用性上看" aria-hidden="true">#</a> 从可用性上看</h3><p>单库发生意外可能会丢失所有数据。</p><h2 id="切分方案选择" tabindex="-1"><a class="header-anchor" href="#切分方案选择" aria-hidden="true">#</a> 切分方案选择</h2><h3 id="分表方案选择" tabindex="-1"><a class="header-anchor" href="#分表方案选择" aria-hidden="true">#</a> 分表方案选择</h3><p>基于业务，可以估算出每天记录数据条数，然后根据系统使用年限等计算需要多少张表，一般一张表记录 500w 行数据。</p><h3 id="分库方案选择" tabindex="-1"><a class="header-anchor" href="#分库方案选择" aria-hidden="true">#</a> 分库方案选择</h3><p>分库除了要考虑平时业务峰值读写 QPS 外，还需要考虑例如双十一大促期间可能达到的峰值。 假如只需要 3500 个数据库连接数，如果单库可以承担最高 1000 个数据库连接，就可以拆分为 4 个库。</p><h2 id="对数据进行切分" tabindex="-1"><a class="header-anchor" href="#对数据进行切分" aria-hidden="true">#</a> 对数据进行切分</h2><p>分为水平切分、垂直切分。</p><h2 id="分库分表导致的问题" tabindex="-1"><a class="header-anchor" href="#分库分表导致的问题" aria-hidden="true">#</a> 分库分表导致的问题</h2><h3 id="如何让数据均匀分布" tabindex="-1"><a class="header-anchor" href="#如何让数据均匀分布" aria-hidden="true">#</a> 如何让数据均匀分布？</h3><p>热点事件出现后，热点数据会存到某个特定库/表，造成读写压力不均。 此问题跟<strong>负载均衡</strong>问题类似，下面是常见的负载均衡算法：</p><p><img src="'+p+`" alt="image-20240221105331377" loading="lazy"> 选择<strong>一致性哈希</strong>算法，并且修改如下：</p><ol><li>一致性 Hash 有 <code>2^32-1</code> 个节点，根据业务可以调整 Hash 环的数量，假设为 4096 个。</li><li>一致性 Hash 通过 <code>hash(DB 的 ip) % 2^32</code> 公式计算 DB 在 Hash 环中的位置。如果 DB 的数量较少，需要通过增加虚拟节点来解决 Hash 环偏斜的问题，而且 DB 在环中的位置肯呢个会随着 IP 的变动而变化，尤其在云环境下。</li></ol><p>下面解决数据均匀分布到 Hash 环的问题： 可以通过 <code>Math.abs(id.hashCode()) % 4096</code> 计算定位到 hash 环的位置，接下来让 DB 也均匀分不到这个 Hash 环上即可。如果 hash 环有 4096 个节点，拆分 4 个库的话，根据公式：<code>Math.abs(id.hashCode()) % 4096) / (4096 / DB_COUNT)</code>计算 4 个库分别位于第 1、1025、 2049、3073 这 4 个节点上。 分库索引伪代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token doc-comment comment">/**
 * 分库数量
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DB_COUNT</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 获取数据库分库索引号
 *
 * <span class="token keyword">@param</span> <span class="token parameter">buyerId</span> 会员ID
 * <span class="token keyword">@return</span>
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexDbByBuyerId</span><span class="token punctuation">(</span><span class="token class-name">Long</span> buyerId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>buyerId<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">4096</span> <span class="token operator">/</span> <span class="token constant">DB_COUNT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何解决分库后主键-id-唯一性" tabindex="-1"><a class="header-anchor" href="#如何解决分库后主键-id-唯一性" aria-hidden="true">#</a> 如何解决分库后主键 ID 唯一性？</h3><p>但单库环境下，表 ID 采用 MySQL 自增的方式，分库之后，如果还继续采用自增的方式，会出现主键 ID 重复的问题。</p><p><strong>UUID 方式</strong>：太长，查询性能太差，占用空间大，主键类型发生改变。</p><p><strong>对 ID 进行拆分</strong>：不同库表使用不同的 ID 段，问题在于<strong>ID 段多长合适？</strong></p><p>如果将所有分库使用的 ID 段按照等差数列进行分隔，每次 ID 段用完之后，再按照固定步长递增。</p><p>例如：每次分配 ID 步长为 1000，则每次分配的 ID 段起止索引按照下面公式计算：</p><p>第 X 库、第 Y 次分配起始索引：<code>X * 步长 + (Y-1) * (库数量 * 步长)</code></p><p>第 X 库、第 Y 次分配结束索引：<code>X * 步长 + (Y-1) * (库数量 * 步长) + (1000 -1)</code></p><p>如果是分 4 个库，最终分配的 ID 段是下面这个样子：</p><figure><img src="`+t+`" alt="image-20240221105344488" tabindex="0" loading="lazy"><figcaption>image-20240221105344488</figcaption></figure><p>除此，为了分析排查问题方便，会在 ID 中增加额外信息，例如：日期、版本、分库索引等。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Setter</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">DateFormatUtils</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 问题单ID构建器
 * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
 * ID格式(18位)：6位日期 + 2位版本号 + 2位库索引号 + 8位序列号
 * 示例：180903010300001111
 * 说明这个问题单是2018年9月3号生成的，采用的01版本的ID生成规则，数据存放在03库，最后8位00001111是生成的序列号ID。* 采用这种ID格式还有个好处就是每天都有1亿(8位)的序列号可用。* <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 */</span>
<span class="token annotation punctuation">@Setter</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProblemOrdIdBuilder</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DB_COUNT</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DATE_FORMATTER</span> <span class="token operator">=</span> <span class="token string">&quot;yyMMdd&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> version <span class="token operator">=</span> <span class="token string">&quot;01&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> buyerId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> timeInMills<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> seqNum<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> dbIndex <span class="token operator">=</span> <span class="token function">indexDbByBuyerId</span><span class="token punctuation">(</span>buyerId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">StringBuilder</span> pid <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">DateFormatUtils</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>timeInMills<span class="token punctuation">,</span> <span class="token constant">DATE_FORMATTER</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;%02d&quot;</span><span class="token punctuation">,</span> dbIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;%08d&quot;</span><span class="token punctuation">,</span> seqNum <span class="token operator">%</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>pid<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 获取数据库分库索引号
     *
     * <span class="token keyword">@param</span> <span class="token parameter">buyerId</span> 会员ID
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexDbByBuyerId</span><span class="token punctuation">(</span><span class="token class-name">Long</span> buyerId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>buyerId<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">4096</span> <span class="token operator">/</span> <span class="token constant">DB_COUNT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="分布式事务问题" tabindex="-1"><a class="header-anchor" href="#分布式事务问题" aria-hidden="true">#</a> 分布式事务问题</h3><p>对业务分库后，同一个操作会分散到多个数据库中，涉及跨库执行的 SQL 语句会出现分布式事务问题。</p><p>目前有两种解决方案：</p><p><strong>分布式事务中间件</strong></p><ul><li>优点：实现简单。</li><li>缺点：由服务器/数据库实现，性能代价高。</li></ul><p><strong>应用程序+数据库</strong></p><ul><li>原理：大事务拆分为小事务。</li><li>优点：性能好。</li><li>缺点：从业务上做处理，改造成本高。</li></ul><h3 id="跨库关联查询问题" tabindex="-1"><a class="header-anchor" href="#跨库关联查询问题" aria-hidden="true">#</a> 跨库关联查询问题</h3><p>分库分表后，跨库和跨表查询操作比较复杂，性能无法保证。</p><p><strong>解决方法</strong>：</p><ul><li>额外存储，维护文件索引。</li><li>合理的冗余数据库字段，避免跨库查询。</li></ul><h3 id="历史数据如何平滑迁移" tabindex="-1"><a class="header-anchor" href="#历史数据如何平滑迁移" aria-hidden="true">#</a> 历史数据如何平滑迁移？</h3><p>分库切换发布可选择<strong>停机</strong>、<strong>不停机</strong>发布两种：</p><h4 id="停机发布" tabindex="-1"><a class="header-anchor" href="#停机发布" aria-hidden="true">#</a> 停机发布</h4><ul><li>首先在流量少的夜晚，需要临时关闭业务入口。</li><li>新增全量数据复制任务，任务执行时间需要估算。</li><li>切换数据库连接配置，重启应用进行检查。</li><li>开发业务入口，提供服务。</li></ul><h4 id="不停机发布-以下面示例参考" tabindex="-1"><a class="header-anchor" href="#不停机发布-以下面示例参考" aria-hidden="true">#</a> 不停机发布（以下面示例参考）</h4><ol><li>新建两个新数据库集群，同时同步老数据库数据到两个新集群。两个新集群的数据要做到实时同步，老库添加修改哪条数据，两个新库也要跟着变化。</li></ol><figure><img src="`+o+'" alt="image-20240221110124864" tabindex="0" loading="lazy"><figcaption>image-20240221110124864</figcaption></figure><ol start="2"><li>上线代码。使用两个新集群的数据库地址，进行查询和插入。这时两个新数据库的proxy还是指向旧数据库。同时验证数据是否写到旧数据库。如果直接将proxy链接到新库A和B，会造成主键冲突。</li></ol><figure><img src="'+i+'" alt="image-20240221110141607" tabindex="0" loading="lazy"><figcaption>image-20240221110141607</figcaption></figure><ol start="3"><li>DBA将两个新数据库的proxyA和proxyB同时指向两个新集群（30s内）</li></ol><figure><img src="'+c+'" alt="image-20240221110157679" tabindex="0" loading="lazy"><figcaption>image-20240221110157679</figcaption></figure><p>丢失的这段时间的数据，后续可以让DBA修复。</p><p>最后按照分库分表方案删除AB数据库中无用的数据，因为之前两个库数据一致，冗余了。</p>',60),r=[u];function d(k,m){return s(),a("div",null,r)}const b=n(l,[["render",d],["__file","MySQL分库分表.html.vue"]]);export{b as default};
