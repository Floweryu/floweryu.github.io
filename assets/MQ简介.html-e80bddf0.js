import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,a as r}from"./app-763c082b.js";const t="/assets/20210718104029-96f15121.png",o="/assets/20210718103747-b29505ba.png",n={},c=r('<h2 id="_1-为什么要使用mq" tabindex="-1"><a class="header-anchor" href="#_1-为什么要使用mq" aria-hidden="true">#</a> 1. 为什么要使用MQ</h2><h3 id="_1-1-流量削峰" tabindex="-1"><a class="header-anchor" href="#_1-1-流量削峰" aria-hidden="true">#</a> 1.1 流量削峰</h3><p>使用消息队列做缓冲。假设一个订单系统最多能处理一万个订单，当订单数量超过一万个后，只能限制超过一万后不允许用户下单。这时可以用MQ做缓冲，把一秒内下的订单分散成一段时间来处理，可能用户在下单后几十秒后才收到下单成功的操作，但是比不能下单要好。</p><h3 id="_1-2-应用解耦" tabindex="-1"><a class="header-anchor" href="#_1-2-应用解耦" aria-hidden="true">#</a> 1.2 应用解耦</h3><p>用户创建完成订单后，后面会调用库存系统、物流系统、支付系统，任何一个系统出现异常，都会造成下单操作异常。</p><p>可以使用消息队列对调用的系统进行解耦，这样系统之间调用的问题就会减少很多，比如，物流系统发生故障，需要几分钟来进行修复，在这几分钟的时间里，物流系统要处理的数据被缓存在消息队列中，用户下单的操作可以正常完成。当物流系统恢复后，继续处理订单信息即可。中间用户再下单就感受不到物流系统的障碍，提高系统的可用性。</p><figure><img src="'+t+'" alt="image-20210718104024644" tabindex="0" loading="lazy"><figcaption>image-20210718104024644</figcaption></figure><h3 id="_1-3-异步处理" tabindex="-1"><a class="header-anchor" href="#_1-3-异步处理" aria-hidden="true">#</a> 1.3 异步处理</h3><p>A调用B的API，只需要监听B处理完后的信息，B处理完成后会发送一条信息给MQ，MQ会将此信息转发给A服务。</p><p>这样A服务不同循环调用B的查询，也不用提供<code>callback api</code>。</p><img src="'+o+'" alt="image-20210718103723104" style="zoom:67%;"><h2 id="_2-rocketmq与kafka对比" tabindex="-1"><a class="header-anchor" href="#_2-rocketmq与kafka对比" aria-hidden="true">#</a> 2. RocketMQ与Kafka对比</h2><h3 id="存储形式" tabindex="-1"><a class="header-anchor" href="#存储形式" aria-hidden="true">#</a> 存储形式</h3><p><strong>Kafka</strong>：</p><ul><li>采用partition，每个topic的每个partition对应一个文件。</li><li>单个broker的partition过多，则顺序写将退化为随机写，Page Cache脏页过多，频繁触发缺页中断，性能大幅下降。</li></ul><p><strong>RocketMQ</strong>：</p><ul><li>采用CommitLog+ConsumeQueue，同一个broker所有topic在同一个CommitLog中顺序写。</li><li>每个topic下的每个queue都有一个对应的ConsumeQueue文件作为索引。</li><li>写入pagecache之后被触发刷盘频率相对较低</li></ul><h3 id="存储可靠性" tabindex="-1"><a class="header-anchor" href="#存储可靠性" aria-hidden="true">#</a> 存储可靠性</h3><p><strong>Kafka</strong>：</p><ul><li>多副本机制：每个Partition都有多个副本，当某个Broker节点失效时，可以通过其他副本来保证数据的可用性。</li></ul><p><strong>RocketMQ</strong>：</p><ul><li>主从复制机制：当主节点失效时，需要进行主节点选举才能保证数据的可用性，这可能会导致一定的延迟。</li></ul>',22),s=[c];function h(d,l){return e(),i("div",null,s)}const u=a(n,[["render",h],["__file","MQ简介.html.vue"]]);export{u as default};
