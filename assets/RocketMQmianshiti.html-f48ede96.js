import{_ as s,o as n,c as a,d as e}from"./app-4805b28f.js";const t={},p=e(`<h2 id="rocketmq如何保证消费幂等" tabindex="-1"><a class="header-anchor" href="#rocketmq如何保证消费幂等" aria-hidden="true">#</a> RocketMQ如何保证消费幂等？</h2><blockquote><p>也可以理解为RocketMQ如何防止重复消费？</p></blockquote><h3 id="消息幂等" tabindex="-1"><a class="header-anchor" href="#消息幂等" aria-hidden="true">#</a> 消息幂等</h3><p>当出现消费者对某条消息重复消费的情况时，<strong>重复消费的结果与消费一次的结果是相同</strong>，并且<strong>多次消费并未对业务系统产生任何负面影响</strong>，那么这个消费者的处理过程就是幂等的。</p><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h3><p><strong>1. 发送消息时重复</strong></p><p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致MQ服务端对客户端应答失败。 此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同但Message ID不同的消息。</p><p><strong>2. 投递时消息重复</strong></p><p>消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断，导致消费成功的状态无法返回给MQ服务端。为了保证消息至少被消费一次，RocketMQ服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。</p><p><strong>3. 负载均衡时消息重复</strong></p><p>当RocketMQ的Broker或客户端重启、扩容或缩容时，会触发Rebalance，此时消费者可能会收到少量重复消息。</p><h3 id="处理方法" tabindex="-1"><a class="header-anchor" href="#处理方法" aria-hidden="true">#</a> 处理方法</h3><p>因为<strong>不同的Message ID对应的消息内容可能相同</strong>，有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。</p><p>最好的方式是<strong>以业务唯一标识作为幂等处理的关键依据</strong>，而业务的唯一标识可以通过消息Key设置。</p><p>以支付场景为例，可以将消息的Key设置为订单号，作为幂等处理的依据。具体代码示例如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
message<span class="token punctuation">.</span><span class="token function">setKey</span><span class="token punctuation">(</span><span class="token string">&quot;ORDERID_100&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费者收到消息时可以根据消息的Key，即订单号来实现消息幂等：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;ons_test&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 根据业务唯一标识的Key做幂等处理。</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>处理方式如下：</p><h4 id="_1-数据库对唯一标识字段设置唯一索引" tabindex="-1"><a class="header-anchor" href="#_1-数据库对唯一标识字段设置唯一索引" aria-hidden="true">#</a> 1. 数据库对唯一标识字段设置唯一索引</h4><h4 id="_2-对数据库使用select-for-update或者乐观锁" tabindex="-1"><a class="header-anchor" href="#_2-对数据库使用select-for-update或者乐观锁" aria-hidden="true">#</a> 2. 对数据库使用<code>select for update</code>或者乐观锁</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>select <span class="token operator">*</span> from t_order where order_no <span class="token operator">=</span> &#39;<span class="token constant">THIS_ORDER_NO</span>&#39; <span class="token keyword">for</span> update  <span class="token comment">//开启事务</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>status <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token comment">//消息重复，直接返回</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-基于关系数据库事务插入消息表" tabindex="-1"><a class="header-anchor" href="#_3-基于关系数据库事务插入消息表" aria-hidden="true">#</a> 3. 基于关系数据库事务插入消息表</h4><p>在数据库中增加一个消息消费记录表，把消息插入到这个表，并且把原来的订单更新和这个插入的动作放到同一个事务中一起提交，就能保证消息只会被消费一遍了。</p><ol><li>开启事务</li><li>插入消息表（解决主键冲突，需要选择好唯一标识）</li><li>更新订单表（消费逻辑）</li><li>提交事务</li></ol><p>按照上面步骤：如果消息消费成功，则消息也插入成功。此时就算再次投递该条消息，也会因为插入消息表失败而回滚事务，从而保证消费幂等。</p><h4 id="_4-拆解消息" tabindex="-1"><a class="header-anchor" href="#_4-拆解消息" aria-hidden="true">#</a> 4. 拆解消息</h4><p>第三个方案基于事务，可能导致锁表时间过长等性能问题。考虑下面这个场景：</p><ol><li>检查库存（RPC）</li><li>锁库存（RPC）</li><li>开启事务，插入订单表（MySQL）</li><li>调用某些其他下游服务（RPC）</li><li>更新订单状态</li><li>commit 事务（MySQL）</li></ol><p>这种情况下，采取消息表+本地事务的实现方式，消息消费过程中很多子过程是不支持回滚的。特别是RPC调用，如果增加分布式事务，将大大降低系统并发。</p><p><strong>拆解消息过程：</strong></p><ol><li>库存系统消费A：检查库存并做锁库存，发送消息B给订单服务</li><li>订单系统消费消息B：插入订单表（MySQL），发送消息C给自己（下游系统）消费</li><li>下游系统消费消息C：处理部分逻辑，发送消息D给订单系统</li><li>订单系统消费消息D：更新订单状态</li></ol><p>上面操作使得每一步的操作都比较原子，意味着使用消息表+事务的方案显得可行。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考：</h2><ul><li>https://jaskey.github.io/blog/2020/06/08/rocketmq-message-dedup/</li></ul>`,35),o=[p];function c(i,l){return n(),a("div",null,o)}const u=s(t,[["render",c],["__file","RocketMQmianshiti.html.vue"]]);export{u as default};
