<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM垃圾回收器</title>
    <link href="/Java/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <url>/Java/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h1><p><strong>串行收集器采用单线程 <code>stop-the-world</code> 的方式进行收集</strong>。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，<strong>采用单线程方式回收空间并整理内存</strong>。</p><p><strong>特点</strong>：</p><ul><li>单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。</li><li><strong>特别适合堆内存不高、单核甚至双核 CPU 的场合</strong>。</li></ul><h2 id="Serial-Serial-Old-收集器"><a href="#Serial-Serial-Old-收集器" class="headerlink" title="Serial + Serial Old 收集器"></a>Serial + Serial Old 收集器</h2><blockquote><p>开启选项：-XX:+UseSerialGC<br>打开此开关后，使用 Serial + Serial Old 收集器组合来进行内存回收。<strong>等价于新生代用Serial GC，且老年代用Serial old GC。</strong></p></blockquote><p><strong>运行示意图</strong>：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310231626614.png" alt="image-20231023162553675"></p><p>针对年轻代：<strong>Serial收集器</strong>采用<strong>复制算法</strong>，<strong>串行回收</strong>和<strong>stop-the-World</strong>机制。</p><p>针对老年代：<strong>Serial old收集器</strong>采用<strong>标记-整理算法</strong>，也采用了<strong>串行回收</strong>和<strong>stop-the-World</strong>机制。</p><p><strong>特点</strong>：</p><ul><li>简单高效：对于限定单个CPU的环境来说，Serial收集器由于<strong>没有线程交互的开销</strong></li><li>占用内存小</li></ul><p><strong>场景</strong>：</p><ul><li>对于堆内存很小的应用（几十或者一两百兆的新生代或老年代）</li><li>桌面应用（客户端模式下的默认垃圾收集器）</li><li>Serial Old在JDK 5之前的版本中和Parallel Scavenge收集器搭配使用</li><li>Serial Old作为CMS收集器发生失败时的后备预案</li></ul><h1 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h1><p><strong>并行收集器是 server 模式下的默认收集器。</strong></p><blockquote><p>开启选项：-XX:+UseParallelGC<br>打开此开关后，使用 Parallel Scavenge + Serial Old 收集器组合来进行内存回收。<br>开启选项：-XX:+UseParallelOldGC<br>打开此开关后，使用 Parallel Scavenge + Parallel Old 收集器组合来进行内存回收。</p></blockquote><p>其他收集器都是以关注停顿时间为目标，而<strong>并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器。</strong></p><ul><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；</li><li>而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li></ul><p><code>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</code></p><p><strong>特点</strong>：</p><ul><li>并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，<strong>只是暂停时并行地进行垃圾收集</strong>。</li><li>并行收集器<strong>年轻代采用复制算法</strong>，<strong>老年代采用标记-整理</strong>，在回收的同时还会<strong>对内存进行压缩</strong>。</li><li>并行收集器<strong>适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</strong></li></ul><p><strong>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。</strong></p><h2 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge + Parallel Old收集器"></a>Parallel Scavenge + Parallel Old收集器</h2><p><strong>特点</strong>：</p><ul><li><strong>新生代</strong>使用Parallel Scavenge<strong>标记复制</strong>，<strong>老年代</strong>使用Parallel Old收集器<strong>标记整理</strong></li><li>吞吐量优先</li><li>并行收集</li></ul><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是：</p><ul><li><code>-XX:MaxGCPauseMillis</code> ：控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。</li><li><code>-XX:GCTimeRatio</code>： 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。</li><li>缩短停顿时间是以牺牲<strong>吞吐量</strong>和<strong>年轻代空间</strong>来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。</li></ul><p>Parallel Scavenge 收集器还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小<code>-Xmn</code>、Eden 和 Survivor 区的比例<code>-XX:SurvivorRatio</code>、晋升老年代对象年龄<code>-XX:PretenureSizeThreshold</code>等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 <strong>GC 自适应的调节策略</strong>（GC Ergonomics）。</p><h1 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a>并发标记清除收集器</h1><blockquote><p>开启选项：-XX:+UseConcMarkSweepGC<br>打开此开关后，使用 CMS + ParNew + Serial Old 收集器组合来进行内存回收。</p></blockquote><p><strong>并发标记清除收集器是以获取最短停顿时间为目标。</strong></p><p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 Concurrent Mode Failure ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p><strong>CMS 收集器是一种以获取最短停顿时间为目标的收集器。JVM9移除</strong></p><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法.</p><p><strong>运行示意图</strong>：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310231642976.png" alt="image-20231023164255376"></p><h3 id="CMS收集器各个阶段"><a href="#CMS收集器各个阶段" class="headerlink" title="CMS收集器各个阶段"></a>CMS收集器各个阶段</h3><h4 id="阶段1：初始标记—STW"><a href="#阶段1：初始标记—STW" class="headerlink" title="阶段1：初始标记—STW"></a>阶段1：初始标记—STW</h4><p>仅仅只是标记一下 GC Roots 能直接关联到的对象（包括根对象直接引用的对象，以及被年轻代中所有存活的对象所引用的老年代对象），速度很快，需要停顿。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310241124055.png" alt="image-20231024112453873"></p><h4 id="阶段2：并发标记—并发"><a href="#阶段2：并发标记—并发" class="headerlink" title="阶段2：并发标记—并发"></a>阶段2：并发标记—并发</h4><p>遍历所有的对象，标记存活的对象，从前一阶段“初始标记”找到的根元素开始算起。</p><p>此阶段由于与用户线程并发执行，对象的状态可能会发生变化，如下：</p><ul><li>年轻代的对象从年轻代晋升到老年代</li><li>有些对象被直接分配到老年代</li><li>老年代和年轻代的对象引用关系变化</li></ul><p>JVM会通过<code>Card(卡片)</code>的方式将发生改变的老年代区域标记为“脏”区，这就是所谓的<code>卡片标记（Card Marking）</code></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310241458159.png" alt="image-20231024145830642"></p><h4 id="阶段3：并发预清理—并发"><a href="#阶段3：并发预清理—并发" class="headerlink" title="阶段3：并发预清理—并发"></a>阶段3：并发预清理—并发</h4><p>标记老年代存活的对象，此阶段仍然是与应用线程并发执行的，不需要停止应用线程。</p><p><strong>目的：</strong> 让最终&#x2F;重新标记的STW时间尽可能短</p><p><strong>标记目标：</strong></p><ul><li>老年代中在<strong>并发标记阶段</strong>中被标记为<strong>dirty</strong>的card</li><li>幸存区（from和to）中引用的老年代对象</li></ul><p><strong>关闭参数：</strong><code>-XX:-CMSPrecleaningEnabled</code>，<strong>默认开启</strong></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310241713880.png" alt="image-20231024171341252"></p><h4 id="阶段4：可取消的并发预清理—并发"><a href="#阶段4：可取消的并发预清理—并发" class="headerlink" title="阶段4：可取消的并发预清理—并发"></a>阶段4：可取消的并发预清理—并发</h4><p>不停止应用程序，本阶段尝试在STW的最终标记阶段之前尽可能多做一些工作。可取消。</p><p><strong>存在价值</strong>：在进入最终标记前尽量等到一个Minor GC，尽量缩短最终标记阶段的停顿时间。</p><p><strong>触发条件：</strong> 在预清理步骤后，如果满足下面这个个条件，就会开启可中断的预清理，直接进入重新标记阶段</p><ul><li>Eden的使用空间大于<code>-XX:CMSScheduleRemarkEdenSizeThreshold</code>，这个参数的默认值是2M</li></ul><p><strong>取消条件：</strong></p><ul><li>设置了<code>CMSMaxAbortablePrecleanLoops</code>循环次数，并且执行的次数大于或者等于这个值的时候。<strong>默认为0</strong></li><li><code>CMSMaxAbortablePrecleanTime</code>，执行可中断预清理的时间超过了这个值，这个参数的<strong>默认值是5000毫秒</strong></li><li>Eden的使用率达到<code>-XX:CMSScheduleRemarkEdenPenetration</code>，**这个参数的默认值是50%**。</li></ul><p>CMS提供了参数<code>CMSScavengeBeforeRemark</code>在执行remark操作之前先做一次<code>Young GC</code>，目的在于减少年轻代对老年代的无效引用，降低remark时的开销。</p><h4 id="阶段5：最终标记-x2F-重标记—STW"><a href="#阶段5：最终标记-x2F-重标记—STW" class="headerlink" title="阶段5：最终标记&#x2F;重标记—STW"></a>阶段5：最终标记&#x2F;重标记—STW</h4><p>第二次（也是最后一次）STW停顿。</p><p><strong>作用：</strong> 重新扫描堆中的对象，因为之前的预清理阶段是并发执行的，有可能GC线程跟不上应用程序的修改速度。</p><p><strong>扫描范围：</strong> 新生代对象+GC Roots+被标记为<strong>脏区</strong>的对象。<strong>如果预清理阶段没有做好，这一步扫描新生代的时候就会花很多时间。</strong></p><h4 id="阶段6：并发清除-Concurrent-Sweep"><a href="#阶段6：并发清除-Concurrent-Sweep" class="headerlink" title="阶段6：并发清除 Concurrent Sweep"></a>阶段6：并发清除 Concurrent Sweep</h4><p><strong>作用</strong>：JVM在此阶段删除不再使用的对象，并回收他们占用的内存空间。</p><h4 id="阶段7：并发重置-Concurrent-Reset"><a href="#阶段7：并发重置-Concurrent-Reset" class="headerlink" title="阶段7：并发重置 Concurrent Reset"></a>阶段7：并发重置 Concurrent Reset</h4><p><strong>作用</strong>：重置CMS算法相关的内部数据，为下一次GC循环做准备</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li><strong>吞吐量降低</strong>：对处理器资源敏感，执行垃圾收集时会占用一部分线程导致程序吞吐量降低。</li><li><strong>占用CPU资源，与CPU核数挂钩</strong>：CMS默认启动的回收线程是（CPU核心数 +3）&#x2F;4，当CPU核数越多，垃圾回收线程占用的资源就越少，反正CPU核数越少，占用资源就越多。</li><li><strong>内存碎片问题</strong>：CMS使用的是标记-清除算法，这种算法的弊端就是会产生内存碎片，导致大对象无法分配，就会触发Full GC。<ul><li>CMS收集器提供了一个参数<code>-XX:+UseCMSCompactAtFullCollection(默认开启,JDK9废弃)</code>，在进行Full GC之前进行一次内存整理（<strong>无法并发，Shenandoah和ZGC可以</strong>）。</li><li>CMS还提供了一个参数<code>-XX:CMSFullGCsBeforeCompaction=n（默认为0，表示每次进入Full GC时都进行碎片整理）</code>，参数作用是当CMS收集器执行过n次不整理内存碎片后，下一次进入Full GC前先进行碎片整理。</li></ul></li><li><strong>无法处理浮动垃圾</strong>：在并发收集阶段时，用户线程创建了一个对象年轻代放不下，直接晋升到老年代，或者年轻代对象晋升到老年代时老年代。因此CMS垃圾收集器必须要预留一部分空间给用户线程（需要更大的堆空间），不能等到老年代满了才收集（JDK5及之前是68%，JDK6之后调整为92%，可通过  <code>-XX:CMSInitiatingOccupancyFraction_=数值</code>+ <code>-XX:+UseCMSInitiatingOccupancyOnly</code>来设置）<ul><li>当设置<code>-XX:CMSInitiatingOccupancyFraction</code>过大时，就可能会出现垃圾收集过程中无法分配对象的问题，导致<strong>并发失败</strong>（Concurrent Mode Failure），此时会临时启用Serial Old收集器来重新进行老年代收集，这会导致停顿时间更长。</li></ul></li></ul><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><blockquote><p>开启选项：-XX:+UseParNewGC</p></blockquote><p>ParNew 收集器其实是 Serial 收集器的多线程版本。主要是为了配合 CSM 的垃圾收集而提供的年轻代的垃圾收集器，其只有年轻代的收集版本。</p><p>Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>ParNew 收集器也是使用 <code>-XX:+UseConcMarkSweepGC</code> 后的默认年轻代收集器。</p><p>ParNew 收集器默认开启的线程数量与 CPU 数量相同，可以使用 <code>-XX:ParallelGCThreads</code> 参数来设置线程数。</p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><blockquote><p>开启选项：-XX:+UseG1GC</p><p>Garbage First：每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。</p></blockquote><p>前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 <strong>G1 是一种兼顾吞吐量和停顿时间的 GC 收集器</strong>。G1 是 Oracle JDK9 以后的默认 GC 收集器。<strong>G1 可以直观的设定停顿时间的目标</strong>，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p><p>G1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷</p><h3 id="分区Region"><a href="#分区Region" class="headerlink" title="分区Region"></a>分区Region</h3><p>G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。<strong>通过记录每个 Region 垃圾回收时间以及回收所获得的空间</strong>（这两个值是通过过去回收的经验获得），<strong>并维护一个优先列表</strong>，<strong>每次根据允许的收集时间</strong>，<strong>优先回收价值最大的 Region</strong>。</p><p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可。</p><p>启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小(1MB~32MB，且<strong>必须是2的幂</strong>)，默认将整堆划分为2048个分区。</p><h3 id="卡片Card"><a href="#卡片Card" class="headerlink" title="卡片Card"></a>卡片Card</h3><p>在每个分区内部又被分成了若干个大小为512 Byte**卡片(Card)**，标识堆内存最小可用粒度。</p><p>所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。</p><p>每次对内存的回收，都是对指定分区的卡片进行处理。</p><h3 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h3><p>G1同样可以通过<code>-Xms/-Xmx</code>来指定堆空间大小。</p><p>如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低。</p><p>目标参数<code>-XX:GCTimeRatio</code>即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。</p><p>当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起Full GC。Full GC后，也会调整堆空间。</p><p><strong>G1分区示意图</strong></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252148963.png" alt="image-20231025214845362"></p><h3 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h3><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252158432.png" alt="image-20231025215816612"></p><h4 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h4><p>G1将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为<strong>Eden</strong>空间和<strong>Survivor</strong>空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。</p><blockquote><p>整个年轻代内存会在初始空间<code>-XX:G1NewSizePercent</code>(默认整堆5%)与最大空间(默认60%)之间动态变化，且该值由下面三个参数计算</p><ul><li>参数目标暂停时间<code>-XX:MaxGCPauseMillis</code>(默认200ms)</li><li>需要扩缩容的大小<code>-XX:G1MaxNewSizePercent</code></li><li>分区的已记忆集合(RSet)</li></ul><p>G1依然可以设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)，但同时暂停目标将失去意义。</p></blockquote><h4 id="本地分配缓冲"><a href="#本地分配缓冲" class="headerlink" title="本地分配缓冲"></a>本地分配缓冲</h4><ul><li><p>应用线程可以独占一个**本地缓冲区(TLAB)**来创建的对象，而大部分都会落入Eden区域（巨型对象或分配失败除外）。</p></li><li><p>每次垃圾收集时，每个GC线程同样可以独占一个**本地缓冲区(GCLAB)**用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间。</p></li><li><p>对于从Eden&#x2F;Survivor空间晋升(Promotion)到Survivor&#x2F;老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为**晋升本地缓冲区(PLAB)**。</p></li></ul><h3 id="分区模型"><a href="#分区模型" class="headerlink" title="分区模型"></a>分区模型</h3><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252203452.png" alt="image-20231025220346616"></p><p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p><h4 id="巨型对象Humongous-Region"><a href="#巨型对象Humongous-Region" class="headerlink" title="巨型对象Humongous Region"></a>巨型对象Humongous Region</h4><p>一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。</p><p>巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。</p><p>G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p><h4 id="已记忆集合Remember-Set-RSet"><a href="#已记忆集合Remember-Set-RSet" class="headerlink" title="已记忆集合Remember Set (RSet)"></a>已记忆集合Remember Set (RSet)</h4><p>G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。</p><p>当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p><blockquote><p><strong>可能只有老年代分区才会有RSet记录</strong>。</p><p>下面这些情况不需要将引用记录在RSet中：</p><ul><li>一个分区确定需要扫描，引用来自该分区的对象。</li><li>引用来自年轻代的对象。（因为G1每次都会对年轻代进行整体收集）</li></ul></blockquote><h4 id="Per-Region-Table-PRT"><a href="#Per-Region-Table-PRT" class="headerlink" title="Per Region Table (PRT)"></a>Per Region Table (PRT)</h4><p>为了降低RSet空间，使用下面三种模式记录：</p><ul><li>稀少：直接记录引用对象的卡片索引</li><li>细粒度：记录引用对象的分区索引</li><li>粗粒度：只记录引用数量，每个分区对应一个比特位，所以扫描时最慢，需要扫描整个堆</li></ul><h3 id="收集集合-CSet"><a href="#收集集合-CSet" class="headerlink" title="收集集合 (CSet)"></a>收集集合 (CSet)</h3><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252226814.png" alt="image-20231025222635479"></p><p>年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p><blockquote><p>候选老年代分区的CSet准入条件：</p><ul><li><p>活跃度阈值<code>-XX:G1MixedGCLiveThresholdPercent</code>(默认85%)进行设置，从而拦截那些回收开销巨大的对象；</p></li><li><p>每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比<code>-XX:G1OldCSetRegionThresholdPercent</code>(默认10%)设置数量上限。</p></li></ul></blockquote><h4 id="年轻代收集集合-CSet-of-Young-Collection"><a href="#年轻代收集集合-CSet-of-Young-Collection" class="headerlink" title="年轻代收集集合 CSet of Young Collection"></a>年轻代收集集合 CSet of Young Collection</h4><blockquote><p>年轻代回收大致过程：</p><ol><li><p>当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。</p></li><li><p>在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。</p></li><li><p>而原有的年轻代分区将被整体回收掉。</p></li></ol></blockquote><p>年轻代收集还负责维护对象的年龄(存活次数)，判断老化对象晋升，条件如下：</p><ul><li>年龄表</li><li>Survivor尺寸</li><li>Survivor填充容量<code>-XX:TargetSurvivorRatio</code>(默认50%)</li><li>最大年龄阈值<code>-XX:MaxTenuringThreshold</code>(默认15)</li></ul><h4 id="混合收集集合-CSet-of-Mixed-Collection"><a href="#混合收集集合-CSet-of-Mixed-Collection" class="headerlink" title="混合收集集合 CSet of Mixed Collection"></a>混合收集集合 CSet of Mixed Collection</h4><p>当老年代占用空间超过整堆比阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(默认45%)时，G1就会启动一次混合垃圾收集周期。</p><p>为了满足暂停目标，G1可能会产生连续多次的STW混合收集与应用线程交替执行。</p><p>为了确定收集能包含到年轻代收集集合CSet的老年代分区，JVM通过下面参数：</p><ul><li>混合周期的最大总次数<code>-XX:G1MixedGCCountTarget</code>(默认8)</li><li>堆废物百分比<code>-XX:G1HeapWastePercent</code>(默认5%)</li></ul><p>通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p><h3 id="并发标记算法（三色标记法）"><a href="#并发标记算法（三色标记法）" class="headerlink" title="并发标记算法（三色标记法）"></a>并发标记算法（三色标记法）</h3><p>CMS和G1在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252237896.png" alt="image-20231025223728170"></p><p>GC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252239771.gif"></p><h4 id="漏标问题"><a href="#漏标问题" class="headerlink" title="漏标问题"></a>漏标问题</h4><p>在remark过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标。会把白色D对象当作没有新引用指向从而回收掉。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252241070.png" alt="image-20231025224130061"></p><p>并发标记过程中，Mutator删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收</p><p>产生漏标问题的条件有两个：</p><ul><li>黑色对象指向了白色对象</li><li>灰色对象指向白色对象的引用消失</li></ul><p>所以要解决漏标问题，打破两个条件之一即可：</p><ul><li><strong>跟踪黑指向白的增加</strong> incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法。</li><li><strong>记录灰指向白的消失</strong> SATB snapshot at the beginning：关注引用的删除，当灰–&gt;白消失时，要把这个 引用 推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。</li></ul><p><strong>为什么G1采用SATB而不用incremental update</strong>？</p><p>因为采用incremental update把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。G1有RSet与SATB相配合。Card Table里记录了RSet，RSet里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描RSet就可以了。</p><p>也就是说 灰色–&gt;白色 引用消失时，如果没有 黑色–&gt;白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。</p><h3 id="G1垃圾回收机制"><a href="#G1垃圾回收机制" class="headerlink" title="G1垃圾回收机制"></a>G1垃圾回收机制</h3><p>【G1垃圾回收生命周期图】：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252246059.png" alt="image-20231025224639513"></p><h4 id="RSet的维护"><a href="#RSet的维护" class="headerlink" title="RSet的维护"></a>RSet的维护</h4><p>由于不能整堆扫描，又需要计算分区确切的活跃度，因此，G1需要一个增量式的完全标记并发算法，通过维护RSet，得到准确的分区引用信息。</p><p>在G1中，RSet的维护主要来源两个方面：<strong>写栅栏(Write Barrier)<strong>和</strong>并发优化线程(Concurrence Refinement Threads)</strong></p><h5 id="栅栏Barrier"><a href="#栅栏Barrier" class="headerlink" title="栅栏Barrier"></a>栅栏Barrier</h5><p>【示意图】：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252251503.png" alt="image-20231025225031116"></p><blockquote><p>栅栏的概念：</p><p>栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。而G1主要在赋值语句中，使用写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p></blockquote><p><strong>写前栅栏 Pre-Write Barrrier</strong>：</p><p>即将执行一段赋值语句时，等式左侧对象将修改引用到另一个对象，那么等式左侧对象原先引用的对象所在分区将因此丧失一个引用，那么<strong>JVM就需要在赋值语句生效之前，记录丧失引用的对象</strong>。JVM并不会立即维护RSet，而是通过批量处理，在将来RSet更新(见<strong>SATB</strong>)。</p><p><strong>写后栅栏 Post-Write Barrrier</strong>：</p><p>当执行一段赋值语句后，等式右侧对象获取了左侧对象的引用，那么等式右侧对象所在分区的RSet也应该得到更新。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)</p><h5 id="起始快照算法Snapshot-at-the-beginning-SATB"><a href="#起始快照算法Snapshot-at-the-beginning-SATB" class="headerlink" title="起始快照算法Snapshot at the beginning (SATB)"></a>起始快照算法Snapshot at the beginning (SATB)</h5><p>增量式完全并发标记算法起始快照算法(SATB)，主要针对标记-清除垃圾收集器的并发标记阶段，非常适合G1的分区块的堆结构，同时解决了CMS的主要烦恼：重新标记暂停时间长带来的潜在风险。</p><p>SATB会创建一个对象图，相当于堆的逻辑快照，从而确保并发标记阶段所有的垃圾对象都能通过快照被鉴别出来。当赋值语句发生时，应用将会改变了它的对象图，那么JVM需要记录被覆盖的对象。因此写前栅栏会在引用变更前，将值记录在SATB日志或缓冲区中。每个线程都会独占一个SATB缓冲区，初始有256条记录空间。当空间用尽时，线程会分配新的SATB缓冲区继续使用，而原有的缓冲去则加入全局列表中。<strong>最终在并发标记阶段，并发标记线程(Concurrent Marking Threads)在标记的同时，还会定期检查和处理全局缓冲区列表的记录，然后根据标记位图分片的标记位，扫描引用字段来更新RSet</strong>。此过程又称为并发标记&#x2F;SATB写前栅栏。</p><h5 id="并发优化线程Concurrence-Refinement-Threads"><a href="#并发优化线程Concurrence-Refinement-Threads" class="headerlink" title="并发优化线程Concurrence Refinement Threads"></a>并发优化线程Concurrence Refinement Threads</h5><p>当赋值语句发生后，写后栅栏会先通过G1的过滤技术判断是否是跨分区的引用更新，并将跨分区更新对象的卡片加入缓冲区序列，即更新日志缓冲区或脏卡片队列。与SATB类似，一旦日志缓冲区用尽，则分配一个新的日志缓冲区，并将原来的缓冲区加入全局列表中。</p><p>并发优化线程(Concurrence Refinement Threads)，只专注扫描日志缓冲区记录的卡片来维护更新RSet，线程最大数目可通过<code>-XX:G1ConcRefinementThreads</code>(默认等于<code>-XX:ParellelGCThreads</code>)设置。并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。如果记录增长很快或者来不及处理，那么通过阈值<code>-X:G1ConcRefinementGreenZone/-XX:G1ConcRefinementYellowZone/-XX:G1ConcRefinementRedZone</code>，G1会用分层的方式调度，使更多的线程处理全局列表。如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p><h4 id="并发标记周期-Concurrent-Marking-Cycle"><a href="#并发标记周期-Concurrent-Marking-Cycle" class="headerlink" title="并发标记周期 Concurrent Marking Cycle"></a>并发标记周期 Concurrent Marking Cycle</h4><p>这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成<strong>根标记</strong>、识别所有(可能**)存活对象**，并计算每个分区的活跃度，从而确定GC效率等级。</p><p>当达到IHOP阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(老年代占整堆比，默认45%)时，便会触发并发标记周期。</p><p>整个并发标记周期有下面几个阶段：</p><ul><li><strong>初始标记</strong>(Initial Mark)—STW</li><li><strong>根分区扫描</strong>(Root Region Scanning)</li><li><strong>并发标记</strong>(Concurrent Marking)</li><li><strong>重新标记</strong>(Remark)——STW</li><li><strong>清除</strong>(Cleanup)——STW</li></ul><p>其中，初始标记(随年轻代收集一起活动)、重新标记、清除是STW的，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。</p><h5 id="初始标记-Initial-Mark——SWT"><a href="#初始标记-Initial-Mark——SWT" class="headerlink" title="初始标记 Initial Mark——SWT"></a>初始标记 Initial Mark——SWT</h5><p>初始标记(Initial Mark)负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Java应用线程暂停掉，也就是需要一个STW的时间段。</p><p>事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为<strong>借道</strong>(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，分区的初始标记是并发执行，直到所有的分区处理完。</p><h5 id="根分区扫描-Root-Region-Scanning——并发"><a href="#根分区扫描-Root-Region-Scanning——并发" class="headerlink" title="根分区扫描 Root Region Scanning——并发"></a>根分区扫描 Root Region Scanning——并发</h5><p>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。</p><p>此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为<strong>根分区扫描</strong>(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。</p><p>根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p><h5 id="并发标记-Concurrent-Marking——并发"><a href="#并发标记-Concurrent-Marking——并发" class="headerlink" title="并发标记 Concurrent Marking——并发"></a>并发标记 Concurrent Marking——并发</h5><p>和应用线程并发执行，并发标记线程在并发标记阶段启动，由参数<code>-XX:ConcGCThreads</code>(默认GC线程数的1&#x2F;4，即<code>-XX:ParallelGCThreads/4</code>)控制启动数量，每个线程每次只扫描一个分区，从而标记出存活对象图。在这一阶段会处理Previous&#x2F;Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。参数<code>-XX:+ClassUnloadingWithConcurrentMark</code>会开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次年轻代收集。如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。</p><h5 id="存活数据计算-Live-Data-Accounting"><a href="#存活数据计算-Live-Data-Accounting" class="headerlink" title="存活数据计算 Live Data Accounting"></a>存活数据计算 Live Data Accounting</h5><p>存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。</p><h5 id="重新标记-Remark——STW"><a href="#重新标记-Remark——STW" class="headerlink" title="重新标记 Remark——STW"></a>重新标记 Remark——STW</h5><p>在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。前面几步是并行执行的，通过参数<code>-XX:ParallelGCThread</code>可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p><h5 id="清除-Cleanup——STW"><a href="#清除-Cleanup——STW" class="headerlink" title="清除 Cleanup——STW"></a>清除 Cleanup——STW</h5><p>主要做下面操作：</p><ul><li><p><strong>RSet梳理</strong>，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数<code>-XX:+PrintAdaptiveSizePolicy</code>可以开启打印启发式算法决策细节；</p></li><li><p><strong>整理堆分区</strong>，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；</p></li><li><p><strong>识别所有空闲分区</strong>，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期</p></li></ul><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><table><thead><tr><th>收集器</th><th>串行&#x2F;并行&#x2F;并发</th><th>年轻代&#x2F;老年代</th><th>收集算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>年轻代</td><td>复制</td><td>响应速度优先</td><td>单 CPU 环境下的 Client 模式</td></tr><tr><td>Serial Old</td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td>ParNew</td><td>串行 + 并行</td><td>年轻代</td><td>复制算法</td><td>响应速度优先</td><td>多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td>Parallel Scavenge</td><td>串行 + 并行</td><td>年轻代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td>Parallel Old</td><td>串行 + 并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td>CMS</td><td>并行 + 并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网站或 B&#x2F;S 系统服务端上的 Java 应用</td></tr><tr><td>G1</td><td>并行 + 并发</td><td>年轻代 + 老年代</td><td>标记-整理 + 复制算法</td><td>响应速度优先</td><td>面向服务端应用，将来替换 CMS</td></tr></tbody></table><h1 id="四、内存分配与回收策略"><a href="#四、内存分配与回收策略" class="headerlink" title="四、内存分配与回收策略"></a>四、内存分配与回收策略</h1><p>对象的内存分配，也就是在堆上分配。主要分配在年轻代的 Eden 区上，少数情况下也可能直接分配在老年代中、</p><h2 id="4-1-Minor-GC"><a href="#4-1-Minor-GC" class="headerlink" title="4.1 Minor GC"></a>4.1 Minor GC</h2><p>当 Eden 区空间不足时，触发 Minor GC。</p><p>Minor GC 发生在年轻代上，因为年轻代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p><p>Minor GC 工作流程：</p><ol><li>Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间不足时（达到设定的阈值），触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。</li><li>经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件。这时候，另外一个 Survivor 区域则会成为 To 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 To 区域，并且存活的年龄计数会被加 1。</li><li>类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过 <code>-XX:MaxTenuringThreshold</code> 参数指定。</li></ol><h2 id="4-2-Full-GC"><a href="#4-2-Full-GC" class="headerlink" title="4.2 Full GC"></a>4.2 Full GC</h2><p>Full GC 发生在老年代上，老年代对象和年轻代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。</p><h2 id="4-3-内存分配策略"><a href="#4-3-内存分配策略" class="headerlink" title="4.3 内存分配策略"></a>4.3 内存分配策略</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h3><p>大多数情况下，对象在年轻代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</p><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 区中<strong>相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>，则<strong>年龄大于或等于该年龄的对象可以直接进入老年代</strong>，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；</p><p>如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那这时也要改为进行一次 Full GC。</p><h2 id="4-4-Full-GC-的触发条件"><a href="#4-4-Full-GC-的触发条件" class="headerlink" title="4.4  Full GC 的触发条件"></a>4.4  Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h3 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 <code>System.gc()</code></h3><p>此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过<code>-XX:DisableExplicitGC</code>来禁止 RMI 调用<code> System.gc()</code>。</p><h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 <code>java.lang.OutOfMemoryError: Java heap space</code>。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。</p><h3 id="3-方法区空间不足"><a href="#3-方法区空间不足" class="headerlink" title="3. 方法区空间不足"></a>3. 方法区空间不足</h3><p>JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中又被习惯称为<strong>永久代</strong>，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出<code> java.lang.OutOfMemoryError: PermGen space</code> 错误。为避免永久代占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。</p><h3 id="4-Minor-GC-的平均晋升空间大小大于老年代可用空间"><a href="#4-Minor-GC-的平均晋升空间大小大于老年代可用空间" class="headerlink" title="4. Minor GC 的平均晋升空间大小大于老年代可用空间"></a>4. Minor GC 的平均晋升空间大小大于老年代可用空间</h3><p>如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。</p><h3 id="5-对象大小大于-To-区和老年代的可用内存"><a href="#5-对象大小大于-To-区和老年代的可用内存" class="headerlink" title="5. 对象大小大于 To 区和老年代的可用内存"></a>5. 对象大小大于 To 区和老年代的可用内存</h3><p>由 <code>Eden 区</code>、<code>From 区</code>向<code> To 区</code>复制时，对象大小大于 To 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM参数详解</title>
    <link href="/Java/JVM%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <url>/Java/JVM%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="XX-UseConcMarkSweepGC"><a href="#XX-UseConcMarkSweepGC" class="headerlink" title="-XX:+UseConcMarkSweepGC"></a>-XX:+UseConcMarkSweepGC</h2><p>打开此开关后，使用 <strong>CMS + ParNew + Serial Old</strong> 收集器组合来进行内存回收。</p><p><strong>并发标记清除收集器是以获取最短停顿时间为目标。</strong></p><p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 Concurrent Mode Failure ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p><h2 id="XX-UseAdaptiveSizePolicy"><a href="#XX-UseAdaptiveSizePolicy" class="headerlink" title="-XX:+UseAdaptiveSizePolicy"></a>-XX:+UseAdaptiveSizePolicy</h2><p>JDK 1.8 默认使用 UseParallelGC 垃圾回收器，该垃圾回收器默认启动了 AdaptiveSizePolicy，会根据GC的情况自动计算计算 Eden、From 和 To 区的大小。</p><p><strong>注意事项：</strong></p><ol><li>在 JDK 1.8 中，如果使用 CMS，无论 UseAdaptiveSizePolicy 如何设置，都会将 UseAdaptiveSizePolicy 设置为 false</li><li>由于AdaptiveSizePolicy会动态调整 Eden、Survivor 的大小，有些情况存在Survivor 被自动调为很小，比如十几MB甚至几MB的可能，这个时候YGC回收掉 Eden区后，还存活的对象进入Survivor 装不下，就会直接晋升到老年代，导致老年代占用空间逐渐增加，从而触发FULL GC，如果一次FULL GC的耗时很长（比如到达几百毫秒），那么在要求高响应的系统就是不可取的。</li></ol><p><strong>对于面向外部的大流量、低延迟系统，不建议启用此参数，建议关闭该参数</strong>。</p><h2 id="XX-CMSClassUnloadingEnabled"><a href="#XX-CMSClassUnloadingEnabled" class="headerlink" title="-XX:+CMSClassUnloadingEnabled"></a>-XX:+CMSClassUnloadingEnabled</h2><p>表示开启 CMS 对永久代的垃圾回收（或元空间），避免由于永久代空间耗尽带来 Full GC。</p><h2 id="XX-UseCMSCompactAtFullCollection"><a href="#XX-UseCMSCompactAtFullCollection" class="headerlink" title="-XX:+UseCMSCompactAtFullCollection"></a>-XX:+UseCMSCompactAtFullCollection</h2><p>控制 <strong>Full GC</strong> 的过程中是否进行空间的整理（默认开启，注意是Full GC，不是普通CMS GC）。</p><blockquote><p>和<code>-XX: CMSFullGCsBeforeCompaction=n</code> 配合使用</p></blockquote><h2 id="XX-CMSFullGCsBeforeCompaction-x3D-n"><a href="#XX-CMSFullGCsBeforeCompaction-x3D-n" class="headerlink" title="-XX: CMSFullGCsBeforeCompaction&#x3D;n"></a>-XX: CMSFullGCsBeforeCompaction&#x3D;n</h2><p>控制多少次 Full GC 后进行一次压缩。</p><h2 id="XX-DisableExplicitGC"><a href="#XX-DisableExplicitGC" class="headerlink" title="-XX:+DisableExplicitGC"></a>-XX:+DisableExplicitGC</h2><p>禁止代码中显示调用GC。</p><h2 id="XX-CMSMaxAbortablePrecleanTime"><a href="#XX-CMSMaxAbortablePrecleanTime" class="headerlink" title="-XX:CMSMaxAbortablePrecleanTime"></a>-XX:CMSMaxAbortablePrecleanTime</h2><p>控制CMS垃圾回收的<strong>abortable preclean阶段</strong>结束时间。默认值5s。</p><h4 id="CMS垃圾回收的6个重要阶段"><a href="#CMS垃圾回收的6个重要阶段" class="headerlink" title="CMS垃圾回收的6个重要阶段"></a>CMS垃圾回收的6个重要阶段</h4><ol><li><strong>initial-mark 初始标记</strong>（CMS的第一个STW阶段）：标记GC Root直接引用的对象，GC Root直接引用的对象不多，所以很快。</li><li><strong>concurrent-mark 并发标记阶段</strong>：由第一阶段标记过的对象出发，所有可达的对象都在本阶段标记。</li><li><strong>concurrent-preclean 并发预清理阶段</strong>，也是一个并发执行的阶段。在本阶段，会查找前一阶段执行过程中,从新生代晋升或新分配或被更新的对象。通过并发地重新扫描这些对象，预清理阶段可以减少下一个stop-the-world 重新标记阶段的工作量。</li><li><strong>concurrent-abortable-preclean 并发可中止的预清理阶段</strong>：这个阶段其实跟上一个阶段做的东西一样，也是为了减少下一个STW重新标记阶段的工作量。增加这一阶段是为了让我们可以控制这个阶段的结束时机，比如扫描多长时间（默认5秒）或者Eden区使用占比达到期望比例（默认50%）就结束本阶段</li><li><strong>remark 重标记阶段</strong>（CMS的第二个STW阶段），暂停所有用户线程，从GC Root开始重新扫描整堆，标记存活的对象。需要注意的是，虽然CMS只回收老年代的垃圾对象，但是这个阶段依然需要扫描新生代，因为很多GC Root都在新生代，而这些GC Root指向的对象又在老年代，这称为“跨代引用”。</li><li><strong>concurrent-sweep ，并发清理</strong>。</li></ol><h2 id="XX-HeapDumpOnOutOfMemoryError"><a href="#XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="-XX:+HeapDumpOnOutOfMemoryError"></a>-XX:+HeapDumpOnOutOfMemoryError</h2><p>当JVM发生OOM时，自动生成DUMP文件。</p><h2 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h2><p>打印输出详细的GC收集日志的信息。</p><blockquote><p>Heap<br> PSYoungGen      total 6144K, used 2058K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>  eden space 5632K, 36% used [0x00000000ff980000,0x00000000ffb82950,0x00000000fff00000)<br>  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br> ParOldGen       total 13824K, used 0K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)<br>  object space 13824K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff980000)<br> Metaspace       used 3032K, capacity 4494K, committed 4864K, reserved 1056768K<br>  class space    used 330K, capacity 386K, committed 512K, reserved 1048576K</p></blockquote><h2 id="XX-PrintGCDateStamps"><a href="#XX-PrintGCDateStamps" class="headerlink" title="-XX:+PrintGCDateStamps"></a>-XX:+PrintGCDateStamps</h2><p>格式化GC日志输出时间。</p><h2 id="XX-CMSInitiatingOccupancyFraction-x3D-70"><a href="#XX-CMSInitiatingOccupancyFraction-x3D-70" class="headerlink" title="-XX:CMSInitiatingOccupancyFraction&#x3D;70"></a>-XX:CMSInitiatingOccupancyFraction&#x3D;70</h2><p>在使用CMS收集器的情况下，老年代使用达到指定阈值的内存时，触发FullGC.。</p><h2 id="XX-UseCMSInitiatingOccupancyOnly"><a href="#XX-UseCMSInitiatingOccupancyOnly" class="headerlink" title="-XX:+UseCMSInitiatingOccupancyOnly"></a>-XX:+UseCMSInitiatingOccupancyOnly</h2><p>指定用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction参数的值)，如果不指定，JVM仅在第一次使用设定值，后续则会根据运行时采集的数据做自动调整。如果指定了该参数，那么每次JVM都会在到达规定设定值时才进行GC。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾回收基础</title>
    <link href="/Java/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/Java/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="如何判断对象需要回收？"><a href="#如何判断对象需要回收？" class="headerlink" title="如何判断对象需要回收？"></a>如何判断对象需要回收？</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。</p><p><strong>缺点：</strong>两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReferenceCountingGC</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGC</span>();<br>        <span class="hljs-type">ReferenceCountingGC</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGC</span>();<br>        objectA.instance = objectB;<br>        objectB.instance = objectA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为循环引用的存在，所以 Java 虚拟机不适用引用计数算法。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过一系列的称为<code>GC Roots</code>的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链相连的话，则证明此对象不可用。即能到达的对象视为存活，不能到达的对象视为失活。</p><blockquote><p>对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的， 因此它们将会被判定为可回收的对象。</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310212252917.png" alt="image-20231021225232901"><br>可作为<code>GC Roots</code>的对象包括以下几种：</p><ul><li><strong>虚拟机栈中引用的对象</strong>。譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等</li><li><strong>本地方法栈中引用的对象（Native)方法</strong>。</li><li><strong>方法区中，类静态属性引用的对象</strong>。譬如Java类的引用类型静态变量。</li><li><strong>方法区中，常量引用的对象</strong>。譬如字符串常量池（String Table）里的引用。</li><li><strong>Java虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 具有四种强度不同的引用类型。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p><code>被强引用关联的对象不会被垃圾收集器回收。</code><br>创建方法：使用<code>new</code>一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p><code>被软引用（Soft Reference）关联的对象，只有在内存不够的情况下才会被回收。</code></p><p>创建方法：使用 <code>SoftReference</code> 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 使对象只被软引用关联</span><br></code></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p><code>被弱引用（Weak Reference）关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。</code></p><p>创建方法：使用 <code>WeakReference</code> 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>WeakReference&lt;Object&gt; wf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p><code>WeakHashMap</code> 的 <code>Entry</code> 继承自 <code>WeakReference</code>，主要用来实现缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt;<br></code></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</p><p>为一个对象设置虚引用关联的唯一目的就是<code>能在这个对象被收集器回收时收到一个系统通知。</code></p><p>创建方法：使用 <code>PhantomReference</code> 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>PhantomReference&lt;Object&gt; pf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>虚引⽤必须和引⽤队列（ReferenceQueue）联合使⽤。当垃圾回收器准备回收⼀个对象时，如果发现它还有虚引⽤，就会在回收对象的内存之前，把这个虚引⽤加⼊到与之关联的引⽤队列中。程序可以通过判断引⽤队列中是 否已经加⼊了虚引⽤，来了解被引⽤的对象是否将要被垃圾回收。程序如果发现某个虚引⽤已经被加⼊到引⽤队列，那么就可以在所引⽤的对象的内存被回收之前采取必要的⾏动。</p><h3 id="1-4-方法区的回收"><a href="#1-4-方法区的回收" class="headerlink" title="1.4 方法区的回收"></a>1.4 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比年轻代差很多，因此在方法区上进行回收性价比不高。</p><p><strong>主要是对常量池的回收和对类的卸载。</strong></p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><p>可以通过 <code>-Xnoclassgc</code> 参数来控制是否对类进行卸载。</p><h3 id="1-5-finalize"><a href="#1-5-finalize" class="headerlink" title="1.5  finalize()"></a>1.5  <code>finalize()</code></h3><p><code>finalize()</code> 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 <code>try-finally</code> 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用<code> finalize()</code>。</p><p>当一个对象可被回收时，如果需要执行该对象的 <code>finalize()</code> 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="垃圾收集性能"><a href="#垃圾收集性能" class="headerlink" title="垃圾收集性能"></a>垃圾收集性能</h2><p>垃圾收集器的性能指标主要有两点：</p><ul><li><strong>停顿时间</strong>：停顿时间是因为 <code>GC</code> 而导致程序不能工作的时间长度。</li><li><strong>吞吐量</strong>：吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。</li></ul><h2 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记 - 清除（Mark-Sweep）算法"></a>标记 - 清除（Mark-Sweep）算法</h2><p>将需要回收的对象进行标记，然后清理掉被标记的对象。</p><p><strong>缺点</strong>：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h2 id="标记-整理（Mark-Compact）算法"><a href="#标记-整理（Mark-Compact）算法" class="headerlink" title="标记 - 整理（Mark-Compact）算法"></a>标记 - 整理（Mark-Compact）算法</h2><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><strong>不足</strong>：这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p><h2 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h2><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p><strong>不足</strong>：主要不足是只使用了内存的一半。</p><blockquote><p>现在的商业虚拟机都采用这种收集算法来回收年轻代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间。每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p></blockquote><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将 Java 堆分为年轻代和老年代。</p><ul><li>年轻代使用：<strong>复制</strong> 算法</li><li>老年代使用：<strong>标记 - 清理</strong> 或者 <strong>标记 - 整理</strong> 算法</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310212310673.png" alt="image-20231021231002355"></p><p>Java 8 JVM 的内存结构主要由三大块组成：堆内存、元空间和栈，Java 堆是内存空间占据最大的一块区域。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310221247489.png" alt="image-20231022124750244"></p><h3 id="新生代（Young-generation）"><a href="#新生代（Young-generation）" class="headerlink" title="新生代（Young generation）"></a>新生代（Young generation）</h3><p>新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。</p><p>其内部又分为 <code>Eden</code> 区域，作为对象初始分配的区域；两个 <code>Survivor</code>，有时候也叫 <code>from、to </code>区域，被用来放置从 <code>Minor GC </code>中保留下来的对象。</p><p>新生成的对象会被分配在<code>Eden</code>区域（如果对象太大会直接分配在老年代中），第一次GC会随机选取一个<code>survivor</code>作为<code>to</code>区域，另一个区域就是<code>from</code>区，将<code>Eden</code>区域存活的对象复制到<code>to</code>区域。第二次GC时，<code>from</code>和<code>to</code>区职责互换，这时会将<code>Eden</code>区和上一次的<code>to</code>区域中存活的对象复制到<code>from</code>区域。</p><p>JVM 会随意选取一个 <code>Survivor</code> 区域作为 <code>to</code>，然后会在 GC 过程中进行区域间拷贝，也就是将 <code>Eden</code> 中存活下来的对象和 <code>from</code> 区域的对象，拷贝到这个to区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p><p>Java 虚拟机会记录 <code>Survivor</code> 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 <code>-XX:+MaxTenuringThreshold</code>），那么该对象将被晋升（promote）至老年代。另外，如果单个 <code>Survivor</code> 区已经被占用了 50%（对应虚拟机参数 <code>-XX:TargetSurvivorRatio</code>），那么较高复制次数的对象也会被晋升至老年代。</p><h3 id="老年代（Old-generation）"><a href="#老年代（Old-generation）" class="headerlink" title="老年代（Old generation）"></a>老年代（Old generation）</h3><p>放置长生命周期的对象，通常都是从 <code>Survivor</code> 区域拷贝过来的对象。当然，也有特殊情况，<strong>如果对象较大</strong>，JVM 会试图直接分配在 Eden 其他位置上；<strong>如果对象太大</strong>，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p><h3 id="永久代（Permanent-generation）"><a href="#永久代（Permanent-generation）" class="headerlink" title="永久代（Permanent generation）"></a>永久代（Permanent generation）</h3><p>这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存。在 JDK 8 之后就不存在永久代这块儿了。</p><p>Java8 之前使用永久代（Permanent Generation，简称 PermGen）实现方法区，而 <strong>Java8 之后使用元空间（Metaspace）</strong>实现。</p><p>JDK8 之前可以通过<code>-XX:PermSize</code>和<code> -XX:MaxPermSize</code> 来设置永久代大小，JDK8 之后，使用元空间替换了永久代，改为通过<code> -XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 来设置元空间大小。</p><h4 id="永久代问题"><a href="#永久代问题" class="headerlink" title="永久代问题"></a>永久代问题</h4><p><strong>1. 内存溢出</strong></p><p>永久代的空间是有限制的，可以通过 <code>-XX:PermSize</code> 设置永久代初始容量，通过<code>-XX:MaxPermSize</code> 设置永久代最大容量。</p><p>但是当加载过多的类或者常量的时候，就可能导致永久代的空间不足，抛出 java.lang.OutOfMemoryError: PermGen space 异常。</p><p><strong>2. 垃圾回收效率低下</strong></p><p>永久代中的类信息一般是在应用程序运行期间不会发生变化的，因此，如果开启了永久代的垃圾回收，就会造成大量的垃圾回收操作，导致垃圾回收效率低下，甚至会引起应用程序的暂停。</p><p>此外，由于永久代主要存放 JVM 加载的类信息等永久存在的数据，这使得它在垃圾回收过程中的回收效率相对较低。在某些情况下，频繁触发的 Full GC 不仅无法有效回收永久代空间，还会严重影响 JVM 的性能。</p><p><strong>3. 无法动态调整大小</strong></p><p>永久代的大小一旦被设置，就无法动态调整，如果预估错误，就可能导致浪费内存或内存不足的问题。</p><p><strong>4. 无法回收常量池中的内存</strong></p><p>在永久代中，常量池是一个非常重要的部分，但是其中的常量无法被回收，即使这些常量已经不再被使用，也无法被垃圾回收器回收，这会浪费内存。</p><h3 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h3><blockquote><p>元空间（Metaspace）是 Java8 中引入的一个新概念，用来替代原来的永久代。与永久代不同，元空间并不在虚拟机中，而是存储在本地内存（Native Memory）。</p></blockquote><p>在 Java8 中彻底移除了永久代，把将<strong>类的元数据信息、运行时常量、类常量、静态变量、即时编译器编译后的代码</strong>从永久代中移到了元空间中，<strong>字符串常量由永久代转移到堆中</strong>。</p><p><strong>【优点】</strong></p><ol><li><strong>突破内存限制，减少OOM</strong>。 由于元空间使用的是本地内存，而不是 JVM 内存，因此理论上，其大小只受限于操作系统的实际可用内存。这大大减少了内存溢出的可能性。相较于永久代在 JVM 堆中预分配的有限空间，元空间的引入提供了更大的空间来存储类元数据。</li><li><strong>提高 Full GC 的效率</strong>。 在永久代中，Full GC 的触发比较频繁，而且效率较低。因为永久代中存放了很多 JVM 需要的类信息，这些数据大多数是不会被清理的，所以 Full GC 往往无法回收多少空间。但在元空间模型中，由于字符串常量池已移至堆中，静态变量也移至 Java 堆或者本地内存，因此可以更有效地进行垃圾回收，避免了因频繁的 Full GC 导致的性能影响。</li><li><strong>满足不同的类加载需求和动态类加载的情况</strong>。 在一些大型的、模块化的应用中，可能需要加载大量的类，这就需要大量的元数据存储空间。元空间可以动态地调整大小，能更好地满足这种需求。</li><li><strong>避免永久代调优和大小设置的复杂性</strong>。 在 Java8 之前的版本中，通常需要手动设置永久代的大小，以避免内存溢出的错误。这增加了应用的配置和管理的复杂性。而元空间使用本地内存，根据实际需求动态调整，大大简化了内存管理的复杂性。</li></ol><h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><p>JVM 允许对堆空间大小、各代空间大小进行设置，以调整 JVM GC。</p><table><thead><tr><th>配置</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>-Xss</td><td></td><td>虚拟机栈大小</td></tr><tr><td>-Xms</td><td>物理内存的1&#x2F;64(&lt;1GB)</td><td>堆空间初始值</td></tr><tr><td>-Xmx</td><td>物理内存的1&#x2F;4(&lt;1GB)</td><td>堆空间最大值</td></tr><tr><td>-Xmn</td><td></td><td>新生代空间大小</td></tr><tr><td>-XX:NewSize</td><td></td><td>新生代空间初始值</td></tr><tr><td>-XX:MaxNewSize</td><td></td><td>新生代空间最大值</td></tr><tr><td>-XX:NewRatio</td><td>2</td><td>新生代(包括Eden和两个Survivor区)与年老代的比例</td></tr><tr><td>-XX:SurvivorRatio</td><td>8</td><td>新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 eden 区为 80% 的大小，两个 survivor 分别为 10% 的大小</td></tr><tr><td>-XX:PermSize</td><td></td><td>永久代空间的初始值</td></tr><tr><td>MaxTenuringThreshold</td><td>15</td><td>垃圾最大年龄</td></tr><tr><td>PretenureSizeThreshold</td><td>0</td><td>超过这个值直接在old区分配，默认值是0，意思是不管多大都是先在eden中分配</td></tr><tr><td>MetaspaceSize</td><td>这个值大小根据不同的平台在12M到20M浮动。使用java -XX:+PrintFlagsInitial命令查看本机的初始化参数</td><td>初始化的Metaspace大小，控制元空间发生GC的阈值。GC后，动态增加或降低MetaspaceSize</td></tr><tr><td>MaxMetaspaceSize</td><td>默认值为4294967295B（大约4096MB）</td><td>限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序</td></tr><tr><td>MinMetaspaceFreeRatio</td><td>默认值为40，也就是40%</td><td>当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长Metaspace的大小</td></tr><tr><td>MaxMetasaceFreeRatio</td><td>默认值为70，也就是70%</td><td>当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间</td></tr><tr><td>MaxMetaspaceExpansion</td><td>默认值为5452592B（大约为5MB）</td><td>Metaspace增长时的最大幅度</td></tr><tr><td>MinMetaspaceExpansion</td><td>默认值为340784B（大约330KB为）。</td><td>Metaspace增长时的最小幅度</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的==和equals区别</title>
    <link href="/Java/Java%E7%9A%84==%E5%92%8Cequals()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/Java/Java%E7%9A%84==%E5%92%8Cequals()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="的含义"><a href="#的含义" class="headerlink" title="==的含义"></a><code>==</code>的含义</h4><ul><li>基本数据类型：<code>byte, short, int, long, float, double, char, boolean</code>。它们之间的比较用<code>==</code>，<strong>比较的是它们的值</strong>。</li><li>引用数据类型：比较的是它们<strong>在堆内存中的存放地址</strong>。</li></ul><h4 id="equals-含义"><a href="#equals-含义" class="headerlink" title="equals()含义"></a><code>equals()</code>含义</h4><p>它不能用于比较基本数据类型的变量。<code>equals()</code>方法存在于<code>Object()</code>类中，而<code>Object()</code>类是所有类的直接或间接父类。但又两种使用情况：</p><ul><li>情况1：类没有覆盖<code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象，等价于通过<code>==</code>比较这两个对象，<strong>也就是比较两个对象的地址</strong>。</li><li>情况2：类覆盖了<code>equals()</code>方法。使用<code>equals()</code>方法来<strong>比较两个对象的内容是否相等</strong>。若内容相等，则返回true.(即认为这两个对象相等）。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(s1 == s2);   <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码输出为<code>true</code>。是不是很奇怪？这就涉及到Java的内存。<code>s1</code>实际上创建了一个字符串常量，存放在<strong>字符串常量池</strong>中。<code>s2</code>再创建时，会去寻找字符串常量池中有没有该内容的字符串。有的话则<strong>直接将s2的引用指向字符串常量池中的字符串</strong>。所以这里<code>s1和s2指向的是同一个地址</code>，因此打印<code>true</code>。<br><a href="https://blog.csdn.net/weixin_43207025/article/details/109576226">详细可参考这篇文章</a>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> equals.src;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str2;<br>        System.out.println(str1 == str2);   <span class="hljs-comment">// false</span><br>        System.out.println(str2 == str3);   <span class="hljs-comment">// true</span><br>        System.out.println(str1 == str3);   <span class="hljs-comment">// false</span><br>        System.out.println(str1.equals(str2));  <span class="hljs-comment">// true</span><br>        System.out.println(str2.equals(str3));  <span class="hljs-comment">// true</span><br>        System.out.println(str1.equals(str3));  <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这与上述不同的地方在于，<code>str2</code>使用<code>new</code>创建了一个字符串。这时，会申请一个新的内存地址。而不是去指向字符串常量池中。所以<code>str1和str2指向的地址就不同</code>。推理，<code>str1和str3也不同</code>。而后面的<code>equals</code>使用的是<code>String</code>类覆盖的的<code>equals</code>方法，只要内容一致就返回<code>true</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS源码理解——ReentrantLock</title>
    <link href="/Java/AQS%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94ReentrantLock/"/>
    <url>/Java/AQS%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h2 id="公平锁策略"><a href="#公平锁策略" class="headerlink" title="公平锁策略"></a>公平锁策略</h2><p><strong>ReentrantLock</strong>类中 <strong>FairSync</strong> 类源码解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<br><br>    <span class="hljs-comment">// 公平锁入口</span><br>    <span class="hljs-comment">// 不响应中断的加锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">// （1）</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">         * recursive call or no waiters or is first.</span><br><span class="hljs-comment">         * 抢占成功：返回true, 包含重入锁</span><br><span class="hljs-comment">         * 抢占失败：返回false</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-comment">// 获取当前线程</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 获取AQS中当前status状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><br>        <span class="hljs-comment">// 条件成立: c == 0 表示  当前AQS处于无锁的状态</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 条件一: hasQueuedPredecessors()</span><br>            <span class="hljs-comment">// 因为FairSync是公平锁，任何时候获取锁都需要检查一下队列中在当前需要获取锁的线程前有无等待者</span><br>            <span class="hljs-comment">// hasQueuedPredecessors()方法返回true表示当前线程前面有等待者, 当前线程需要入队等待</span><br>            <span class="hljs-comment">// hasQueuedPredecessors()方法返回false表示当前线程前面无等待者, 直接可以获取锁</span><br><br>            <span class="hljs-comment">// 条件二: compareAndSetState(0, acquires) CAS设置state值, 由于是从条件一进入的此处, 队列中没有线程, CAS的预期值是0</span><br>            <span class="hljs-comment">// 成功: 说明当前线程抢占锁成功</span><br>            <span class="hljs-comment">// 失败: 说明存在竞争, 且当前线程竞争锁失败</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                <span class="hljs-comment">// 如果当前线程前面没有等待线程, 并且成功获取到锁</span><br>                <span class="hljs-comment">// 设置当前线程为独占锁的线程</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 执行到此处的情况：c != 0 或 c &gt; 0</span><br>        <span class="hljs-comment">// 这种情况需要判断当前线程是不是独占锁的线程, 因为ReentrantLock是可重入锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-comment">// 可重入锁的逻辑</span><br>            <span class="hljs-comment">// nextc 是更新AQS的state的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-comment">// 越界判断, 当重入的深度很深时, 会导致nextc&lt;0, state的最大值是int, int值达到最大之后 再+1...变负数..</span><br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 设置state的值</span><br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 执行到这里的情况</span><br>        <span class="hljs-comment">// 1. c==0时, CAS失败, CAS修改state时未抢过其他线程</span><br>        <span class="hljs-comment">// 2. c!=0或c&gt;0时, 当前线程不是独占锁线程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// The correctness of this depends on head being initialized</span><br>    <span class="hljs-comment">// before tail and on head.next being accurate if the current</span><br>    <span class="hljs-comment">// thread is first in queue.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    Node s;<br>    <span class="hljs-comment">// 条件一: h!=t 成立, 说明队列中有节点, 既然有节点, 为什么会出现条件二的判断呢？</span><br>    <span class="hljs-comment">// 条件二: h.next == null, 在向空队列中新插入节点时, 新插入的节点的前驱与前置节点(这里就是tail)建立了关联，但在head.next还未与新节点连接之前, b会出现这种情况</span><br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>        ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><p>点击上述(1)处代码进入<strong>AbstractQueuedSynchronizer</strong>源码中的<strong>acquire方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 条件一: tryAcquire(arg) 该方法在ReentrantLock类中重写, 尝试获取锁, 获取成功后返回true, 获取失败返回false</span><br>    <span class="hljs-comment">// 条件二: acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br>    <span class="hljs-comment">// 2.1: addWaiter(Node.EXCLUSIVE) 将当前线程封装成node添加到队列中</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        <span class="hljs-comment">//再次设置中断标记为true</span><br>        <span class="hljs-comment">//此处为什么要selfInterrupt()?，原因是，如果acquireQueued()返回了true，说明线程是被interrupt醒的，不是被unpark醒的，</span><br>        <span class="hljs-comment">//如果是被interrupt醒的，由于acquireQueued里面判断线程到底是怎么醒的，用的是Thread.interrupted()，该方法判断后，还会清除interrupt标记，因此这里要重新加上中断标记为。具体见https://www.zhihu.com/question/399039232</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates and enqueues node for current thread and given mode.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the new node</span><br><span class="hljs-comment"> * 返回当前线程形成的node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 构建node, 将当前线程封装到node中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-comment">// 将节点入队</span><br>    <span class="hljs-comment">// 获取队尾节点, 保存到pred变量中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 条件成立: 当队列中已经有node了</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 当前节点的prev指向前置节点, 因为此时pred是tail</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// CAS 如果成功, 说明node入队成功</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 前置节点指向当前节点, 完成双向绑定</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 什么时候执行这里?</span><br>    <span class="hljs-comment">// 1. 当前队列是空队列 tail = null</span><br>    <span class="hljs-comment">// 2. CAS竞争失败</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 自旋入队, 只有当前节点入队成功后才会跳出循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// 1. 当前队列是空队列 tail = null</span><br>        <span class="hljs-comment">// 说明当前锁被占用, 且当前线程可能是第一个获取锁失败的线程（当前时刻可能存在一批获取锁失败的线程...）</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">// 作为当前持锁线程的第一个后继线程, 需要做什么事</span><br>            <span class="hljs-comment">// 1. 因为当前持锁的线程, 在它获取锁时, 直接tryAcquire成功了, 没有向阻塞队列中添加任何node, 所以作为后继第一个进入阻塞队列的线程,需要额外处理一些事情</span><br>            <span class="hljs-comment">// 2. 在自己这个节点之前追加一个线程为空的node</span><br>            <span class="hljs-comment">// CAS成功, 说明当前节点成为head.next节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>            <span class="hljs-comment">// 注意这里执行完后并没有跳出for循环....</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 普通的入队方式, 在队列不为null时进入, 由于for是无限循环, 所以可以一直入队成功</span><br>            <span class="hljs-comment">// 要入队的节点前驱和tail绑定</span><br>            node.prev = t;<br>            <span class="hljs-comment">// CAS设置tail指针</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                <span class="hljs-comment">// 当前节点和前置节点的后驱绑定</span><br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="hljs-comment"> * queue. Used by condition wait methods as well as acquire.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node 当前线程包装出来的node，且当前时刻已经入队成功了</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the acquire argument  当前线程抢占资源成功后，设置state值时会用到</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if interrupted while waiting</span><br><span class="hljs-comment"> * true:当前线程抢占成功，普通情况下，当前线程早晚会拿到锁</span><br><span class="hljs-comment"> * false:表示失败，需要执行出队的逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当前线程是否被中断</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 为什么会执行到这里</span><br>            <span class="hljs-comment">// 1. 进行for循环时, 在线程尚未park前会执行</span><br>            <span class="hljs-comment">// 2. 线程park之后, 被唤醒后, 也会执行到这里</span><br><br>            <span class="hljs-comment">// 获取当前节点的前置节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><br>            <span class="hljs-comment">// 条件一成立：p==head, 说明当前节点为head.next节点, head.next节点在任何时候都有权力去争夺锁</span><br>            <span class="hljs-comment">// 条件二成立: tryAcquire(arg) 说明head对应的线程已经释放锁了, head.next节点对应的线程正好获取到锁</span><br>            <span class="hljs-comment">// 条件二不成立：head对应的线程还没有释放锁.. head.next仍然需要park</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 拿到锁之后需要做什么？</span><br>                <span class="hljs-comment">// 设置自己为head节点</span><br>                setHead(node);<br><br>                <span class="hljs-comment">// 将上个线程对应的node节点的next引用指向null, 使之出队</span><br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-comment">// 当前线程获取锁的过程没有异常</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 返回当前线程的中断标记</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br><br>            <span class="hljs-comment">//shouldParkAfterFailedAcquire这个方法是干嘛的？ 当前线程获取锁资源失败后，是否需要挂起呢？</span><br>            <span class="hljs-comment">//返回值：true -&gt;当前线程需要挂起  false-&gt; 不需要</span><br>            <span class="hljs-comment">//parkAndCheckInterrupt()作用：挂起当前线程，并且唤醒之后返回当前线程的中断标记</span><br>            <span class="hljs-comment">//唤醒：1：正常唤醒 其他线程unpark 2:其他线程给当前挂起的线程一个中断信号</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">//interruped=true表示当前node对应的线程是被中断信号唤醒的</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 什么时候会走到这？感觉不会走，应该是保险措施</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 总结：</span><br><span class="hljs-comment"> * 1：当前节点的前置节点是取消状态，第一次来到这个方法时会越过取消状态的节点，第二次会返回true，然后park当前线程</span><br><span class="hljs-comment"> * 2：当前节点的前置节点状态是0，当前线程会设置前置节点的状态为-1，第二次自旋来到这个方法时会返回true，然后park当前线程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pred 当前线程node的前置节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 当前线程对应node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if thread should block</span><br><span class="hljs-comment"> * 返回值：boolean true 表示当前线程需要挂起</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-comment">// 获取前置节点的状态</span><br>    <span class="hljs-comment">// waitStatus: 0 默认状态 -1 Signal状态,表示当前节点释放锁之后会唤醒它的第一个后继节点 &gt;0 表示当前节点是CANCELED状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br><br>    <span class="hljs-comment">// 条件成立：表示前置节点是个可以唤醒当前节点的节点, 返回 true  ==&gt;parkAndCheckInterrupt() park当前线程</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * This node has already set status asking a release</span><br><span class="hljs-comment">             * to signal it, so it can safely park.</span><br><span class="hljs-comment">             */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//条件成立：&gt;0,表示前置节点是CANCELED状态</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">             * indicate retry.</span><br><span class="hljs-comment">             */</span><br>        <span class="hljs-comment">// 寻找节点的waitStatus大于0的前置节点, 这些节点是取消的状态</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 找到waitStatus不是大于0的节点后, 将waitStatus &gt; 0 的节点剔除队列</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">             * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">             */</span><br>        <span class="hljs-comment">// 当前节点的前置节点是0或&lt;0的情况</span><br>        <span class="hljs-comment">// 将当前线程node的前置node状态强制设置为SIGNAL，表示前置节点释放锁之后需要唤醒我...</span><br>        <span class="hljs-comment">// 说白了就是，当某个线程的node想排队的时候，它会把它的前置node的status设置为-1</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Convenience method to park and then check if interrupted</span><br><span class="hljs-comment"> * 将当前线程挂起，唤醒后返回当前线程是否为&quot;中断信号&quot;唤醒</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 将当前线程挂起</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 唤醒后执行下面操作</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cancels an ongoing attempt to acquire.</span><br><span class="hljs-comment"> * 取消指定node参与竞争</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 因为已经取消排队了，所以node内部关联的当前线程置为null就好了</span><br>    node.thread = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Skip cancelled predecessors</span><br>    <span class="hljs-comment">// 获取当前取消排队node的前驱</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-comment">// 跳过需要需要排队的节点</span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br><br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    <span class="hljs-comment">// 拿到前驱的next节点, 有一下情况</span><br>    <span class="hljs-comment">// 1.当前node</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    <span class="hljs-comment">// 将当前node状态设置为取消状态1</span><br>    node.waitStatus = Node.CANCELLED;<br><br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当前取消排队的node所在队列的位置不同，执行出队策略是不一样的，一共分为3种情况。</span><br><span class="hljs-comment">         * 1:当前node是队尾 tail -&gt; node</span><br><span class="hljs-comment">         * 2:当前node不是head.next节点，也不是tail节点</span><br><span class="hljs-comment">         * 3:当前node是head.next节点。</span><br><span class="hljs-comment">         */</span><br><br>    <span class="hljs-comment">// 第一种情况</span><br>    <span class="hljs-comment">// 条件一: node=tail成立，当前node是队尾 tail -&gt; node</span><br>    <span class="hljs-comment">// 条件二:compareAndSetTail(node,pred)成功的话, 说明修改tail完成, 即将当前节点的前驱设置为tail</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        <span class="hljs-comment">// 修改pred.next -&gt; null,完成node出队</span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-comment">// 保存节点状态</span><br>        <span class="hljs-type">int</span> ws;<br><br>        <span class="hljs-comment">// 第二种情况：当前node不是head.next节点，也不是tail</span><br>        <span class="hljs-comment">// 条件一：pred!=head 说明当前node不是head.next节点，也不是tail节点</span><br>        <span class="hljs-comment">// 条件二： ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL)))</span><br>        <span class="hljs-comment">// 条件2.1 (ws = pred.waitStatus) == Node.SIGNAL 成立:说明node的前驱状态是Signal状态. 不成立：前驱状态可能是0，</span><br>        <span class="hljs-comment">// 极端情况下：前驱也取消排队了</span><br>        <span class="hljs-comment">// 条件2.2: (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))</span><br>        <span class="hljs-comment">// 假设前驱状态 ws&lt;=0 则设置前驱状态为Signal状态，表示要唤醒后继节点</span><br><br>        <span class="hljs-comment">// if里面做的事情，就是让pred.next -&gt; node.next, 所有需要保证pred节点状态为Signal状态</span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-comment">// 情况2：当前node不是head.next节点，也不是tail</span><br>            <span class="hljs-comment">// 出队: pred.next -&gt; node.next 节点后，当node.next节点被唤醒后，调用shouldParkAfterFailedAcquire会让node.next节点越过取消状态的节点，完成真正的出队</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                compareAndSetNext(pred, predNext, next);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前node是head.next节点</span><br>            <span class="hljs-comment">// 类似情况2，后继节点唤醒后，会调用shouldParkAfterFailedAcquire会让node.next节点越过取消状态的节点</span><br>            <span class="hljs-comment">// 队列的第三个节点会直接与head建立双重指向的关系，head.next-&gt;第三个node 中间就是被出队的head.next节点 第三个node.prev -&gt; head</span><br>            unparkSuccessor(node);<br>        &#125;<br><br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Wakes up node&#x27;s successor, if one exists.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">         * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-comment">// 获取当前节点的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//-1 Signal 改成0的原因：因为当前节点已经完成喊后续节点的任务了。</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">         * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">         * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">         * non-cancelled successor.</span><br><span class="hljs-comment">         */</span><br><br>    <span class="hljs-comment">// 条件一：</span><br>    <span class="hljs-comment">// s什么时候等于null？</span><br>    <span class="hljs-comment">// 1.当前节点就是tail节点时，s==null</span><br><br>    <span class="hljs-comment">// 条件二： s.waitStatus&gt;0 前提：s!=null</span><br>    <span class="hljs-comment">// 成立：说明当前node节点的后续节点是取消状态... 需要找一个合适的可以被唤醒的节点。此处可以画图看看。</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">            head指向节点0，s指向节点1，t指向节点5。 则最终s指向节点3</span><br><span class="hljs-comment">             0       1      2       3       4      5</span><br><span class="hljs-comment">            node -&gt; [1] -&gt; [1] -&gt; [-1] -&gt; [-1] -&gt; [0]</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 查找可以被唤醒的节点...</span><br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>        <span class="hljs-comment">// 上面循环，会找到一个离当前node最近的一个可以被唤醒的node，node可能找不到，node可能是null</span><br>    &#125;<br>    <span class="hljs-comment">// 如果找到合适的可以被唤醒的node，则唤醒..，找不到啥也不做</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>释放锁的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 尝试释放锁，tryRelease返回true表示当前线程已经完全释放锁</span><br>    <span class="hljs-comment">// 返回false，说明当前线程尚未完全释放锁</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-comment">// head什么情况下会被创建出来？</span><br>        <span class="hljs-comment">// 当持锁线程未释放线程时，且持锁期间有其他线程想要获取锁时，其他线程发现获取不了锁，而且队列是空队列，此时后续线程会为当前持锁中的线程构建出来一个head节点。后续线程会追加到head节点后面</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 条件一成立：说明队列中head已经初始化过了，ReentrantLock在使用期间发生过多线程竞争了</span><br>        <span class="hljs-comment">// 条件二成立：说明head后面一定插入过node节点</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo超时时间原理</title>
    <link href="/Dubbo/Dubbo%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E5%8E%9F%E7%90%86/"/>
    <url>/Dubbo/Dubbo%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><p>服务端：方法控制——&gt;接口控制——&gt;全局控制<br>消费端：方法控制——&gt;接口控制——&gt;全局控制</p><p><strong>超时设置的优先级</strong></p><blockquote><p>可以这样理解：如果服务端设置了超时，则消费端可以不用设置超时时间，默认会使用服务端超时配置</p></blockquote><p>优先级为：<strong>消费端方法级 &gt; 消费端接口级 &gt; 消费端全局 &gt; 服务端方法级 &gt; 服务端接口级 &gt; 服务端全局</strong></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel熔断降级</title>
    <link href="/Sentinel/Sentinel%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
    <url>/Sentinel/Sentinel%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202309182244737.png" alt="image-20230918224359647"></p><p>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p><h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>Sentinel 提供以下几种熔断策略：</p><ul><li><p>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置以下参数：</p><ul><li>允许的慢调用 RT（即最大的响应时间）：请求的响应时间大于该值则统计为慢调用。</li><li><strong>单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值</strong>，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li></ul></li><li><p>异常比例 (<code>ERROR_RATIO</code>)：当<strong>单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值</strong>，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</p></li><li><p>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的<strong>异常数目</strong>超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</p></li></ul><p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>  entry = SphU.entry(resource);<br><br>  <span class="hljs-comment">// Write your biz code here.</span><br>  <span class="hljs-comment">// &lt;&lt;BIZ CODE&gt;&gt;</span><br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>  <span class="hljs-keyword">if</span> (!BlockException.isBlockException(t)) &#123;<br>    Tracer.trace(t);<br>  &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>    entry.exit();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="熔断降级规则说明"><a href="#熔断降级规则说明" class="headerlink" title="熔断降级规则说明"></a>熔断降级规则说明</h2><p>熔断降级规则（DegradeRule）包含下面几个重要的属性：</p><table><thead><tr><th align="left">Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td align="left">resource</td><td>资源名，即规则的作用对象</td><td></td></tr><tr><td align="left">grade</td><td>熔断策略，支持<strong>慢调用比例</strong>、<strong>异常比例</strong>、<strong>异常数策略</strong></td><td>慢调用比例</td></tr><tr><td align="left">count</td><td><strong>慢调用比例</strong>模式下：慢调用临界 RT（超出该值计为慢调用）；<strong>异常比例&#x2F;异常数模式</strong>：为对应的阈值</td><td></td></tr><tr><td align="left">timeWindow</td><td>熔断时长，单位为 s</td><td></td></tr><tr><td align="left">minRequestAmount</td><td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td><td>5</td></tr><tr><td align="left">statIntervalMs</td><td>统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td><td>1000 ms</td></tr><tr><td align="left">slowRatioThreshold</td><td>慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td><td></td></tr></tbody></table><h2 id="熔断器事件监听"><a href="#熔断器事件监听" class="headerlink" title="熔断器事件监听"></a>熔断器事件监听</h2><p>Sentinel 支持注册自定义的事件监听器监听熔断器状态变换事件（state change event）。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">EventObserverRegistry.getInstance().addStateChangeObserver(<span class="hljs-string">&quot;logging&quot;</span>,<br>    (prevState, newState, rule, snapshotValue) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (newState == State.OPEN) &#123;<br>            <span class="hljs-comment">// 变换至 OPEN state 时会携带触发时的值</span><br>            System.err.println(String.format(<span class="hljs-string">&quot;%s -&gt; OPEN at %d, snapshotValue=%.2f&quot;</span>, prevState.name(),<br>                TimeUtil.currentTimeMillis(), snapshotValue));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.err.println(String.format(<span class="hljs-string">&quot;%s -&gt; %s at %d&quot;</span>, prevState.name(), newState.name(),<br>                TimeUtil.currentTimeMillis()));<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConfigurationClassPostProcessor源码理解</title>
    <link href="/Spring/ConfigurationClassPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/Spring/ConfigurationClassPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring执行BeanFactoryPostProcessor源码理解</title>
    <link href="/Spring/Spring%E6%89%A7%E8%A1%8CBeanFactoryPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/Spring/Spring%E6%89%A7%E8%A1%8CBeanFactoryPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307302031012.png" alt="image-20230730203029711"></p><h2 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h2><p>源码位于<code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</code>方法，这里省略了上下文，需要知道该方法是在<code>BeanFactory</code>准备完成后调用，位置如下图所示：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307302031111.png" alt="image-20230730203053823"></p><p>关于代码的理解都写在注释中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;<br><br><span class="hljs-comment">// WARNING: Although it may appear that the body of this method can be easily</span><br><span class="hljs-comment">// refactored to avoid the use of multiple loops and multiple lists, the use</span><br><span class="hljs-comment">// of multiple lists and multiple passes over the names of processors is</span><br><span class="hljs-comment">// intentional. We must ensure that we honor the contracts for PriorityOrdered</span><br><span class="hljs-comment">// and Ordered processors. Specifically, we must NOT cause processors to be</span><br><span class="hljs-comment">// instantiated (via getBean() invocations) or registered in the ApplicationContext</span><br><span class="hljs-comment">// in the wrong order.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Before submitting a pull request (PR) to change this method, please review the</span><br><span class="hljs-comment">// list of all declined PRs involving changes to PostProcessorRegistrationDelegate</span><br><span class="hljs-comment">// to ensure that your proposal does not result in a breaking change:</span><br><span class="hljs-comment">// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22</span><br><br><span class="hljs-comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="hljs-comment">// 无论什么情况，优先执行BeanDefinitionRegistryPostProcessors</span><br><span class="hljs-comment">// 将已经执行过的BFPP存储在processedBeans中，防止重复执行</span><br>Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-comment">// 判断beanFactory是否是BeanDefinitionRegistry类型，此处是DefaultListableBeanFactory，实现了BeanDefinitionRegistry接口，所以是true</span><br><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry registry) &#123;<br><span class="hljs-comment">// BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子集</span><br><span class="hljs-comment">// BeanDefinitionRegistryPostProcessor主要针对对象是BeanDefinition，BeanFactoryPostProcessor主要针对对象是BeanFactory</span><br><br><span class="hljs-comment">// 存放BeanFactoryPostProcessor的集合</span><br>List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 存放BeanDefinitionRegistryPostProcessor的集合</span><br>List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 1. 先处理外部集合传入的beanFactoryPostProcessors</span><br><span class="hljs-comment">// 将BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor区分开</span><br><span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<br><span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor registryProcessor) &#123;<br><span class="hljs-comment">// 直接执行下面方法</span><br>registryProcessor.postProcessBeanDefinitionRegistry(registry);<br><span class="hljs-comment">// 添加到registryProcessors集合中，后续会执行postProcessBeanFactory方法</span><br>registryProcessors.add(registryProcessor);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 添加到regularPostProcessors集合中，后续会执行postProcessBeanFactory方法</span><br>regularPostProcessors.add(postProcessor);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="hljs-comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="hljs-comment">// PriorityOrdered, Ordered, and the rest.</span><br><span class="hljs-comment">// 保存本次要执行的BeanDefinitionRegistryPostProcessors</span><br>List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="hljs-comment">// 2. 调用所有实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类</span><br><span class="hljs-comment">// 找到所有实现BeanDefinitionRegistryPostProcessor接口的bean的name</span><br>String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 遍历处理所有符合规则的postProcessorNames</span><br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-comment">// 检查是否实现了PriorityOrdered接口</span><br><span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br><span class="hljs-comment">// 获取名字对应的bean实例，添加到currentRegistryProcessors中</span><br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br><span class="hljs-comment">// 将要被执行的BFPP名称添加到processedBeans中，避免后续重复执行</span><br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 按照优先级进行排序操作</span><br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br><span class="hljs-comment">// 添加到registryProcessors中，用于最后执行postProcessBeanFactory方法</span><br><span class="hljs-comment">// 前面第一步添加的是外部定义的BeanDefinitionRegistryPostProcessor，这一步将有排序的添加进去</span><br>registryProcessors.addAll(currentRegistryProcessors);<br><span class="hljs-comment">// 遍历currentRegistryProcessors，执行postProcessBeanDefinitionRegistry方法</span><br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br><span class="hljs-comment">// 执行完毕后清空currentRegistryProcessors</span><br>currentRegistryProcessors.clear();<br><br><span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="hljs-comment">// 3. 调用所有实现Ordered接口的BeanDefinitionRegistryPostProcessors实现类</span><br><span class="hljs-comment">// 找到所有实现BeanDefinitionRegistryPostProcessor接口的bean的name</span><br><span class="hljs-comment">// 为什么和第2步重复？因为在上面执行过程中可能会新增其他的BeanDefinitionRegistryPostProcessor</span><br>postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-comment">// 检查是否实现了Ordered接口，并且还未执行过</span><br><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br><span class="hljs-comment">// 获取名字对应的bean实例，添加到currentRegistryProcessors中</span><br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br><span class="hljs-comment">// 将要被执行的BFPP名称添加到processedBeans中，避免后续重复执行</span><br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 按照优先级进行排序操作</span><br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br><span class="hljs-comment">// 添加到registryProcessors中，用于最后执行postProcessBeanFactory方法</span><br>registryProcessors.addAll(currentRegistryProcessors);<br><span class="hljs-comment">// 遍历currentRegistryProcessors，执行postProcessBeanDefinitionRegistry方法</span><br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br><span class="hljs-comment">// 执行完毕后清空currentRegistryProcessors</span><br>currentRegistryProcessors.clear();<br><br><span class="hljs-comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="hljs-comment">// 最后，调用剩下的BeanDefinitionRegistryPostProcessor</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">reiterate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (reiterate) &#123;<br>reiterate = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 找到所有实现BeanDefinitionRegistryPostProcessor接口的bean的name</span><br>postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-comment">// 跳过已经执行过的</span><br><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;<br><span class="hljs-comment">// 获取名字对应的bean实例，添加到currentRegistryProcessors中</span><br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br><span class="hljs-comment">// 将要被执行的BFPP名称添加到processedBeans中，避免后续重复执行</span><br>processedBeans.add(ppName);<br><span class="hljs-comment">// 这里为true的原因是：</span><br><span class="hljs-comment">// 如果还有未处理的，下面会进行处理逻辑，在执行过程中很可能会再产生BeanDefinitionRegistryPostProcessor</span><br>reiterate = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 按照优先级进行排序操作</span><br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br><span class="hljs-comment">// 添加到registryProcessors中，用于最后执行postProcessBeanFactory方法</span><br>registryProcessors.addAll(currentRegistryProcessors);<br><span class="hljs-comment">// 遍历currentRegistryProcessors，执行postProcessBeanDefinitionRegistry方法</span><br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br><span class="hljs-comment">// 执行完毕后清空currentRegistryProcessors</span><br>currentRegistryProcessors.clear();<br>&#125;<br><br><span class="hljs-comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="hljs-comment">// 调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法</span><br><span class="hljs-comment">// 因为实现了BeanDefinitionRegistryPostProcessor接口一定也实现了BeanFactoryPostProcessor接口</span><br>invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);<br><span class="hljs-comment">// 调用入参beanFactoryPostProcessors中所有普通BeanFactoryPostProcessor的postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);<br>&#125;<br><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Invoke factory processors registered with the context instance.</span><br><span class="hljs-comment">// 如果beanFactory不属于BeanDefinitionRegistry类型，直接执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);<br>&#125;<br><br><span class="hljs-comment">// 到此为止，入参beanFactoryPostProcessors和容器中所有的BeanDefinitionRegistryPostProcessors已经全部处理完毕，</span><br><span class="hljs-comment">// 下面开始处理容器中通过@Component注解提供的BeanFactoryPostProcessor，而不是ac.addBeanFactoryPostProcessor提供的</span><br><span class="hljs-comment">// 上面执行的，仅仅是程序员通过add到spring容器中的beanFactoryPostProcessor</span><br><br><span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="hljs-comment">// 找到所有实现BeanFactoryPostProcessor的类</span><br>String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="hljs-comment">// Ordered, and the rest.</span><br><span class="hljs-comment">// 用于存放实现了PriorityOrdered接口BeanFactoryPostProcessor</span><br>List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 用于存放实现了Ordered接口BeanFactoryPostProcessor的name</span><br>List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 用于存放普通BeanFactoryPostProcessor的name</span><br>List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 遍历postProcessorNames，将实现的PriorityOrdered接口、rdered接口、普通三种区别开</span><br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;<br><span class="hljs-comment">// skip - already processed in first phase above</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>orderedPostProcessorNames.add(ppName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>nonOrderedPostProcessorNames.add(ppName);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="hljs-comment">// 对实现PriorityOrdered接口的BeanFactoryPostProcessor进行排序</span><br>sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><span class="hljs-comment">// 遍历实现PriorityOrdered接口的BeanFactoryPostProcessor，执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="hljs-comment">// 创建存放Ordered接口的集合</span><br>List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;<br><span class="hljs-comment">// 将实现Ordered接口的BeanFactoryPostProcessor添加到集合中</span><br>orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>&#125;<br><span class="hljs-comment">// 对实现Ordered接口的BeanFactoryPostProcessor进行排序</span><br>sortPostProcessors(orderedPostProcessors, beanFactory);<br><span class="hljs-comment">// 遍历实现Ordered接口的BeanFactoryPostProcessor，执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="hljs-comment">// 创建存放普通对象的集合</span><br>List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;<br><span class="hljs-comment">// 将普通的BeanFactoryPostProcessor添加到集合中</span><br>nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>&#125;<br><span class="hljs-comment">// 遍历普通的BeanFactoryPostProcessor，执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span><br><span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="hljs-comment">// 清除元数据缓存（mergeBeanDefinitions、allBeanNamesByType、singletonBeanNameByType）</span><br><span class="hljs-comment">// 因为后置处理器可能已经修改了原始数据，比如：替换值中的占位符</span><br>beanFactory.clearMetadataCache();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-095-最长公共子序列"><a href="#剑指-Offer-II-095-最长公共子序列" class="headerlink" title="剑指 Offer II 095. 最长公共子序列"></a>剑指 Offer II 095. 最长公共子序列</h2><blockquote><p><a href="https://leetcode.cn/problems/qJnOS7/">https://leetcode.cn/problems/qJnOS7/</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：动态规划"><a href="#题解：动态规划" class="headerlink" title="题解：动态规划"></a>题解：动态规划</h4><p>状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;text1[i-<span class="hljs-number">1</span>]==text2[j-<span class="hljs-number">1</span>]<br>dp[i][j] = Max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);text1[i-<span class="hljs-number">1</span>]!=text2[j-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>最终计算得到<code>dp[len1][len2]</code>就是text1和text2的最长公共子序列长度。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162000920.png" alt="image-20230716200028347"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> text1.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> text2.length();<br>    <span class="hljs-comment">// 定义dp数组： 这里特殊处理，由于后面需要判断i-1和j-1，所以dp[0][0]、dp[0][j]、dp[i][0]需要预留，防止为空</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-099-最小路径之和"><a href="#剑指-Offer-II-099-最小路径之和" class="headerlink" title="剑指 Offer II 099. 最小路径之和"></a>剑指 Offer II 099. 最小路径之和</h2><blockquote><p><a href="https://leetcode.cn/problems/0i0mDW/description/">https://leetcode.cn/problems/0i0mDW/description/</a></p><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>一个机器人每次只能向下或者向右移动一步。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162022825.png" alt="image-20230716202256838"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维数组dp"><a href="#题解：二维数组dp" class="headerlink" title="题解：二维数组dp"></a>题解：二维数组dp</h4><p>动态转移方程：<code>dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-keyword">if</span> (grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][col];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 第一行特殊处理，直接在前一列基础上累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>    &#125;<br>    <span class="hljs-comment">// 第一列特殊处理，直接在前一行基础上累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// 其他情况去上下相邻的最小值累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>            dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维数组dp"><a href="#题解：一维数组dp" class="headerlink" title="题解：一维数组dp"></a>题解：一维数组dp</h4><p>优化空间的思路见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-keyword">if</span> (grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[col];<br>    dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 第一行特殊处理，直接在前一列基础上累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>        dp[j] = dp[j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>    &#125;<br>    <span class="hljs-comment">// 其他情况去上下相邻的最小值累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i ++) &#123;<br>        <span class="hljs-comment">// 遍历到第0列时，其实原二维第[i-1][0]位置记录已经无效了，可以压缩到dp[0]转为1维数组</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 例如：</span><br><span class="hljs-comment">             *  1 3 1</span><br><span class="hljs-comment">             *  1 5 1</span><br><span class="hljs-comment">             *  4 2 1</span><br><span class="hljs-comment">             *  i = 0时, dp为：1 3 1</span><br><span class="hljs-comment">             *  i = 1时, dp[0]为 1+1=2，此时dp数组为：2 3 1</span><br><span class="hljs-comment">             *  接上一步j = 1时，dp[1] = min(dp[0], dp[1]) + grid[1][1]</span><br><span class="hljs-comment">             *  实则还是dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="hljs-comment">             *  只是dp[0][0]处元素在i=1和j=1时没用，将dp[1][0]滚动到dp[0][0]而已，就优化成一维数组</span><br><span class="hljs-comment">             */</span><br>        dp[<span class="hljs-number">0</span>] += grid[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>            dp[j] = Math.min(dp[j - <span class="hljs-number">1</span>], dp[j]) + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[col - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-089-房屋偷盗"><a href="#剑指-Offer-II-089-房屋偷盗" class="headerlink" title="剑指 Offer II 089. 房屋偷盗"></a>剑指 Offer II 089. 房屋偷盗</h2><blockquote><p><a href="https://leetcode.cn/problems/Gu0c2T/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/Gu0c2T/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：数组dp"><a href="#题解：数组dp" class="headerlink" title="题解：数组dp"></a>题解：数组dp</h4><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 <code>k (k&gt;2) </code>间房屋，有两个选项：</p><ul><li><p>偷窃第 k 间房屋，那么就不能偷窃第 <code>k−1</code>间房屋，偷窃总金额为前 <code>k−2</code> 间房屋的最高总金额与第 k间房屋的金额之和。</p></li><li><p>不偷窃第 k 间房屋，偷窃总金额为前 <code>k−1</code> 间房屋的最高总金额。</p></li></ul><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前k 间房屋能偷窃到的最高总金额。</p><p>用<code>dp[i]</code> 表示前 <code>i</code>间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><p><code>dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);</code></p><p>边界条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">// 只有一间房屋，则偷窃该房屋</span><br>dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 只有两间房屋，选择其中金额较高的房屋进行偷窃</span><br></code></pre></td></tr></table></figure><p>最终的答案即为<code>dp[len - 1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果房间梳理大于两间，有两个选项：</span><br><span class="hljs-comment"> * 1. 偷窃第k个房屋，就不能偷第k-1个房屋，偷窃总额为前k-2个房屋最高总额与第k间房屋的金额之和</span><br><span class="hljs-comment"> * 2. 不偷窃第k个房屋，偷窃总金额为前k-1间房屋最高总金额</span><br><span class="hljs-comment"> * dp[i]表示前i间房屋能偷窃的最大金额，状态转移方程如下：</span><br><span class="hljs-comment"> * dp[i] = Max(dp[i - 2] + nums[i], dp[i - 1])</span><br><span class="hljs-comment"> * 边界条件：</span><br><span class="hljs-comment"> * dp[0] = nums[0] 只有一间房屋</span><br><span class="hljs-comment"> * dp[1] = max(nums[0], nums[1]) 只有两间房屋</span><br><span class="hljs-comment"> * 最后结果：dp[nums.length - 1]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 对每个房间都有偷与不偷两种选择</span><br>        <span class="hljs-comment">// 假如偷：则上一个房间被偷的只能是i-2，加上本间房金额为：dp[i-2]+nums[i]</span><br>        <span class="hljs-comment">// 加入不偷：则上一次被偷的房间是i-1，当前房间由于不被偷，总价值还是dp[i-1]</span><br>        <span class="hljs-comment">// 两则去最大值</span><br>        dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：滚动数组"><a href="#题解：滚动数组" class="headerlink" title="题解：滚动数组"></a>题解：滚动数组</h4><p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], second = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> second;<br>            second = Math.max(first + nums[i], second);<br>            first = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-090-环形房屋偷盗"><a href="#剑指-Offer-II-090-环形房屋偷盗" class="headerlink" title="剑指 Offer II 090. 环形房屋偷盗"></a>剑指 Offer II 090. 环形房屋偷盗</h2><blockquote><p><a href="https://leetcode.cn/problems/PzWKhm/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/PzWKhm/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：分两段dp"><a href="#题解：分两段dp" class="headerlink" title="题解：分两段dp"></a>题解：分两段dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 由于相邻房屋不能偷窃，又由于房屋是环形的，所以有以下规则</span><br><span class="hljs-comment"> * 1. 偷窃了第一间房屋则不能偷窃最后一间，此时偷窃的房屋范围是[0, length - 2]</span><br><span class="hljs-comment"> * 2. 偷窃了最后一间房屋则不能偷窃第一间，此时偷窃的房屋范围是[1, length - 1]</span><br><span class="hljs-comment"> * 所以，分别寻找上面两个范围的偷窃最大值，然后再取两个范围最大值即为结果</span><br><span class="hljs-comment"> * 寻找单个区间范围最大值思路和房屋偷盗思路一样，只不过不用数据，而是用变量来记录最大值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>     &#125;<br>     <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>) &#123;<br>         <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>     &#125;<br>     <span class="hljs-keyword">return</span> Math.max(robDp(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>), robDp(nums, <span class="hljs-number">1</span>, nums.length));<br> &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> Math.max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 假设nums如下： 1     2    3     3  4</span><br><span class="hljs-comment">         *              fir  sec   i</span><br><span class="hljs-comment">         *              每次second和nums[i]+first</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">2</span>; i &lt; end; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> second;<br>        second = Math.max(nums[i] + first, second);<br>        first = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> second;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-091-粉刷房子"><a href="#剑指-Offer-II-091-粉刷房子" class="headerlink" title="剑指 Offer II 091. 粉刷房子"></a>剑指 Offer II 091. 粉刷房子</h2><blockquote><p><a href="https://leetcode.cn/problems/JEj789/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/JEj789/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>假如有一排房子，共 <code>n</code> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 <code>n x 3</code> 的正整数矩阵 <code>costs</code> 来表示的。</p><p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成绿色的花费，以此类推。</p><p>请计算出粉刷完所有房子最少的花费成本。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: costs = <span class="hljs-string">[[17,2,17],[16,16,5],[14,3,19]]</span><br>输出: <span class="hljs-number">10</span><br>解释: 将 <span class="hljs-number">0</span> 号房子粉刷成蓝色，<span class="hljs-number">1</span> 号房子粉刷成绿色，<span class="hljs-number">2</span> 号房子粉刷成蓝色。<br>     最少花费: <span class="hljs-number">2</span> + <span class="hljs-number">5</span> + <span class="hljs-number">3</span> = <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维数组dp-1"><a href="#题解：二维数组dp-1" class="headerlink" title="题解：二维数组dp"></a>题解：二维数组dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] costs)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> costs.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][<span class="hljs-number">3</span>];<br>    System.arraycopy(costs[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) + costs[i][<span class="hljs-number">0</span>];<br>        dp[i][<span class="hljs-number">1</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) + costs[i][<span class="hljs-number">1</span>];<br>        dp[i][<span class="hljs-number">2</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) + costs[i][<span class="hljs-number">2</span>];<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> Arrays.stream(dp[row - <span class="hljs-number">1</span>]).min().getAsInt();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维dp"><a href="#题解：一维dp" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostV2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] costs)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> costs.length;<br>    <span class="hljs-comment">// 二维dp数组简化为一维</span><br>    <span class="hljs-comment">// 因为dp数组只需要记录前面一间房最小花费即可</span><br>    <span class="hljs-comment">// dp数组含义：刷到当前房间时每种颜色的最小花费</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>    System.arraycopy(costs[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, dp, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 从第2行开始计算，因为第1间房最小花费不用计算</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-comment">// 因为dp数组在为每一间房赋值过程中不能变化，所以需要有一个临时数组</span><br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-comment">// 这里巧妙的使用(j + 1) % 3和(j + 2) % 3来使相邻房间颜色不重复</span><br>            <span class="hljs-comment">// 只需要去前面一间房最小费用当前房间颜色花费保存即可</span><br>            tmp[j] = Math.min(dp[(j + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], dp[(j + <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>]) + costs[i][j];<br>        &#125;<br>        dp = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Arrays.stream(dp).min().getAsInt();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-092-翻转字符"><a href="#剑指-Offer-II-092-翻转字符" class="headerlink" title="剑指 Offer II 092. 翻转字符"></a>剑指 Offer II 092. 翻转字符</h2><blockquote><p><a href="https://leetcode.cn/problems/cyJERH/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/cyJERH/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>如果一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串，是以一些 <code>&#39;0&#39;</code>（可能没有 <code>&#39;0&#39;</code>）后面跟着一些 <code>&#39;1&#39;</code>（也可能没有 <code>&#39;1&#39;</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p><p>我们给出一个由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串 s，我们可以将任何 <code>&#39;0&#39;</code> 翻转为 <code>&#39;1&#39;</code> 或者将 <code>&#39;1&#39;</code> 翻转为 <code>&#39;0&#39;</code>。</p><p>返回使 s <strong>单调递增</strong> 的最小翻转次数。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00110&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：我们翻转最后一位得到 <span class="hljs-number">00111</span>.<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：dp"><a href="#题解：dp" class="headerlink" title="题解：dp"></a>题解：dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// dp0表示遍历到第i个元素如果是0最小翻转次数</span><br>    <span class="hljs-comment">// dp1表示遍历到第i个元素如果是1最小翻转次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, dp1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) &#123;<br>        <span class="hljs-comment">// 遍历到第i个元素时如果取1，则i-1个元素可以是1，也可以是0，所以需要取两者最小值</span><br>        dp1 = Math.min(dp1, dp0) + (ch == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        dp0 += (ch == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.min(dp0, dp1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-093-最长斐波那契数列"><a href="#剑指-Offer-II-093-最长斐波那契数列" class="headerlink" title="剑指 Offer II 093. 最长斐波那契数列"></a>剑指 Offer II 093. 最长斐波那契数列</h2><blockquote><p><a href="https://leetcode.cn/problems/Q91FMA/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/Q91FMA/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p><ul><li><code>n &gt;= 3</code></li><li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_&#123;i+1&#125; = X_&#123;i+2&#125;</code></li></ul><p>给定一个<strong>严格递增</strong>的正整数数组形成序列 <code>arr</code> ，找到 <code>arr</code> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p><p><em>（回想一下，子序列是从原序列 <code>arr</code> 中派生出来的，它从 <code>arr</code> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: arr = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>]<br>输出: <span class="hljs-number">5</span><br>解释: 最长的斐波那契式子序列为 [<span class="hljs-number">1,2,3,5</span>,<span class="hljs-number">8</span>] 。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp"><a href="#题解：二维dp" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-comment">// 由于arr是递增有序的，所以判断下标即可判断arr中是否有该值</span><br>    Map&lt;Integer, Integer&gt; indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        indexMap.put(arr[i], i);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历arr数组，以每个arr[i]作为第3个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 遍历arr[0, i)的元素，作为第2个元素</span><br>        <span class="hljs-comment">// 这里为了少遍历，增加了一个条件arr[j] * 2 &gt; arr[i]</span><br>        <span class="hljs-comment">// 原因：假设第一个元素为arr[index], 则有arr[index]+arr[j]=arr[i]，同时index&lt;j&lt;i并且arr[index]&lt;arr[j]&lt;arr[i]</span><br>        <span class="hljs-comment">// 所以欲满足arr[index]+arr[j]=arr[i]，必有arr[j]+arr[j]&gt;arr[i]，这样可以省去遍历很多元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] * <span class="hljs-number">2</span> &gt; arr[i]; j--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> indexMap.getOrDefault(arr[i] - arr[j], -<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 如果存在第一个值，则说明找到一个序列index, j, i可以组成斐波那契数列</span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果index, j之前就是斐波那数列，则第i个元素也满足就相当于在之前数列上延续，直接+1</span><br>                <span class="hljs-comment">// 否则找到一个序列就是长度为3，比如一开始的1,2,3</span><br>                dp[j][i] = Math.max(dp[index][j] + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>            &#125;<br>            ans = Math.max(ans, dp[j][i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-096-字符串交织"><a href="#剑指-Offer-II-096-字符串交织" class="headerlink" title="剑指 Offer II 096. 字符串交织"></a>剑指 Offer II 096. 字符串交织</h2><blockquote><p><a href="https://leetcode.cn/problems/IY6buf/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/IY6buf/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请判断 <code>s3</code> 能不能由 <code>s1</code> 和 <code>s2</code> <strong>交织（交错）</strong> 组成。</p><p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交织</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p><ul><li><code>s = s1 + s2 + ... + sn</code></li><li><code>t = t1 + t2 + ... + tm</code></li><li><code>|n - m| &lt;= 1</code></li><li><strong>交织</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li></ul><p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbcbcac&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-1"><a href="#题解：二维dp-1" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> s2.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len3</span> <span class="hljs-operator">=</span> s3.length();<br>    <span class="hljs-keyword">if</span> (len1 + len2 != len3) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// dp[i][j]含义：s1的前i个字符和s2的前j个字符是否能交织成s3前i+j-1个字符</span><br>    <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 设置初始值，因为s1[0],s2[0]不一定能组成s3[0]，所以下面遍历从下标1开始</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 矩阵按行从左到右更新，每次更新仅需本行当前更新元素的前一个元素及前一行的同列元素</span><br>            <span class="hljs-comment">// 即每次更新只需要矩阵左侧和上侧元素，所以可以转为一维数组</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 这里需要判断s1是否满足, 所以要或一下dp[i][j]，表示s1或s2有一个满足条件即可</span><br>                dp[i][j] = dp[i][j] || dp[i][j - <span class="hljs-number">1</span>] &amp;&amp; s2.charAt(j - <span class="hljs-number">1</span>) == s3.charAt(k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维dp-1"><a href="#题解：一维dp-1" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> s2.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len3</span> <span class="hljs-operator">=</span> s3.length();<br>    <span class="hljs-keyword">if</span> (len1 + len2 != len3) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len2 + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] = dp[j] &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] = dp[j] || (dp[j - <span class="hljs-number">1</span>] &amp;&amp; s2.charAt(j - <span class="hljs-number">1</span>) == s3.charAt(k));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len2];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-098-路径的数目"><a href="#剑指-Offer-II-098-路径的数目" class="headerlink" title="剑指 Offer II 098. 路径的数目"></a>剑指 Offer II 098. 路径的数目</h2><blockquote><p><a href="https://leetcode.cn/problems/2AoeFn/description/">https://leetcode.cn/problems/2AoeFn/description/</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162038839.png" alt="image-20230716203818229"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-2"><a href="#题解：二维dp-2" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 第一行和第一列默认为1</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; j != <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维dp-2"><a href="#题解：一维dp-2" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[j] += dp[j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-100-三角形中最小路径之和"><a href="#剑指-Offer-II-100-三角形中最小路径之和" class="headerlink" title="剑指 Offer II 100. 三角形中最小路径之和"></a>剑指 Offer II 100. 三角形中最小路径之和</h2><blockquote><p><a href="https://leetcode.cn/problems/IlPe0q/description/">https://leetcode.cn/problems/IlPe0q/description/</a></p><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-3"><a href="#题解：二维dp-3" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三角形数组</span><br><span class="hljs-comment"> * 2    0   0   0</span><br><span class="hljs-comment"> * 3    4   0   0</span><br><span class="hljs-comment"> * 6    5   7   0</span><br><span class="hljs-comment"> * 4    1   8   3</span><br><span class="hljs-comment"> * 构造一个dp数组，长宽和上面一致</span><br><span class="hljs-comment"> * 设置dp[0][0] = t[0][0]，因为是起点</span><br><span class="hljs-comment"> * dp状态转移方程分下面几个情况：</span><br><span class="hljs-comment"> * 1. 如果是第一列，则dp[i][0] = dp[i - 1][0] + t[i][0]，因为第一列只能通过上一层来改变</span><br><span class="hljs-comment"> * 2. 如果是对角线，则dp[i][i] = dp[i-1][j-1] + t[i][i]，因为对角线状态的更改只能通过[i-1][j-1]处来改变</span><br><span class="hljs-comment"> * 3. 其他情况：dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + t[i][j];</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.get(m - <span class="hljs-number">1</span>).size();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 第一列特殊处理</span><br>                dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + triangle.get(i).get(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 其他情况取最小值</span><br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 对角线状态的更改只能通过[i-1][j-1]处来改变特殊处理</span><br>        dp[i][i] = dp[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + triangle.get(i).get(i);<br>    &#125;<br>    <span class="hljs-comment">// 寻找最后一行最小值即可</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        ans = Math.min(ans, dp[m - <span class="hljs-number">1</span>][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-101-分割等和子集"><a href="#剑指-Offer-II-101-分割等和子集" class="headerlink" title="剑指 Offer II 101. 分割等和子集"></a>剑指 Offer II 101. 分割等和子集</h2><blockquote><p><a href="https://leetcode.cn/problems/NUPfPr/description/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/NUPfPr/description/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定一个非空的正整数数组 <code>nums</code> ，请判断能否将这些数字分成元素和相等的两部分。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：nums 可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> 。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：0-1背包问题"><a href="#题解：0-1背包问题" class="headerlink" title="题解：0-1背包问题"></a>题解：0-1背包问题</h4><p>题目可以转换为：从数组Nums中寻找元素能装满sum(nums)&#x2F;2容量的背包。</p><p>前面有些细节条件可以去掉很多测试用例：</p><ol><li>数组元素之和不能被2整除</li><li>数组中最大值比所有元素之和一半还大</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        maxNum = Math.max(maxNum, num);<br>    &#125;<br>    <span class="hljs-comment">// 数组元素相加和不能被2整除，说明不能分为两个相等的部分</span><br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 如果最大值比总和一半还大，也不n呢个分为两个相等的部分</span><br>    <span class="hljs-keyword">if</span> (maxNum &gt; target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义数组，使用0-1背包来解决此问题</span><br>    <span class="hljs-comment">// 问题转化为在数组中能否选取合适元素，使得和为target</span><br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= num; j--) &#123;<br>            <span class="hljs-comment">// 当前容量状态取决于不装num和装num，不装num是dp[j]，装num是dp[j-num]</span><br>            dp[j] |= dp[j - num];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-102-加减的目标值"><a href="#剑指-Offer-II-102-加减的目标值" class="headerlink" title="剑指 Offer II 102. 加减的目标值"></a>剑指 Offer II 102. 加减的目标值</h2><blockquote><p><a href="https://leetcode.cn/problems/YaVDxD/description/">https://leetcode.cn/problems/YaVDxD/description/</a></p><p>给定一个正整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：0-1背包问题-1"><a href="#题解：0-1背包问题-1" class="headerlink" title="题解：0-1背包问题"></a>题解：0-1背包问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 问题可以转化为0-1背包问题：</span><br><span class="hljs-comment"> * 对数组[1,1,1,1,1]</span><br><span class="hljs-comment"> * 设添加+号的元素之和为pos，添加-号的元素之和为neg</span><br><span class="hljs-comment"> * 则有：pos + neg = sum, pos - neg = target</span><br><span class="hljs-comment"> * 组合方程得到：pos = (sum + target) / 2,  neg = (sum - target) / 2</span><br><span class="hljs-comment"> * 所以上面问题化为：给定一个背包neg，从数组中找到一些数字（每个数字可以选一次），使得选出的数字和刚好等于pos或者neg。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-comment">// 去掉特殊情况</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> sum - target;<br>    <span class="hljs-keyword">if</span> (sum &lt; target || diff % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算背包容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">neg</span> <span class="hljs-operator">=</span> diff / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 0-1 背包</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[neg + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 背包容量为0时，可以选择不选任何数，所以有一种方案</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> neg; j &gt;= num; j--) &#123;<br>            <span class="hljs-comment">// dp[j]表示容量为j时刚好装满的方案数</span><br>            dp[j] += dp[j - num];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[neg];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-103-最少的硬币数目"><a href="#剑指-Offer-II-103-最少的硬币数目" class="headerlink" title="剑指 Offer II 103. 最少的硬币数目"></a>剑指 Offer II 103. 最少的硬币数目</h2><blockquote><p><a href="https://leetcode.cn/problems/gaM7Ch/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/gaM7Ch/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>+ 1<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一维dp-3"><a href="#题解：一维dp-3" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// dp[i]表示装满容量i需要的最少硬币数目</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 容量最大为amount，假设硬币有1，则需要的最多的硬币数据为amount，这里初始化数组为最大值（表示每个容量默认都不可能装满）</span><br>    Arrays.fill(dp, amount + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 容量为0不需要装</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 针对每个容量，使用不同币种去填充，然后不同币种取最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= amount; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>            <span class="hljs-comment">// 如果该coin小于本次要装的背包容量</span><br>            <span class="hljs-keyword">if</span> (coin &lt;= i) &#123;<br>                <span class="hljs-comment">// 因为有多个币种，所以取最小的那个币种的方案</span><br>                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? -<span class="hljs-number">1</span> : dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-104-排列的数目"><a href="#剑指-Offer-II-104-排列的数目" class="headerlink" title="剑指 Offer II 104. 排列的数目"></a>剑指 Offer II 104. 排列的数目</h2><blockquote><p><a href="https://leetcode.cn/problems/D0F0SV/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/D0F0SV/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定一个由 <strong>不同</strong> 正整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p><p>题目数据保证答案符合 32 位整数范围。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一维dp-4"><a href="#题解：一维dp-4" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><p>用 <code>dp[x] </code>表示选取的元素之和等于 x 的方案数，目标是求 <code>dp[target]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= target; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &lt;= i) &#123;<br>                dp[i] += dp[i - num];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2770-达到末尾下标所需的最大跳跃次数"><a href="#2770-达到末尾下标所需的最大跳跃次数" class="headerlink" title="2770. 达到末尾下标所需的最大跳跃次数"></a>2770. 达到末尾下标所需的最大跳跃次数</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/description/">https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/description/</a></p><p>给你一个下标从 <strong>0</strong> 开始、由 <code>n</code> 个整数组成的数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>你的初始位置在下标 <code>0</code> 。在一步操作中，你可以从下标 <code>i</code> 跳跃到任意满足下述条件的下标 <code>j</code> ：</p><ul><li><code>0 &lt;= i &lt; j &lt; n</code></li><li><code>-target &lt;= nums[j] - nums[i] &lt;= target</code></li></ul><p>返回到达下标 <code>n - 1</code> 处所需的 <strong>最大跳跃次数</strong> 。</p><p>如果无法到达下标 <code>n - 1</code> ，返回 <code>-1</code> 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,3,6,4,1,2], target = 2<br>输出：3<br>解释：要想以最大跳跃次数从下标<span class="hljs-number"> 0 </span>到下标 n -<span class="hljs-number"> 1 </span>，可以按下述跳跃序列执行操作：<br>- 从下标<span class="hljs-number"> 0 </span>跳跃到下标<span class="hljs-number"> 1 </span>。 <br>- 从下标<span class="hljs-number"> 1 </span>跳跃到下标<span class="hljs-number"> 3 </span>。 <br>- 从下标<span class="hljs-number"> 3 </span>跳跃到下标<span class="hljs-number"> 5 </span>。 <br>可以证明，从<span class="hljs-number"> 0 </span>到 n -<span class="hljs-number"> 1 </span>的所有方案中，不存在比<span class="hljs-number"> 3 </span>步更长的跳跃序列。因此，答案是<span class="hljs-number"> 3 </span>。 <br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一维dp-5"><a href="#题解：一维dp-5" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><p>定义<code>dp[i]</code>表示跳跃到i位置时最大跳跃次数。</p><p> 对于位置<code>nums[i]</code>来说，必然从<code>[0, i-1]</code>中某个位置跳转得来，即<code>dp[i] = dp[j] + 1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumJumps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    <span class="hljs-comment">// 初始值每个位置设为不可达，即-1</span><br>    Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 位置0时最大跳跃数为0</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-comment">// 如果符合条件，并且j位置可达，说明i位置可以从j跳跃而来 dp[i] = dp[j] + 1</span><br>            <span class="hljs-comment">// 由于要取最大跳跃数，所以要取最大值</span><br>            <span class="hljs-keyword">if</span> (Math.abs(nums[i] - nums[j]) &lt;= target &amp;&amp; dp[j] != -<span class="hljs-number">1</span>) &#123;<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931. 下降路径最小和"></a>931. 下降路径最小和</h2><blockquote><p><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">https://leetcode.cn/problems/minimum-falling-path-sum/</a></p><p>给你一个 <code>n x n</code> 的 <strong>方形</strong> 整数数组 <code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong> 的 <strong>最小和</strong> 。</p><p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162107722.png" alt="image-20230716210708184" style="zoom:50%;" /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[2,1,3],[6,5,4],[7,8,9]]</span><br>输出：<span class="hljs-number">13</span><br>解释：如图所示，为和最小的两条下降路径<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-4"><a href="#题解：二维dp-4" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><p>给你一个<code> n x n</code> 的方形 整数数组 <code>matrix </code>，请你找出并返回通过 <code>matrix </code>的下降路径 的 最小和 。</p><p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。</p><p>在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。</p><p>具体来说，位置 <code>(row, col)</code> 的下一个元素应当是<code> (row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者<code> (row + 1, col + 1)</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= row; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = Integer.MAX_VALUE;<br>    &#125;<br><br>    Arrays.fill(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= col; j++) &#123;<br>            dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], j + <span class="hljs-number">1</span> &lt;= col ? dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] : Integer.MAX_VALUE))<br>                + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= col; i++) &#123;<br>        ans = Math.min(dp[row][i], ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-075-数组相对排序"><a href="#剑指-Offer-II-075-数组相对排序" class="headerlink" title="剑指 Offer II 075. 数组相对排序"></a>剑指 Offer II 075. 数组相对排序</h2><blockquote><p><a href="https://leetcode.cn/problems/0H97ZC/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/0H97ZC/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定两个数组，<code>arr1</code> 和 <code>arr2</code>，</p><ul><li><code>arr2</code> 中的元素各不相同</li><li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li></ul><p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr1 = [<span class="hljs-number">2,3,1,3</span>,<span class="hljs-number">2,4,6,7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">19</span>], arr2 = [<span class="hljs-number">2,1,4,3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">2,2,2,1</span>,<span class="hljs-number">4,3,3,9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：计数排序"><a href="#题解：计数排序" class="headerlink" title="题解：计数排序"></a>题解：计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] relativeSortArray(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>    <span class="hljs-comment">// 为节省空间，可以先算出数组中最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr1) &#123;<br>        max = Math.max(v, max);<br>    &#125;<br>    <span class="hljs-comment">// 初始化max+1空间数组</span><br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 统计arr1中每个数字出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr1) &#123;<br>        count[v]++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr1.length];<br>    <span class="hljs-comment">// 此时以arr2数组中的顺序为主（计数排序是以统计次数的数组下标来遍历，因为下标是有序的）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr2) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count[v]; i++) &#123;<br>            res[index++] = v;<br>        &#125;<br>        <span class="hljs-comment">// 每个数填完后次数归0</span><br>        count[v] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后遍历计数数组，按照下标遍历，因为这样arr1中剩下数组就会按照有序排列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= max; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; count[i]; j++) &#123;<br>            res[index++] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql的limit原理及分页查询优化</title>
    <link href="/MySQL/LIMIT%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/"/>
    <url>/MySQL/LIMIT%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在进行分页查询的时候，通常会使用LIMIT加偏移量的办法实现，但当偏移量非常大的时候，例如：LIMIT 10000， 20这样的查询，这是MySQL需要查询10020条记录然后只返回20条，前面的10000条都将会抛弃。这样的代价就非常高。</p></blockquote><p>优化上述查询，有两种方案供选择：</p><ul><li>在页面中限制分页的数量</li><li>优化大偏移量的性能</li></ul><p><strong>使用索引覆盖扫描，不查询所有的列，然后根据需要进行一次关联，再返回所需的列</strong></p><p>例如下面查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5;<br></code></pre></td></tr></table></figure><p>当偏移量很大的时候，可以改成下面查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film.film_id, film.description FROM sakila.film INNER JOIN (<br>SELECT film_id FROM sakila.film ORDER BY title LIMIT 50, 5<br>) AS lim USING(film_id);<br></code></pre></td></tr></table></figure><p>这里先获取需要访问的记录，然后再根据关联列回原表查询所需要的列。</p><hr><p><strong>将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得到对应的结果</strong></p><p>可以根据索引列，预先计算边界值，上面查询可以修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film_id, description FROM sakila.film<br>WHERE position BETWEEN 50 AND 54 ORDER BY position;<br></code></pre></td></tr></table></figure><hr><blockquote><p>LIMIT和OFFSET的问题，实际上是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。</p></blockquote><p><strong>可以使用标记记录上次读取数据的位置，下次就可以直接从该标记的位置开始扫描，这样可以避免OFFSET</strong></p><p>假设使用下面查询获取第一条结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM sakila.rental<br>ORDER BY rental_id DESC LIMIT 20;<br></code></pre></td></tr></table></figure><p>假设上面查询的是主键16049到16030的租界记录，下一页查询就可以从16030这个点开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM sakila.rental<br>WHERE rental_id &lt; 16030<br>ORDER BY rental_id DESC LIMIT 2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel限流原理</title>
    <link href="/Sentinel/Sentinel%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86/"/>
    <url>/Sentinel/Sentinel%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="SphU-entry-入口"><a href="#SphU-entry-入口" class="headerlink" title="SphU.entry 入口"></a>SphU.entry 入口</h2><p>从<code>SphU.entry()</code>方法向下执行，会进入到下面这个方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">entryWithPriority</span><span class="hljs-params">(ResourceWrapper resourceWrapper, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>       <span class="hljs-keyword">throws</span> BlockException &#123;<br>       <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> ContextUtil.getContext();<br>       <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> NullContext) &#123;<br>           <span class="hljs-comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span><br>           <span class="hljs-comment">// so here init the entry only. No rule checking will be done.</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// Using default context.</span><br>           context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);<br>       &#125;<br><br>       <span class="hljs-comment">// Global switch is close, no rule checking will do.</span><br>       <span class="hljs-comment">// 1. 全局开关关闭，说明没有规则检查，直接返回一个CtEntry对象，不再进行后续的限流检测</span><br>       <span class="hljs-keyword">if</span> (!Constants.ON) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-comment">// 2. 根据包装过的资源获取对应的SlotChain</span><br>       ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;,</span><br><span class="hljs-comment">        * so no rule checking will be done.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, chain, context, count, args);<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 3. 执行SlotChain的entry方法，如果SlotChain的entry方法抛出了BlockException，则将该异常继续向上抛出，如果SlotChain的entry方法正常执行了，则最后会将该entry对象返回</span><br>           chain.entry(context, resourceWrapper, <span class="hljs-literal">null</span>, count, prioritized, args);<br>       &#125; <span class="hljs-keyword">catch</span> (BlockException e1) &#123;<br>           e.exit(count, args);<br>           <span class="hljs-comment">// 4. 如果上层方法捕获了BlockException，则说明请求被限流了，否则请求能正常执行</span><br>           <span class="hljs-keyword">throw</span> e1;<br>       &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br>           <span class="hljs-comment">// This should not happen, unless there are errors existing in Sentinel internal.</span><br>           RecordLog.info(<span class="hljs-string">&quot;Sentinel unexpected exception&quot;</span>, e1);<br>       &#125;<br>       <span class="hljs-keyword">return</span> e;<br>   &#125;<br></code></pre></td></tr></table></figure><p>该方法主要实现了下面几点：</p><ol><li>全局开关关闭，说明没有规则检查，直接返回一个 CtEntry 对象，不再进行后续的限流检测。</li><li>根据包装过的资源获取对应的 SlotChain。</li><li>执行 SlotChain 的 entry 方法，如果 SlotChain 的 entry 方法抛出了 BlockException，则将该异常继续向上抛出，如果 SlotChain 的 entry 方法正常执行了，则最后会将该 entry 对象返回。</li><li>如果上层方法捕获了 BlockException，则说明请求被限流了，否则请求能正常执行。</li></ol><h2 id="SlotChain-的链路获取"><a href="#SlotChain-的链路获取" class="headerlink" title="SlotChain 的链路获取"></a>SlotChain 的链路获取</h2><p>重点关注一下<strong>SlotChain</strong>链路的获取逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java">ProcessorSlot&lt;Object&gt; <span class="hljs-title function_">lookProcessChain</span><span class="hljs-params">(ResourceWrapper resourceWrapper)</span> &#123;<br>    <span class="hljs-comment">// 这里使用两次判断为null(双重检查锁或缓存机制)的原因如下：</span><br>    <span class="hljs-comment">// 假设有两个线程A，B同时到达第一个if，都为null，此时A线程进入synchronized</span><br>    <span class="hljs-comment">// 遇到第二个if，当然还是null，A线程就会执行第二个if里面的语句，创建一个chain，然后存到缓存中，退出synchronized</span><br>    <span class="hljs-comment">// B线程进入synchronized，获取chain，但此时缓存命中，就不用再执行第二个if里面的语句了，减少了synchronized锁的时间</span><br>    <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> chainMap.get(resourceWrapper);<br>    <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>            chain = chainMap.get(resourceWrapper);<br>            <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Entry size limit.</span><br>                <span class="hljs-keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br><span class="hljs-comment">// 构造SlotChain</span><br>                chain = SlotChainProvider.newSlotChain();<br><br>               <span class="hljs-comment">// map扩容</span><br>                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;ResourceWrapper, ProcessorSlotChain&gt;(<br>                    chainMap.size() + <span class="hljs-number">1</span>);<br>                newMap.putAll(chainMap);<br>                <span class="hljs-comment">// 将资源和slot-chain映射</span><br>                newMap.put(resourceWrapper, chain);<br>                chainMap = newMap;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> chain;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessorSlotChain <span class="hljs-title function_">newSlotChain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (slotChainBuilder != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> slotChainBuilder.build();<br>    &#125;<br><br>    <span class="hljs-comment">// Resolve the slot chain builder SPI.</span><br>    <span class="hljs-comment">// 从com.alibaba.csp.sentinel.slotchain.ProcessorSlot文件中读取slot构建slot chain</span><br>    slotChainBuilder = SpiLoader.of(SlotChainBuilder.class).loadFirstInstanceOrDefault();<br><br>    <span class="hljs-comment">// 确保slotChainBuilder不为null</span><br>    <span class="hljs-keyword">if</span> (slotChainBuilder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Should not go through here.</span><br>        RecordLog.warn(<span class="hljs-string">&quot;[SlotChainProvider] Wrong state when resolving slot chain builder, using default&quot;</span>);<br>        slotChainBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSlotChainBuilder</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        RecordLog.info(<span class="hljs-string">&quot;[SlotChainProvider] Global slot chain builder resolved: &#123;&#125;&quot;</span>,<br>                       slotChainBuilder.getClass().getCanonicalName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> slotChainBuilder.build();<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSlotChainBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SlotChainBuilder</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ProcessorSlotChain <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultProcessorSlotChain</span>();<br><br>        List&lt;ProcessorSlot&gt; sortedSlotList = SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted();<br>        <span class="hljs-keyword">for</span> (ProcessorSlot slot : sortedSlotList) &#123;<br>            <span class="hljs-keyword">if</span> (!(slot <span class="hljs-keyword">instanceof</span> AbstractLinkedProcessorSlot)) &#123;<br>                RecordLog.warn(<span class="hljs-string">&quot;The ProcessorSlot(&quot;</span> + slot.getClass().getCanonicalName() + <span class="hljs-string">&quot;) is not an instance of AbstractLinkedProcessorSlot, can&#x27;t be added into ProcessorSlotChain&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            chain.addLast((AbstractLinkedProcessorSlot&lt;?&gt;) slot);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> chain;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Sentinel 里面，所有的资源都对应一个资源名称（<code>resourceName</code>），每次资源调用都会创建一个 <code>Entry</code> 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>SphU</code> API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p><ul><li>**<code>NodeSelectorSlot</code>**：收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</li><li><strong><code>ClusterBuilderSlot</code></strong> ：用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><strong><code>StatisticSlot</code></strong> ：用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><strong><code>SystemSlot</code></strong> ：通过系统的状态，来控制总的入口流量；</li><li><strong><code>AuthoritySlot</code></strong> ：根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><strong><code>FlowSlot</code></strong> ：用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><strong><code>DegradeSlot</code></strong> ：通过统计信息以及预设的规则，来做熔断降级；</li></ul><p>下面借用官网的图片：官方链接如下：<a href="https://sentinelguard.io/zh-cn/docs/basic-implementation.html">https://sentinelguard.io/zh-cn/docs/basic-implementation.html</a></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906761.png" alt="image-20220801191458948"></p><p>上面 slot 的排序规则根据下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(sortedClassList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">S</span>&gt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Class&lt;? extends S&gt; o1, Class&lt;? extends S&gt; o2)</span> &#123;<br>        <span class="hljs-type">Spi</span> <span class="hljs-variable">spi1</span> <span class="hljs-operator">=</span> o1.getAnnotation(Spi.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">order1</span> <span class="hljs-operator">=</span> spi1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : spi1.order();<br><br>        <span class="hljs-type">Spi</span> <span class="hljs-variable">spi2</span> <span class="hljs-operator">=</span> o2.getAnnotation(Spi.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> spi2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : spi2.order();<br><br>        <span class="hljs-keyword">return</span> Integer.compare(order1, order2);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>其中<code>spi2.order()</code>是<code>@Spi</code>注解定义的，每个 slot 的顺序如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_NODE_SELECTOR_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_CLUSTER_BUILDER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">9000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_LOG_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_STATISTIC_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">7000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_AUTHORITY_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_SYSTEM_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_FLOW_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEFAULT_CIRCUIT_BREAKER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1500</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEGRADE_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>整个调用链中最核心的就是 **<code>StatisticSlot</code>(<strong>用于记录、统计不同纬度的 runtime 指标监控信息) 以及</strong><code>FlowSlot</code>(**根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制）</p><p>可以查看**<code>DefaultProcessorSlotChain.java</code>**类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultProcessorSlotChain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ProcessorSlotChain</span> &#123;<br><br>    <span class="hljs-comment">// 先创建头结点</span><br>    AbstractLinkedProcessorSlot&lt;?&gt; first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractLinkedProcessorSlot</span>&lt;Object&gt;() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>            <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-built_in">super</span>.fireEntry(context, resourceWrapper, t, count, prioritized, args);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, <span class="hljs-type">int</span> count, Object... args)</span> &#123;<br>            <span class="hljs-built_in">super</span>.fireExit(context, resourceWrapper, count, args);<br>        &#125;<br><br>    &#125;;<br>    <span class="hljs-comment">// 创建尾结点，直接指向头结点</span><br>    AbstractLinkedProcessorSlot&lt;?&gt; end = first;<br>    ....<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出<strong>ProcessorSlotChain</strong>是一个链表，里面有两个<strong>AbstractLinkedProcessorSlot</strong>类型的链表：first 和 end，即链表的头结点和尾结点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906376.png" alt="image-20220801191557361"></p><p>然后添加通过<code>addLast</code>方法添加节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span> &#123;<br>    end.setNext(protocolProcessor);<span class="hljs-comment">// 由于end=first，所以是在first.next下面添加节点</span><br>    end = protocolProcessor;<span class="hljs-comment">// 然后调整end的指针指向新节点</span><br>&#125;<br><br><span class="hljs-comment">// AbstractLinkedProcessorSlot抽象类中的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(AbstractLinkedProcessorSlot&lt;?&gt; next)</span> &#123;<br>    <span class="hljs-built_in">this</span>.next = next;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906704.png" alt="image-20220801191607238"></p><p>然后依次类推，可以得到下面的链路 SlotChain：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906079.png" alt="image-20220801191620840"></p><h2 id="SlotChain-的链路执行"><a href="#SlotChain-的链路执行" class="headerlink" title="SlotChain 的链路执行"></a>SlotChain 的链路执行</h2><p><code>lookProcessChain</code>方法获得的第一个<code>ProcessorSlotChain</code>的实例是<code>DefaultProcessorSlotChain</code>，那么执行 chain.entry 方法，就会执行<code>DefaultProcessorSlotChain</code>的<code>entry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 触发下一个slot</span><br>    first.transformEntry(context, resourceWrapper, t, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着调用父类<code>AbstractLinkedProcessorSlot </code>的<code>transformEntry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 触发下一个节点entry逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireEntry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>        next.transformEntry(context, resourceWrapper, obj, count, prioritized, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transformEntry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object o, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (T)o;<br>    <span class="hljs-comment">// 触发节点entry逻辑</span><br>    entry(context, resourceWrapper, t, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟着代码<code>debug</code>可以知道，上面代码会触发第一个 slot 节点，也就是<code>NodeSelectorSlot</code>。这里先不介绍这个 slot 的具体逻辑。</p><h2 id="Slot-中的-entry-逻辑"><a href="#Slot-中的-entry-逻辑" class="headerlink" title="Slot 中的 entry 逻辑"></a>Slot 中的 entry 逻辑</h2><h3 id="滑动窗口限流原理"><a href="#滑动窗口限流原理" class="headerlink" title="滑动窗口限流原理"></a>滑动窗口限流原理</h3><h4 id="从-StatisticSlot-中的-entry-进入"><a href="#从-StatisticSlot-中的-entry-进入" class="headerlink" title="从 StatisticSlot 中的 entry 进入"></a>从 StatisticSlot 中的 entry 进入</h4><p><code>StaticSlot</code>主要是统计指标数据，用来给<code>FlowSlot</code>进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        Iterator var8;<br>        ProcessorSlotEntryCallback handler;<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// Do some checking.</span><br>            <span class="hljs-comment">// 1. 做一些检查，执行AuthoritySlot、SystemSlot、FlowSlot、DefaultCircuitBreakerSlot方法</span><br>            <span class="hljs-comment">// 如果规则不通过，就会抛出BlockException异常。反之，会在node中统计通过的请求数和线程数等信息。</span><br>            <span class="hljs-built_in">this</span>.fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>            <span class="hljs-comment">// 执行到这里表示通过了检查，没有被限流</span><br>            node.increaseThreadNum();<br>            <span class="hljs-comment">// 2. 记录通过规则的请求</span><br>            node.addPassRequest(count);<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseThreadNum();<br>                context.getCurEntry().getOriginNode().addPassRequest(count);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseThreadNum();<br>                Constants.ENTRY_NODE.addPassRequest(count);<br>            &#125;<br><br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">var13</span> <span class="hljs-operator">=</span> StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var13.hasNext()) &#123;<br>                ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler = (ProcessorSlotEntryCallback)var13.next();<br>                handler.onPass(context, resourceWrapper, node, count, args);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (PriorityWaitException var10) &#123;<br>            node.increaseThreadNum();<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseThreadNum();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseThreadNum();<br>            &#125;<br><br>            var8 = StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;<br>                handler = (ProcessorSlotEntryCallback)var8.next();<br>                handler.onPass(context, resourceWrapper, node, count, args);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException var11) &#123;<br>            <span class="hljs-type">BlockException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> var11;<br>            context.getCurEntry().setBlockError(var11);<br>            node.increaseBlockQps(count);<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseBlockQps(count);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseBlockQps(count);<br>            &#125;<br><br>            var8 = StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;<br>                handler = (ProcessorSlotEntryCallback)var8.next();<br>                handler.onBlocked(e, context, resourceWrapper, node, count, args);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>            context.getCurEntry().setError(var12);<br>            <span class="hljs-keyword">throw</span> var12;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><code>node.addPassRequest</code>方法是在<code>fireEntry</code>执行后才执行的，也就是说，当前请求通过了 sentinel 的流控规则，此时需要将当次请求记录下来，也就是执行<code>addPassRequest</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPassRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-built_in">super</span>.addPassRequest(count);<br>    <span class="hljs-built_in">this</span>.clusterNode.addPassRequest(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面方法在<code>DefaultNode</code>对象中。</p><ul><li><code>DefaultNode</code>：保存着某个 resource 在某个 context 中的实时指标，每个 DefaultNode 都指向一个 ClusterNode</li><li><code>ClusterNode</code>：保存着某个 resource 在所有 context 中实时指标的总和，同样的 resource 会共享同一个 ClusterNode，不管他在哪个 context 中</li></ul><p>在<code>StatisticNode</code>类中对<code>ArrayMetric</code>进行了初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.rollingCounterInSecond = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL);<br><span class="hljs-built_in">this</span>.rollingCounterInMinute = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(<span class="hljs-number">60</span>, <span class="hljs-number">60000</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPassRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-built_in">this</span>.rollingCounterInSecond.addPass(count);<br>    <span class="hljs-built_in">this</span>.rollingCounterInMinute.addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加指标用的 addPass 方法是一个<code>ArrayMetric</code>的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LeapArray&lt;MetricBucket&gt; data;<br><br><span class="hljs-comment">// SAMPLE_COUNT=2  INTERVAL=1000 上面传递的静态变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayMetric</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs)</span> &#123;<br>    <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OccupiableBucketLeapArray</span>(sampleCount, intervalInMs);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPass</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    WindowWrap&lt;MetricBucket&gt; wrap = <span class="hljs-built_in">this</span>.data.currentWindow();<br>    ((MetricBucket)wrap.value()).addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就跟窗口有关系了，这里使用<code>data</code>来获取当前窗口，窗口大小为 2。data 的类型是<code>MetricBucket</code>对象，用来保存各项指标，变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LongAdder[] counters;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> minRt;<br></code></pre></td></tr></table></figure><p><code>WindowWrap</code>对象的变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间窗口的长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowLengthInMs;<br><span class="hljs-comment">// 时间窗口的开始时间，单位是毫秒</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> windowStart;<br><span class="hljs-comment">//时间窗口的内容，在 WindowWrap 中是用泛型表示这个值的，但实际上就是 MetricBucket 类, 参考上面代码</span><br><span class="hljs-keyword">private</span> T value;<br></code></pre></td></tr></table></figure><p><code>LeapArray</code>对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeapArray</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 时间窗口的长度</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> windowLengthInMs;<br>    <span class="hljs-comment">// 采样窗口的个数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> sampleCount;<br>    <span class="hljs-comment">// 以毫秒为单位的时间间隔</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> intervalInMs;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> intervalInSecond;<br>    <span class="hljs-comment">// 采样的时间窗口数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">updateLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LeapArray</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs)</span> &#123;<br>        AssertUtil.isTrue(sampleCount &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;bucket count is invalid: &quot;</span> + sampleCount);<br>        AssertUtil.isTrue(intervalInMs &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;total time interval of the sliding window should be positive&quot;</span>);<br>        AssertUtil.isTrue(intervalInMs % sampleCount == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;time span needs to be evenly divided&quot;</span>);<br>        <span class="hljs-built_in">this</span>.windowLengthInMs = intervalInMs / sampleCount;<br>        <span class="hljs-built_in">this</span>.intervalInMs = intervalInMs;<br>        <span class="hljs-built_in">this</span>.intervalInSecond = (<span class="hljs-type">double</span>)intervalInMs / <span class="hljs-number">1000.0D</span>;<br>        <span class="hljs-comment">// 时间窗口的采样个数，默认为2个采样窗口</span><br>        <span class="hljs-built_in">this</span>.sampleCount = sampleCount;<br>        <span class="hljs-built_in">this</span>.array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceArray</span>(sampleCount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>LeapArray</code>中创建了一个<code>AtomicReferenceArray</code>数组，用来对时间窗口中的统计值进行采样。通过采样的统计值计算出平均值，即最终的实时指标的值。</p><p>重点是<code>this.data.currentWindow();</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateTimeIdx</span><span class="hljs-params">(<span class="hljs-comment">/*@Valid*/</span> <span class="hljs-type">long</span> timeMillis)</span> &#123;<br>    <span class="hljs-comment">// 获取时间窗口个数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">timeId</span> <span class="hljs-operator">=</span> timeMillis / windowLengthInMs;<br>    <span class="hljs-comment">// Calculate current index so we can map the timestamp to the leap array.</span><br>    <span class="hljs-comment">// 获取当前时间在实际窗口array数组中的索引</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(timeId % array.length());<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title function_">calculateWindowStart</span><span class="hljs-params">(<span class="hljs-comment">/*@Valid*/</span> <span class="hljs-type">long</span> timeMillis)</span> &#123;<br>    <span class="hljs-comment">// 获取时间窗口的起始时间。如下：</span><br>    <span class="hljs-comment">// 时间点：0    1    2   3   4   5   6</span><br>    <span class="hljs-comment">// 时间窗口windowLengthInMs为：2</span><br>    <span class="hljs-comment">// 当前时间为timeMillis为：5</span><br>    <span class="hljs-comment">// 当前时间所在的窗口起始时间= 5 - 5 % 2 = 4</span><br>    <span class="hljs-comment">// timeMillis % windowLengthInMs = 当前时间在当前时间窗口已经跑过的距离</span><br>    <span class="hljs-keyword">return</span> timeMillis - timeMillis % windowLengthInMs;<br>&#125;<br><br><span class="hljs-comment">// 传进来的是当前时间</span><br><span class="hljs-keyword">public</span> WindowWrap&lt;T&gt; <span class="hljs-title function_">currentWindow</span><span class="hljs-params">(<span class="hljs-type">long</span> timeMillis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (timeMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><span class="hljs-comment">// 时间窗口个数对2（假如默认值）取模</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> calculateTimeIdx(timeMillis);<br>        <span class="hljs-comment">// Calculate current bucket start time.</span><br>    <span class="hljs-comment">// 时间窗口的起始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">windowStart</span> <span class="hljs-operator">=</span> calculateWindowStart(timeMillis);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Get bucket item at given time from the array.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * (1) Bucket is absent, then just create a new bucket and CAS update to circular array.</span><br><span class="hljs-comment">         * (2) Bucket is up-to-date, then just return the bucket.</span><br><span class="hljs-comment">         * (3) Bucket is deprecated, then reset current bucket and clean all deprecated buckets.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 根据索引获取缓存的时间窗口</span><br>            WindowWrap&lt;T&gt; old = array.get(idx);<br>           <span class="hljs-comment">// 这里如果没有从缓存中取到，就会创建一个新的时间窗口，所以array的长度不能太大，不然不容易命中</span><br>            <span class="hljs-keyword">if</span> (old == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            bucket is empty, so create new and update</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the old bucket is absent, then we create a new bucket at &#123;@code windowStart&#125;,</span><br><span class="hljs-comment">                 * then try to update circular array via a CAS operation. Only one thread can</span><br><span class="hljs-comment">                 * succeed to update, while other threads yield its time slice.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-comment">// (1) 没取到缓存，则创建一个新的时间窗口</span><br>                WindowWrap&lt;T&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>                <span class="hljs-comment">// 通过CAS将新创建的窗口置换到缓存数组中去</span><br>                <span class="hljs-keyword">if</span> (array.compareAndSet(idx, <span class="hljs-literal">null</span>, window)) &#123;<br>                    <span class="hljs-comment">// 设置成功就返回该窗口</span><br>                    <span class="hljs-keyword">return</span> window;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 否则当前线程让出时间片，等待</span><br>                    Thread.<span class="hljs-keyword">yield</span>();<br>                &#125;<br>            <span class="hljs-comment">// (2) 如果当前窗口的开始时间与old的开始时间相等，则直接返回old窗口</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart == old.windowStart()) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2     B3      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            startTime of Bucket 3: 800, so it&#x27;s up-to-date</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If current &#123;@code windowStart&#125; is equal to the start timestamp of old bucket,</span><br><span class="hljs-comment">                 * that means the time is within the bucket, so directly return the bucket.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">return</span> old;<br>            <span class="hljs-comment">// 如果当前时间窗口的开始时间已经超过了old窗口的开始时间，则放弃old窗口</span><br>            <span class="hljs-comment">// 并将time设置为新的时间窗口的开始时间，此时窗口向前滑动</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &gt; old.windowStart()) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *   (old)</span><br><span class="hljs-comment">                 *             B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * |_______||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * ...    1200     1400    1600    1800    2000    2200  timestamp</span><br><span class="hljs-comment">                 *                              ^</span><br><span class="hljs-comment">                 *                           time=1676</span><br><span class="hljs-comment">                 *          startTime of Bucket 2: 400, deprecated, should be reset</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the start timestamp of old bucket is behind provided time, that means</span><br><span class="hljs-comment">                 * the bucket is deprecated. We have to reset the bucket to current &#123;@code windowStart&#125;.</span><br><span class="hljs-comment">                 * Note that the reset and clean-up operations are hard to be atomic,</span><br><span class="hljs-comment">                 * so we need a update lock to guarantee the correctness of bucket update.</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * The update lock is conditional (tiny scope) and will take effect only when</span><br><span class="hljs-comment">                 * bucket is deprecated, so in most cases it won&#x27;t lead to performance loss.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (updateLock.tryLock()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// (3) Successfully get the update lock, now we reset the bucket.</span><br>                        <span class="hljs-keyword">return</span> resetWindowTo(old, windowStart);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        updateLock.unlock();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span><br>                    Thread.<span class="hljs-keyword">yield</span>();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &lt; old.windowStart()) &#123;<br>                <span class="hljs-comment">// Should not go through here, as the provided time is already behind.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面代码实际可以分成以下几步：</p><ol><li>根据当前时间，算出该时间的 timeId，并根据 timeId 算出当前窗口在采样窗口数组中的索引 idx。</li><li>根据当前时间算出当前窗口的应该对应的开始时间 time，以毫秒为单位。</li><li>根据索引 idx，在采样窗口数组中取得一个时间窗口。</li><li>循环判断直到获取到一个当前时间窗口 old 。<ol><li>如果 old 为空，则创建一个时间窗口，并将它插入到 array 的第 idx 个位置，array 上面已经分析过了，是一个 AtomicReferenceArray。</li><li>如果当前窗口的开始时间 time 与 old 的开始时间相等，那么说明 old 就是当前时间窗口，直接返回 old。</li><li>如果当前窗口的开始时间 time 大于 old 的开始时间，则说明 old 窗口已经过时了，将 old 的开始时间更新为最新值：time，进入下一次得循环再判断当前窗口的开始时间 time 与 old 的开始时间相等的时候返回。</li><li>如果当前窗口的开始时间 time 小于 old 的开始时间，实际上这种情况是不可能存在的，因为 time 是当前时间，old 是过去的一个时间。</li></ol></li></ol><p><strong>timeId（即时间窗口的个数）是会随着时间的增长而增加，当前时间每增长一个 windowLength 的长度，timeId 就加 1。但是 idx 不会增长，只会在 0 和 1 之间变换，因为 array 数组的长度是 2，只有两个采样时间窗口。</strong></p><p>为什么默认只有两个采样窗口？可能是因为时间窗口中保存着很多统计数据，如果时间窗口过多的话，一方面会占用过多内存，另一方面时间窗口过多就意味着时间窗口的长度会变小，如果时间窗口长度变小，就会导致时间窗口过于频繁的滑动。</p><p><strong>下面看看 currentWindow 代码逻辑</strong>：</p><p>根据当前时间除于 <code>windowLength </code>得到一个 timeId，再用 timeId 跟取样窗口的长度进行一个取模，那么值一定会落在 0，1 两个位置的其中一个。然后根据当前时间算出当前窗口的应该对应的开始时间 time。由于刚刚开始的时候 array 是空的，那么获取到的 old 应当是 null，那么会创建一个新的实例，用图看一下初始化的 LeapArray：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091850289.png" alt="image-20230709184837045"></p><p>当 old 获取到的是 null，那么初始的时候 arrays 数组中只有一个窗口（可能是第一个(idx&#x3D;0)，也可能是第二个(idx&#x3D;1)），每个时间窗口的长度是 500ms，这就意味着只要当前时间与时间窗口的差值在 500ms 之内，时间窗口就不会向前滑动。例如，假如当前时间走到 300 或者 500 时，当前时间窗口仍然是相同的那个：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091854811.png" alt="image-20230709185358381"></p><p>时间继续往前走，当超过 500ms 时，时间窗口就会向前滑动到下一个，这时就会更新当前窗口的开始时间,时间继续往前走，只要不超过 1000ms，则当前窗口不会发生变化，其中代码实现是 resetWindowTo 方法：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091857034.png" alt="image-20230709185704628"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WindowWrap&lt;MetricBucket&gt; <span class="hljs-title function_">resetWindowTo</span><span class="hljs-params">(WindowWrap&lt;MetricBucket&gt; w, <span class="hljs-type">long</span> time)</span> &#123;<br>    <span class="hljs-comment">// Update the start time and reset value.</span><br>    w.resetTo(time);<br>    <span class="hljs-type">MetricBucket</span> <span class="hljs-variable">borrowBucket</span> <span class="hljs-operator">=</span> borrowArray.getWindowValue(time);<br>    <span class="hljs-keyword">if</span> (borrowBucket != <span class="hljs-literal">null</span>) &#123;<br>        w.value().reset();<br>        w.value().addPass((<span class="hljs-type">int</span>)borrowBucket.pass());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        w.value().reset();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br></code></pre></td></tr></table></figure><p>当时间继续往前走，当前时间超过 1000ms 时，就会再次进入下一个时间窗口，此时 arrays 数组中的窗口将会有一个失效，会有另一个新的窗口进行替换：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906190.png" alt="image-20220814153836045"></p><p>这样，在当前时间点中进入的请求，会被统计到当前时间对应的窗口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPass</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    WindowWrap&lt;MetricBucket&gt; wrap = data.currentWindow();<br>    wrap.value().addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>获得窗口后，会执行下面语句，增加当前窗口通过的请求数 QPS。这里的<code>wrap.value()</code>得到的是<code>MetricBucket</code>，在 Sentinel 中 QPS 相关数据的统计结果就维护在这个类中<code>LongAddr[]</code>中，最终由这个指标来与我们设置好的规则进行匹配，查看是否限流，也就是<code>StatisticSlot</code>的 entry 方法中的<code>fireEntry</code>，都要先进入到<code>FlowSlot</code>的<code>entry</code>方法进行限流过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 在此方法里面进行限流规则检查</span><br>    checkFlow(resourceWrapper, context, node, count, prioritized);<br><br>    fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>FlowRuleChecker</code>类中，循环规则匹配资源进行限流过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkFlow</span><span class="hljs-params">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span><br><span class="hljs-params">                      Context context, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized)</span> <span class="hljs-keyword">throws</span> BlockException &#123;<br>    <span class="hljs-keyword">if</span> (ruleProvider == <span class="hljs-literal">null</span> || resource == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());<br>    <span class="hljs-keyword">if</span> (rules != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (FlowRule rule : rules) &#123;<br>            <span class="hljs-keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowException</span>(rule.getLimitApp(), rule);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/wuzhenzhao/p/11453649.html">https://www.cnblogs.com/wuzhenzhao/p/11453649.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存一致性方案思考</title>
    <link href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、缓存的查询"><a href="#一、缓存的查询" class="headerlink" title="一、缓存的查询"></a>一、缓存的查询</h2><p>先查询缓存，如果缓存查询失败，就去查询数据库，然后重新生成缓存。</p><h2 id="二、缓存的更新"><a href="#二、缓存的更新" class="headerlink" title="二、缓存的更新"></a>二、缓存的更新</h2><p>在高并发的情况下，需要考虑下面两个问题：</p><ul><li>是先更新数据库还是先更新缓存？</li><li>是更新缓存还是删除缓存？</li></ul><h4 id="1-先更新数据库再更新缓存"><a href="#1-先更新数据库再更新缓存" class="headerlink" title="1. 先更新数据库再更新缓存"></a>1. 先更新数据库再更新缓存</h4><p>线程A：更新数据库（第1s）——&gt;  更新缓存（第10s）</p><p>线程B：更新数据库 （第3s）——&gt; 更新缓存（第5s）</p><p>上面情况，就会导致线程B的缓存值被线程A覆盖，<strong>缓存中存的是线程A的旧值</strong>，产生脏数据并且直到缓存失效（如果有过期时间）。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252234.png" alt="image-20230620164505738" style="zoom:50%;" /><h4 id="2-先更新缓存再更新数据库"><a href="#2-先更新缓存再更新数据库" class="headerlink" title="2. 先更新缓存再更新数据库"></a>2. 先更新缓存再更新数据库</h4><p>线程A：更新缓存（第1s）——&gt; 更新数据库（第10s）</p><p>线程B： 更新缓存（第3s）——&gt;  更新数据库（第5s）</p><p>和前面一种情况相反，<strong>缓存中是线程B的新值，而数据库中是线程A的旧值。</strong></p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252759.png" alt="image-20230620170050262" style="zoom:50%;" /><p>﻿前两种方式之所以会在并发场景下出现异常，<strong>本质上是因为更新缓存和更新数据库是两个操作</strong>。</p><p>如果把它化简，更新时只更新数据库，同时删除缓存。等待下一次查询时命中不到缓存，再去重建缓存，是不是就解决了这个问题？</p><h4 id="3-先删除缓存再更新数据库"><a href="#3-先删除缓存再更新数据库" class="headerlink" title="3. 先删除缓存再更新数据库"></a>3. 先删除缓存再更新数据库</h4><p>通过这种方式，两个线程都值修改数据库，不管谁先，数据库以后修改的数据为准。</p><p>但这时另一个<strong>并发场景</strong>：两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的。很显然，这种状况也不是我们想要的。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252794.png" alt="image-20230620170016670" style="zoom:50%;" /><p><strong>解决方案</strong>：</p><h5 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h5><p>对于<strong>请求</strong>A，做一下操作：</p><ol><li><p>删除缓存</p></li><li><p>更新数据库</p></li><li><p><strong>睡眠一段时间</strong></p></li><li><p><strong>再次删除缓存</strong></p></li></ol><p>添加一个睡眠时间，主要是为了确保请求A在睡眠的时候，请求B能在这段时间内完成<strong>从数据库读取数据，再把缺失的数据写入缓存</strong>的操作，然后请求A睡眠完，再删除缓存。</p><p>所以请求A的睡眠时间就需要大于请求B<strong>从数据库读取数据+写入数据</strong>的时间。<strong>但是这个时间不好评估</strong>。</p><p><strong>所以不建议这种方案</strong>。</p><h4 id="4-先更新数据库再删除缓存（cache-aside）"><a href="#4-先更新数据库再删除缓存（cache-aside）" class="headerlink" title="4. 先更新数据库再删除缓存（cache aside）"></a>4. 先更新数据库再删除缓存（cache aside）</h4><p><strong>场景</strong>：一个是查询操作，一个是更新操作的并发，我们先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，删除操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会方案3一样，后续的查询操作一直在取老的数据。如下图：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252546.png" alt="image-20230619202426780" style="zoom: 50%;" /><p>但是，这种策略也不是一定完美。看下面这个场景：</p><p>一个读操作没有命中缓存，然后就去数据库中获取数据。此时有一个写操作，写完数据库后，让缓存失效。然后之前的读操作再把老的数据写回缓存，这样就造成脏数据。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252030.png" alt="image-20230620170340552" style="zoom:50%;" /><p>上面的例子理论上会出现，但是出现概率比较低。因为条件需要读缓存时缓存正好失效，并且此时并发一个写操作。而数据库写操作比读操作慢的多，而读操作读操作必须在写操作之前，又要晚于写操作更新缓存。所有条件在一起的可能性并不大。</p><h2 id="三、操作失败如何"><a href="#三、操作失败如何" class="headerlink" title="三、操作失败如何"></a>三、操作失败如何</h2><p>在实际生产中，由于网络抖动、服务下线等原因，对数据库和缓存的操作可能失败。</p><p>举例说明：应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252746.png" alt="image-20230620170950273" style="zoom:50%;" /><p>那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有删除，所以会缓存命中，但是读到的却是旧值 1。</p><p>其实<strong>不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题</strong>。</p><p>问题原因知道了，该怎么解决呢？有两种方法：</p><ul><li>重试机制</li><li>订阅MySQL binlog，再操作缓存</li></ul><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p>举个例子，来说明重试机制的过程：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252738.png" alt="image-20230620171258860" style="zoom:50%;" /><h4 id="订阅-MySQL-binlog，再操作缓存"><a href="#订阅-MySQL-binlog，再操作缓存" class="headerlink" title="订阅 MySQL binlog，再操作缓存"></a>订阅 MySQL binlog，再操作缓存</h4><p><strong>先更新数据库，再删缓存</strong>的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p><p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p><p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p><p>下图是 Canal 的工作原理：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262253576.png" alt="image-20230619225953489"></p><p>综上，<strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</strong></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="1-cache-aside并非万能"><a href="#1-cache-aside并非万能" class="headerlink" title="1. cache aside并非万能"></a>1. cache aside并非万能</h3><p>虽然说cache aside可以被称之为缓存使用的最佳实践，但与此同时，它引入了缓存的命中率降低的问题，（每次都删除缓存自然导致更不容易命中了），因此它更适用于对缓存命中率要求并不是特别高的场景。<strong>如果要求较高的缓存命中率，依然需要采用更新数据库后同时更新缓存的方案</strong>。</p><h3 id="2-缓存数据不一致的解决方案"><a href="#2-缓存数据不一致的解决方案" class="headerlink" title="2. 缓存数据不一致的解决方案"></a>2. 缓存数据不一致的解决方案</h3><p>在更新数据库后同时更新缓存，会在并发的场景下出现数据不一致，有下面方案：</p><h4 id="引入分布式锁"><a href="#引入分布式锁" class="headerlink" title="引入分布式锁"></a>引入分布式锁</h4><p>在更新缓存之前尝试获取锁，如果已经被占用就先阻塞住线程，等待其他线程释放锁后再尝试更新。但这会影响并发操作的性能。</p><h4 id="设置较短缓存时间"><a href="#设置较短缓存时间" class="headerlink" title="设置较短缓存时间"></a>设置较短缓存时间</h4><p>设置较短的缓存过期时间能够使得数据不一致问题存在的时间也比较短，对业务的影响相对较小。但是与此同时，其实这也使得缓存命中率降低，又回到了前面的问题里…</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li><a href="https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY">https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU缓存算法</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="双向链表-哈希表（非线程安全）"><a href="#双向链表-哈希表（非线程安全）" class="headerlink" title="双向链表+哈希表（非线程安全）"></a>双向链表+哈希表（非线程安全）</h2><p><a href="https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/">https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LRU算法: 哈希表+双向链表实现</span><br><span class="hljs-comment"> * 1. 双向链表按照被使用的顺序来存储, 靠近头部的节点是最近使用的, 靠近尾部的节点是最久未使用的</span><br><span class="hljs-comment"> * 2. 哈希表存储key和node映射关系, 通过key能快速定位到链表中的节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhangjunfeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2023/2/2 16:15</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">()</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value)</span> &#123;<br>            key = _key;<br>            value = _value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode head, tail;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> _capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity = _capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 先判断key是否存在, 不存在返回-1</span><br><span class="hljs-comment">     * 2. 若key存在, 则key对应的节点就是最近访问节点, 通过哈希表映射到在双向链表中的位置, 然后将节点移动到链表头部</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// key存在则移动到链表头部, 表示最近访问</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 如果key不存在, 创建一个新节点并在链表头部添加该节点, 判断链表长度是否超出容量限制, 若超出容量, 则删除链表尾部结点</span><br><span class="hljs-comment">     * 2. 如果key存在, 覆盖旧值, 将节点移动到头部</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// node不存在, 则创建一个新节点</span><br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache.put(key, newNode);<br>            <span class="hljs-comment">// 添加到链表头部, 表示最近访问</span><br>            addToHead(newNode);<br>            <span class="hljs-comment">// 链表长度加1</span><br>            ++size;<br>            <span class="hljs-comment">// 如果超出缓存容量</span><br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 删除链表最后一个结点, 去掉最长时间未访问的</span><br>                <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> removeTail();<br>                <span class="hljs-comment">// 去掉哈希表中对应节点</span><br>                cache.remove(tail.key);<br>                <span class="hljs-comment">// 减小链表长度</span><br>                --size;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果缓存中有</span><br>            <span class="hljs-comment">// 先覆盖旧值</span><br>            node.value = value;<br>            <span class="hljs-comment">// 再将节点移到链表头部, 表示最近访问</span><br>            moveToHead(node);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个结点需要修改四条链</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(DLinkedNode node)</span> &#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除一个结点需要修改两条链</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(DLinkedNode node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 把结点移到头部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span> &#123;<br>        <span class="hljs-comment">// 先删除节点</span><br>        removeNode(node);<br>        <span class="hljs-comment">// 再将该节点移到头部</span><br>        addToHead(node);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除尾结点并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> tail.prev;<br>        removeNode(last);<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;key: &quot;</span> + cur.key + <span class="hljs-string">&quot;; value: &quot;</span> + cur.value);<br>            cur = cur.next;<br>            <br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="线程安全版本"><a href="#线程安全版本" class="headerlink" title="线程安全版本"></a>线程安全版本</h2><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p><code>ConcurrentHashMap</code> + <code>ConcurrentLinkedQueue</code> +<code>ReadWriteLock</code></p><h3 id="ConcurrentLinkedQueue简单介绍"><a href="#ConcurrentLinkedQueue简单介绍" class="headerlink" title="ConcurrentLinkedQueue简单介绍"></a><strong>ConcurrentLinkedQueue简单介绍</strong></h3><p><strong>ConcurrentLinkedQueue是一个基于单向链表的无界无锁线程安全的队列，适合在高并发环境下使用，效率比较高。</strong> 我们在使用的时候，可以就把它理解为我们经常接触的数据结构——队列，不过是增加了多线程下的安全性保证罢了。<strong>和普通队列一样，它也是按照先进先出(FIFO)的规则对接点进行排序。</strong> 另外，队列元素中不可以放置null元素。</p><p><code>ConcurrentLinkedQueue中</code>最主要的两个方法是：<code>offer(value)</code>和<code>poll()</code>，分别实现队列的两个重要的操作：入队和出队(<code>offer(value)</code>等价于 <code>add(value)</code>)。</p><p>我们添加一个元素到队列的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。</p><p>利用<code>ConcurrentLinkedQueue</code>队列先进先出的特性，每当我们 <code>put</code>&#x2F;<code>get</code>(缓存被使用)元素的时候，我们就将这个元素存放在队列尾部，这样就能保证队列头部的元素是最近最少使用的。</p><h3 id="ReadWriteLock简单介绍"><a href="#ReadWriteLock简单介绍" class="headerlink" title="ReadWriteLock简单介绍"></a><strong>ReadWriteLock简单介绍</strong></h3><p><code>ReadWriteLock</code> 是一个接口，位于<code>java.util.concurrent.locks</code>包下，里面只有两个方法分别返回读锁和写锁：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">public interface ReadWriteLock &#123;<br>    /**<br>     * 返回读锁<br>     */<br>    Lock readLock();<br><br>    /**<br>     * 返回写锁<br>     */<br>    Lock writeLock();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code> 是<code>ReadWriteLock</code>接口的具体实现类。</p><p><strong>读写锁还是比较适合缓存这种读多写少的场景。读写锁可以保证多个线程和同时读取，但是只有一个线程可以写入。但是，有一个问题是当读锁被线程持有的时候，读锁是无法被其它线程申请的，会处于阻塞状态，直至读锁被释放。</strong></p><p>另外，<strong>同一个线程持有写锁时是可以申请读锁，但是持有读锁的情况下不可以申请写锁。</strong></p><h3 id="ScheduledExecutorService-简单介绍"><a href="#ScheduledExecutorService-简单介绍" class="headerlink" title="ScheduledExecutorService 简单介绍"></a><strong>ScheduledExecutorService 简单介绍</strong></h3><p><code>ScheduledExecutorService</code> 是一个接口，<code>ScheduledThreadPoolExecutor</code> 是其主要实现类。</p><p><strong><code>ScheduledThreadPoolExecutor</code></strong> <strong>主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目用到的比较少，因为有其他方案选择比如<code>quartz</code>。但是，在一些需求比较简单的场景下还是非常有用的！</p><p><strong><code>ScheduledThreadPoolExecutor</code></strong> <strong>使用的任务队列</strong> <strong><code>DelayQueue</code></strong> <strong>封装了一个</strong> <strong><code>PriorityQueue</code>，<code>PriorityQueue</code></strong> <strong>会对队列中的任务进行排序，执行所需时间短的放在前面先被执行，如果执行所需时间相同则先提交的任务将被先执行。</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>LRU缓存指的是当缓存大小已达到最大分配容量的时候，如果再要去缓存新的对象数据的话，就需要将缓存中最近访问最少的对象删除掉以便给新来的数据腾出空间。</p><p><code>ConcurrentHashMap</code> 是线程安全的Map，我们可以利用它缓存 key,value形式的数。<code>ConcurrentLinkedQueue</code>是一个线程安全的基于链表的队列（先进先出），我们可以用它来维护 key 。每当我们put&#x2F;get(缓存被使用)元素的时候，我们就将这个元素对应的 key 存放在队列尾部，这样就能保证队列头部的元素是最近最少使用的。当我们的缓存容量不够的时候，我们直接移除队列头部对应的key以及这个key对应的缓存即可！</p><p>另外，我们用到了<code>ReadWriteLock</code>(读写锁)来保证线程安全。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 使用 ConcurrentHashMap+ConcurrentLinkedQueue+ReadWriteLock实现线程安全的 LRU 缓存</span><br><span class="hljs-comment"> * 这里只是为了学习使用，本地缓存推荐使用 Guava 自带的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLruCache</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxCapacity;<br><br>    <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;K, V&gt; cacheMap;<br>    <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;K&gt; keys;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读写锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLruCache</span><span class="hljs-params">(<span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (maxCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal max capacity: &quot;</span> + maxCapacity);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxCapacity = maxCapacity;<br>        cacheMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(maxCapacity);<br>        keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-comment">// 加写锁</span><br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                moveToTailOfQueue(key);<br>                cacheMap.put(key, value);<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>            <span class="hljs-comment">//2.是否超出缓存容量，超出的话就移除队列头部的元素以及其对应的缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.size() == maxCapacity) &#123;<br>                System.out.println(<span class="hljs-string">&quot;maxCapacity of cache reached&quot;</span>);<br>                removeOldestKey();<br>            &#125;<br>            <span class="hljs-comment">//3.key不存在于当前缓存。将key添加到队列的尾部并且缓存key及其对应的元素</span><br>            keys.add(key);<br>            cacheMap.put(key, value);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-comment">//加读锁</span><br>        readLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在的话就将key移动到队列的尾部</span><br>                moveToTailOfQueue(key);<br>                <span class="hljs-keyword">return</span> cacheMap.get(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> &#123;<br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在移除队列和Map中对应的Key</span><br>                keys.remove(key);<br>                <span class="hljs-keyword">return</span> cacheMap.remove(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将元素添加到队列的尾部(put/get的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTailOfQueue</span><span class="hljs-params">(K key)</span> &#123;<br>        keys.remove(key);<br>        keys.add(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除队列头部的元素以及其对应的缓存 (缓存容量已满的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeOldestKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">oldestKey</span> <span class="hljs-operator">=</span> keys.poll();<br>        <span class="hljs-keyword">if</span> (oldestKey != <span class="hljs-literal">null</span>) &#123;<br>            cacheMap.remove(oldestKey);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cacheMap.size();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//init cache</span><br>MyLruCache&lt;String, Integer&gt; myLruCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLruCache</span>&lt;&gt;(batchSize * <span class="hljs-number">10</span>);<br><span class="hljs-comment">//init thread pool with 10 threads</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(threadNum);<br><span class="hljs-comment">//init CountDownLatch with 10 count</span><br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; t &lt; threadNum; t++) &#123;<br>    fixedThreadPool.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; batchSize; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> atomicInteger.incrementAndGet();<br>            myLruCache.put(<span class="hljs-string">&quot;id&quot;</span> + value, value);<br>        &#125;<br>        latch.countDown();<br>    &#125;);<br>&#125;<br><span class="hljs-comment">//wait for 10 threads to complete the task</span><br>latch.await();<br>fixedThreadPool.shutdown();<br>System.out.println(<span class="hljs-string">&quot;Cache size:&quot;</span> + myLruCache.size());<span class="hljs-comment">//Cache size:100</span><br><span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> endTime - startTime;<br>System.out.println(String.format(<span class="hljs-string">&quot;Time cost：%dms&quot;</span>, duration));<span class="hljs-comment">//Time cost：511ms</span><br></code></pre></td></tr></table></figure><h2 id="线程安全并且带有过期时间"><a href="#线程安全并且带有过期时间" class="headerlink" title="线程安全并且带有过期时间"></a>线程安全并且带有过期时间</h2><p>实际上就是在我们上面时间的LRU缓存的基础上加上一个定时任务去删除缓存，单纯利用 JDK 提供的类，我们实现定时任务的方式有很多种：</p><ol><li><code>Timer</code> :不被推荐，多线程会存在问题。</li><li><code>ScheduledExecutorService</code> ：定时器线程池，可以用来替代 <code>Timer</code></li><li><code>DelayQueue</code> ：延时队列</li><li><code>quartz</code> ：一个很火的开源任务调度框架，很多其他框架都是基于 <code>quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案</li><li>……</li></ol><p>最终我们选择了 <code>ScheduledExecutorService</code>，主要原因是它易用（基于<code>DelayQueue</code>做了很多封装）并且基本能满足我们的大部分需求。</p><p>我们在我们上面实现的线程安全的 LRU 缓存基础上，简单稍作修改即可！我们增加了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAfterExpireTime</span><span class="hljs-params">(K key, <span class="hljs-type">long</span> expireTime)</span> &#123;<br>    scheduledExecutorService.schedule(() -&gt; &#123;<br>        <span class="hljs-comment">//过期后清除该键值对</span><br>        cacheMap.remove(key);<br>        keys.remove(key);<br>    &#125;, expireTime, TimeUnit.MILLISECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们put元素的时候，如果通过这个方法就能直接设置过期时间。</p><h3 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 使用 ConcurrentHashMap+ConcurrentLinkedQueue+ReadWriteLock+ScheduledExecutorService实现线程安全的 LRU 缓存</span><br><span class="hljs-comment"> * 这里只是为了学习使用，本地缓存推荐使用 Guava 自带的，使用 Spring 的话，推荐使用Spring Cache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLruCacheWithExpireTime</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxCapacity;<br><br>    <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;K, V&gt; cacheMap;<br>    <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;K&gt; keys;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读写锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();<br><br>    <span class="hljs-keyword">private</span> ScheduledExecutorService scheduledExecutorService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLruCacheWithExpireTime</span><span class="hljs-params">(<span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (maxCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal max capacity: &quot;</span> + maxCapacity);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxCapacity = maxCapacity;<br>        cacheMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(maxCapacity);<br>        keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>        scheduledExecutorService = Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value, <span class="hljs-type">long</span> expireTime)</span> &#123;<br>        <span class="hljs-comment">// 加写锁</span><br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                moveToTailOfQueue(key);<br>                cacheMap.put(key, value);<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>            <span class="hljs-comment">//2.是否超出缓存容量，超出的话就移除队列头部的元素以及其对应的缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.size() == maxCapacity) &#123;<br>                System.out.println(<span class="hljs-string">&quot;maxCapacity of cache reached&quot;</span>);<br>                removeOldestKey();<br>            &#125;<br>            <span class="hljs-comment">//3.key不存在于当前缓存。将key添加到队列的尾部并且缓存key及其对应的元素</span><br>            keys.add(key);<br>            cacheMap.put(key, value);<br>            <span class="hljs-keyword">if</span> (expireTime &gt; <span class="hljs-number">0</span>) &#123;<br>                removeAfterExpireTime(key, expireTime);<br>            &#125;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-comment">//加读锁</span><br>        readLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在的话就将key移动到队列的尾部</span><br>                moveToTailOfQueue(key);<br>                <span class="hljs-keyword">return</span> cacheMap.get(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> &#123;<br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在移除队列和Map中对应的Key</span><br>                keys.remove(key);<br>                <span class="hljs-keyword">return</span> cacheMap.remove(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将元素添加到队列的尾部(put/get的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTailOfQueue</span><span class="hljs-params">(K key)</span> &#123;<br>        keys.remove(key);<br>        keys.add(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除队列头部的元素以及其对应的缓存 (缓存容量已满的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeOldestKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">oldestKey</span> <span class="hljs-operator">=</span> keys.poll();<br>        <span class="hljs-keyword">if</span> (oldestKey != <span class="hljs-literal">null</span>) &#123;<br>            cacheMap.remove(oldestKey);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAfterExpireTime</span><span class="hljs-params">(K key, <span class="hljs-type">long</span> expireTime)</span> &#123;<br>        scheduledExecutorService.schedule(() -&gt; &#123;<br>            <span class="hljs-comment">//过期后清除该键值对</span><br>            cacheMap.remove(key);<br>            keys.remove(key);<br>        &#125;, expireTime, TimeUnit.MILLISECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cacheMap.size();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试效果：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">MyLruCacheWithExpireTime&lt;Integer,String&gt; myLruCache = new MyLruCacheWithExpireTime&lt;&gt;(3);<br>myLruCache.put(1,&quot;Java&quot;,3;<br>myLruCache.put(2,&quot;C++&quot;,3;<br>myLruCache.put(3,&quot;Python&quot;,1500);<br>System.out.println(myLruCache.size());//3<br>Thread.sleep(2;<br>System.out.println(myLruCache.size());//2<br></code></pre></td></tr></table></figure><h2 id="资料来自"><a href="#资料来自" class="headerlink" title="资料来自"></a>资料来自</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/135936339">https://zhuanlan.zhihu.com/p/135936339</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="二分4-寻找两个正序数组的中位数"><a href="#二分4-寻找两个正序数组的中位数" class="headerlink" title="二分4. 寻找两个正序数组的中位数"></a>二分4. 寻找两个正序数组的中位数</h2><blockquote><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">https://leetcode.cn/problems/median-of-two-sorted-arrays/description/</a></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：递归-二分查找排序第k值"><a href="#题解一：递归-二分查找排序第k值" class="headerlink" title="题解一：递归+二分查找排序第k值"></a>题解一：递归+二分查找排序第k值</h3><p><strong>时间复杂度</strong>：<code>O(log(m+n))</code></p><p><strong>思路</strong>：</p><ol><li>迭代核心是找排序为第k的数（剩余总序列里），然后剪掉前<code>k/2</code>个数。 （剔除前<code>k/2</code>个较小的后，在剩下的里面找第<code>k-(k/2)</code>个，即最开始想要的第<code>k</code>个，然后继续迭代这个过程）</li><li>终结的条件为找第<code>k=1</code>个<strong>or</strong>剪到边剪得啥都不剩了。 （k&#x3D;1说明找第一小的数，返回最小值即可。剪的啥都不剩了说明一个数组完全大于另一个，直接返回中位数即可）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 迭代核心是找排序为第k的数（剩余总序列里），然后剪掉前`k/2`个数。 （剔除前`k/2`个较小的后，在剩下的里面找第`k-(k/2)`个，即最开始想要的第`k`个，然后继续迭代这个过程）</span><br><span class="hljs-comment">     * 2. 终结的条件为找第`k=1`个**or**剪到边剪得啥都不剩了。 （k=1说明找第一小的数，返回最小值即可。剪的啥都不剩了说明一个数组完全大于另一个，直接返回中位数即可）</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>    <span class="hljs-comment">// 按照下面思路: left + right 可以满足奇数和偶数所有情况</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> (fingKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, left) + fingKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, right)) / <span class="hljs-number">2.0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fingKth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// nums1为空数组</span><br>    <span class="hljs-keyword">if</span> (nums1.length &lt;= i) <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// nums2为空数组</span><br>    <span class="hljs-keyword">if</span> (nums2.length &lt;= j) <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// k==1说明找第一小的数(剩余序列)</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>    &#125;<br>    <span class="hljs-comment">// k: 本次两个数组的中间下标</span><br>    <span class="hljs-comment">// i + k/2 - 1: k/2是因为现在在单个数组中, 该步骤表示nums1中有没有第k/2个数</span><br>    <span class="hljs-comment">// 为什么赋最大值？</span><br>    <span class="hljs-comment">// 假如nums1长度为2, nums2长度为12, 则k为(2+12)/2=7, k/2=3</span><br>    <span class="hljs-comment">// 因为nums1长度小于3, 则无法判断中位数是否在nums1中; 而nums2中前3个肯定不是中位数</span><br>    <span class="hljs-comment">// 所以当k/2不存在时,将其设置为最大值,这样可以保留继续下一次循环</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">midVal1</span> <span class="hljs-operator">=</span> (i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">midVal2</span> <span class="hljs-operator">=</span> (j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>    <span class="hljs-keyword">if</span> (midVal1 &lt; midVal2) &#123;<br>        <span class="hljs-comment">// 说明nums1的前i+k/2个数都被舍弃, 因为在整体数组前半部分比midVal2小, 说明中位数可能在nums2中</span><br>        <span class="hljs-comment">// 下一轮的中位数下标要在舍弃的基础上计算: k/2是舍弃部分, 所以是: k - k / 2</span><br>        <span class="hljs-keyword">return</span> fingKth(nums1, i + k / <span class="hljs-number">2</span>, nums2, j, k - k / <span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fingKth(nums1, i, nums2, j + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：归并排序"><a href="#题解二：归并排序" class="headerlink" title="题解二：归并排序"></a>题解二：归并排序</h3><p><strong>思路</strong>：因为两个数组都是有序数组，所以直接使用归并排序一次即可合并成整个有序数组，然后再取中位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-comment">// 先归并排序, 因为两个都是有序数组</span><br>    <span class="hljs-type">int</span>[] res = mergeSort(nums1, nums2);<br>    <span class="hljs-comment">// 这里使用一个小trick, 不用判断奇偶长度</span><br>    <span class="hljs-keyword">return</span> (res[(res.length + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + res[(res.length + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2.0</span>;<br>&#125;<br><br><span class="hljs-comment">// 归并排序底层实现: 合并两个有序数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length, len2 = nums2.length;<br>    <span class="hljs-keyword">if</span> (len1 &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums2;<br>    <span class="hljs-keyword">if</span> (len2 &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums1;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + len2];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;<br>        res[index++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; len1) &#123;<br>        res[index++] = nums1[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt; len2) &#123;<br>        res[index++] = nums2[j++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分34-在排序数组中查找元素的第一个和最后一个位置"><a href="#二分34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="二分34. 在排序数组中查找元素的第一个和最后一个位置"></a>二分34. 在排序数组中查找元素的第一个和最后一个位置</h2><blockquote><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：二分查找分别寻找最左边界和最右边界"><a href="#题解：二分查找分别寻找最左边界和最右边界" class="headerlink" title="题解：二分查找分别寻找最左边界和最右边界"></a>题解：二分查找分别寻找最左边界和最右边界</h3><p><strong>思路</strong>：</p><ol><li>二分查找可以寻找最左边界和最右边界</li><li>找到边界后需要判断边界是否合法</li></ol><p><strong>普通代码结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">// 寻找最左边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            <span class="hljs-comment">// 这时不需要mid-1, 因为右区间本来就不存在数字</span><br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断一下边界和是否等于target</span><br>    <span class="hljs-keyword">if</span> (left &lt; nums.length &amp;&amp; nums[left] == target) res[<span class="hljs-number">0</span>] = left;<br><br>    <span class="hljs-comment">// 寻找最右边界</span><br>    left = <span class="hljs-number">0</span>;<br>    right = nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>            <span class="hljs-comment">// 因为是寻找右边界, 所以left相等也先舍弃</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 这时不需要mid-1, 因为右区间本来就不存在数字</span><br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断一下边界和是否等于target</span><br>    <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; nums[right - <span class="hljs-number">1</span>] == target) res[<span class="hljs-number">1</span>] = right - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化代码结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 寻找左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 寻找右边界，由于返回的是第一个&gt;=target 但是索引+1的值, 所以要减1（参考left=mid+1后才返回，这时多加了个1）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &lt; nums.length &amp;&amp; right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-comment">// flag=true表示寻找最左边界</span><br>    <span class="hljs-comment">// 左右边界都可以返回left. 原因: 因为结束条件是left &lt; right, 所以跳出循环时一定是left=right, 所以返回left和right都行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">boolean</span> flag)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (flag &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ul><li>二分查找算法的几种情况：<a href="https://floweryu.blog.csdn.net/article/details/112378419">https://floweryu.blog.csdn.net/article/details/112378419</a></li></ul><h2 id="二分35-搜索插入位置"><a href="#二分35-搜索插入位置" class="headerlink" title="二分35. 搜索插入位置"></a>二分35. 搜索插入位置</h2><blockquote><p><a href="https://leetcode.cn/problems/search-insert-position/description/">https://leetcode.cn/problems/search-insert-position/description/</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：二分寻找目标值最左边界"><a href="#题解：二分寻找目标值最左边界" class="headerlink" title="题解：二分寻找目标值最左边界"></a>题解：二分寻找目标值最左边界</h3><p><strong>思路</strong>：</p><p>返回将要被插入的位置，其实就是寻找到target的最左边界, 找到最接近小于target的值的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分74-搜索二维矩阵"><a href="#二分74-搜索二维矩阵" class="headerlink" title="二分74. 搜索二维矩阵"></a>二分74. 搜索二维矩阵</h2><blockquote><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109603.png" alt="image-20230316132305748" style="zoom:25%;" /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：-二叉搜索树思想（消去行列）"><a href="#题解：-二叉搜索树思想（消去行列）" class="headerlink" title="题解： 二叉搜索树思想（消去行列）"></a>题解： 二叉搜索树思想（消去行列）</h3><p>详情可见：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg">剑指Offer.04 二维数组中的查找</a></p><p><strong>思路</strong>：</p><ul><li>以矩阵左下角位置<code>tmp</code>为观察点: 小于<code>tmp</code>的元素都在<code>tmp</code>所在行之上, 大于<code>tmp</code>的元素都在<code>tmp</code>所在列向右</li><li>所以, 每次比较<code>tmp</code>和<code>target</code>的值, 然后舍弃行列即可, 规则如下：<ul><li>若<code>target &gt; tmp</code>, 则说明<code>tmp</code>该列向左的元素都小于<code>target</code>, 所以舍弃该列，即<code>j++</code></li><li>若<code>target &lt; tmp</code>, 则说明<code>target</code>在<code>tmp</code>所在行之上，所以舍弃该行，即<code>i--</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (target &gt; matrix[i][j]) &#123;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; matrix[i][j]) &#123;<br>            i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分162-寻找峰值"><a href="#二分162-寻找峰值" class="headerlink" title="二分162. 寻找峰值"></a>二分162. 寻找峰值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-peak-element/description/">https://leetcode.cn/problems/find-peak-element/description/</a></p><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,1,3,5,6,4]</span><br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span> <br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；<br>     或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ol><li>由于是严格递增的，所以二分时只需要判断<code>nums[mid] &gt; nums[mid + 1]</code>即可。</li><li>由于需要将<code>mid</code>和<code>mid + 1</code>进行比较，所以<code>while</code>条件必须是<code>left &lt; right</code>，如果是<code>left &lt;= right</code>，则在一个元素时，会数组越界。</li><li><code>right</code>的初始化条件不能用<code>nums.lenght</code>，当只有一个元素时，是需要结束<code>while</code>循环的，所以当只有一个元素时，<code>left</code>和<code>right</code>必须相等。</li><li>由于<code>nums[nums.length]=负无穷</code>，所以二分查找大的那一半一定存在峰值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这里必须使用nums.length - 1, 因为只有一个元素时, left等于right直接返回</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这里必须是 &lt; , 如果是&lt;=, 则下面mid会越界</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">https://leetcode.cn/problems/binary-tree-preorder-traversal/description/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p></blockquote><h4 id="二叉树前序遍历："><a href="#二叉树前序遍历：" class="headerlink" title="二叉树前序遍历："></a>二叉树前序遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    res.add(root.val);<br>    preorderTraversal(root.left);<br>    preorderTraversal(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    inorderTraversal(root.left);<br>    res.add(root.val);<br>    inorderTraversal(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    postorderTraversal(root.left);<br>    postorderTraversal(root.right);<br>    res.add(root.val);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108652.png" alt="image-20230428173147211" style="zoom:50%;" /><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 记录每次层个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-comment">// 每一层放入一个列表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            tmp.add(poll.val);<br>            <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.right);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h2><blockquote><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/description/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/description/</a></p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108728.png" alt="image-20230514152733905"></p></blockquote><h4 id="题解：层序遍历对每层进行奇偶判断"><a href="#题解：层序遍历对每层进行奇偶判断" class="headerlink" title="题解：层序遍历对每层进行奇偶判断"></a>题解：层序遍历对每层进行奇偶判断</h4><p>层序遍历二叉树，初始化一个下标<code>index</code>用来判断是奇数层还是偶数层</p><ul><li>如果是奇数层则正常添加元素</li><li>如果是偶数层则向结果集倒着添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                tmp.addLast(poll.val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp.addFirst(poll.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.right);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a>剑指 Offer 55 - I. 二叉树的深度</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/</a></p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108745.png" alt="image-20230514153159332"></p></blockquote><h3 id="题解：递归"><a href="#题解：递归" class="headerlink" title="题解：递归"></a>题解：递归</h3><ul><li>递归左子树和右子树，每次递归深度+1</li><li>每次递归都比较左右子树深度，取深度大的返回</li></ul><p>【可以背一下】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a>剑指 Offer 34. 二叉树中和为某一值的路径</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108969.png" alt="image-20230514155635577"></p></blockquote><h4 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h4><p><strong>思路</strong>：深度优先搜索枚举每条从根节点到叶子节点，当遍历到叶节点时并且此时路径和恰好是目标和时，就找到一条满足条件的路径。</p><blockquote><p>需要注意的是添加路径时要拷贝一份数组，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>    dfs(root, target, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target, List&lt;Integer&gt; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    arr.add(root.val);<br>    dfs(root.left, target - root.val, arr);<br>    dfs(root.right, target - root.val, arr);<br><br>    <span class="hljs-keyword">if</span> (target == root.val &amp;&amp; root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 这里不能直接加入arr, 而是要复制一份</span><br>        <span class="hljs-comment">// 因为直接加入是引用, arr后面还会变</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(arr));<br>        <span class="hljs-comment">// 这里也不能return, 因为该节点不能影响其他节点, 还需要将它移除</span><br>    &#125;<br>    <span class="hljs-comment">// 如果当前叶子节点不满足target, 需要把他移除, 该节点不影响其他节点</span><br>    arr.remove(arr.size() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(N^2)，其中N是树的节点数。最坏情况每条路径都符合要求，路径数目是N，节点数目也是N（这里是拷贝数组时的复杂度）。</p><p><strong>空间复杂度</strong>：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p><h4 id="题解二：广度优先搜索"><a href="#题解二：广度优先搜索" class="headerlink" title="题解二：广度优先搜索"></a>题解二：广度优先搜索</h4><p>遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，就找到了一条满足条件的路径。</p><p>为了节省空间，使用哈希表<code>map</code>记录树中的每一个节点的父节点。每次找到一个满足条件的节点，就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 存储最终结果</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 存储节点的父结点, 便于寻找完成路径 key: 节点 value: 父结点</span><br>    Map&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 层序遍历队列存储节点</span><br>    Queue&lt;TreeNode&gt; queueNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 存储层序遍历到当前节点时，前面已经累加的sum</span><br>    Queue&lt;Integer&gt; sumQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queueNode.offer(root);<br>    sumQueue.offer(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (!queueNode.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queueNode.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rec</span> <span class="hljs-operator">=</span> sumQueue.poll() + poll.val;<br><br>        <span class="hljs-keyword">if</span> (poll.left == <span class="hljs-literal">null</span> &amp;&amp; poll.right == <span class="hljs-literal">null</span> &amp;&amp; rec == target) &#123;<br>            getPath(poll, res, map);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 记录left的父结点</span><br>                map.put(poll.left, poll);<br>                queueNode.offer(poll.left);<br>                <span class="hljs-comment">// 说明还有叶节点，还需要继续遍历</span><br>                sumQueue.offer(rec);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                map.put(poll.right, poll);<br>                queueNode.offer(poll.right);<br>                sumQueue.offer(rec);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据叶节点获取完整路径</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode node, List&lt;List&lt;Integer&gt;&gt; res, Map&lt;TreeNode, TreeNode&gt; map)</span> &#123;<br>    LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>        tmp.addFirst(node.val);<br>        node = map.get(node);<br>    &#125;<br>    res.add(tmp);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(N^2)，其中 N 是树的节点数。</p><p><strong>空间复杂度</strong>：O(N)，其中 N是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数。</p><h2 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/">https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/</a></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108201.png" alt="image-20230514172511622"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108672.png" alt="image-20230514172535408"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p></blockquote><h4 id="题解：递归中序遍历-链表构造"><a href="#题解：递归中序遍历-链表构造" class="headerlink" title="题解：递归中序遍历+链表构造"></a>题解：递归中序遍历+链表构造</h4><p>算法流程：</p><ul><li><ol><li>中序遍历：二叉搜索树中序遍历结果是一个有序集</li></ol></li><li><ol start="2"><li>递归左子树，即midDfs(root.left)</li></ol></li><li><ol start="3"><li>构造链表：</li></ol><ul><li>当pre不为空时，修改双向节点引用，即：pre.right &#x3D; node, node.left &#x3D; pre</li><li>当pre为空时，表示正在访问头结点，即为head</li><li>保存node节点，作为下一个pre节点</li></ul></li><li><ol start="4"><li>递归右子树，即midDfs(root.right)</li></ol></li><li><ol start="5"><li>递归完成后，需要将头尾节点相连，此时pre就是尾结点。即：pre.right &#x3D; head, head.left &#x3D; pre</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">Node head, pre;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    midDfs(root);<br>    pre.right = head;<br>    head.left = pre;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">midDfs</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    midDfs(node.left);<br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>        pre.right = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 说明是第一个节点</span><br>        head = node;<br>    &#125;<br>    node.left = pre;<br>    pre = node;<br>    midDfs(node.right);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/</a></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108713.png" alt="image-20230514183743231"></p></blockquote><h4 id="题解：递归-1"><a href="#题解：递归-1" class="headerlink" title="题解：递归"></a>题解：递归</h4><ul><li>遇到不相等的节点返回<code>false</code></li><li>如果两个节点都为<code>null</code>，返回<code>true</code></li><li>如果只有一个节点为<code>null</code>，那肯定不是对称二叉树，返回<code>false</code></li><li>递归时判断的两个节点也有要求，怎么判断对称呢？<ul><li>左子树左节点跟右子树右节点比较</li><li>左子树右节点跟右子树左节点比较</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 根节点为null, 返回true</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 递归遍历左右子树</span><br>    <span class="hljs-keyword">return</span> dfs(root.left, root.right);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>    <span class="hljs-comment">// 左节点和右节点都为空, 返回true</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 左节点和右节点有一个为空, 返回false</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 节点值不相等 返回false</span><br>    <span class="hljs-keyword">if</span> (left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 判断 left节点的左节点和right的右节点 并且 left的右节点和right的左节点 是否对称</span><br>    <span class="hljs-keyword">return</span> dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">https://leetcode.cn/problems/merge-two-binary-trees/description/</a></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108138.png" alt="image-20230514184148616"></p></blockquote><h4 id="题解：递归-树的构建"><a href="#题解：递归-树的构建" class="headerlink" title="题解：递归+树的构建"></a>题解：递归+树的构建</h4><p>【建议背着】：递归构建树的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>    <span class="hljs-comment">// 遇到null，直接赋值另一个节点</span><br>    <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>    <span class="hljs-comment">// 都不是null相加构建一个新节点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">merge</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root1.val + root2.val);<br>    <span class="hljs-comment">// 构建新节点的左子树，对应的root1和root2的左子树</span><br>    merge.left = mergeTrees(root1.left, root2.left);<br>    <span class="hljs-comment">// 构建新节点的右子树，对应的root1和root2的右子树</span><br>    merge.right = mergeTrees(root1.right, root2.right);<br>    <span class="hljs-keyword">return</span> merge;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/">https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/</a></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108009.png" alt="image-20230514184616170"></p></blockquote><h4 id="题解一：递归-1"><a href="#题解一：递归-1" class="headerlink" title="题解一：递归"></a>题解一：递归</h4><p>深度优先搜索：递归交换左右子树节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root.left;<br>    <span class="hljs-comment">// 左右子树节点交换</span><br>    root.left = mirrorTree(root.right);<br>    root.right = mirrorTree(tmp);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：广度优先搜索-1"><a href="#题解二：广度优先搜索-1" class="headerlink" title="题解二：广度优先搜索"></a>题解二：广度优先搜索</h4><p>层序遍历交换左右节点，每次交换后，子树节点都被交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree2</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        <span class="hljs-comment">// 这里交换完node后，node的子树都被交换位置了</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.left;<br>        node.left = node.right;<br>        node.right = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li><p>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</p></li><li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108015.png" alt="image-20230514185014977"></p></li></ul></blockquote><h4 id="题解：中序遍历"><a href="#题解：中序遍历" class="headerlink" title="题解：中序遍历"></a>题解：中序遍历</h4><p><strong>二叉搜索树中序遍历是个有序数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个最小值</span><br><span class="hljs-type">long</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><span class="hljs-comment">// 默认是二叉搜索树</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    isValidBST(root.left);<br>    <span class="hljs-comment">// 根据二叉搜索树中序遍历是个有序数组的性质，可以在遍历过程中比较是否有序来判断</span><br>    <span class="hljs-keyword">if</span> (tmp &gt;= root.val) &#123;<br>        res = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将当前值保留与下一次比较</span><br>    tmp = root.val;<br>    isValidBST(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a>剑指 Offer 55 - II. 平衡二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/">https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/</a></p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108655.png" alt="image-20230514185146136"></p></blockquote><h4 id="题解：递归-2"><a href="#题解：递归-2" class="headerlink" title="题解：递归"></a>题解：递归</h4><p><strong>思路</strong>：主要思路就是判断左右子树深度相差值是否大于1，遍历每个节点，获取该节点左右子树的深度比较，如果小于等于1，则继续遍历该节点子树判断是否左右子树节点都满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果当前节点左右子树深度相差小于等于1，则说明是平衡二叉树</span><br>    <span class="hljs-keyword">if</span> (Math.abs(getHeight(root.left) - getHeight(root.right)) &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 接着递归遍历子节点, 并且左右子节点都要满足条件</span><br>        <span class="hljs-keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取左右子树中最大深度</span><br><span class="hljs-comment">     * 跳出递归条件: root=null, 深度返回0</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取当前节点左右子树深度最大值</span><br>    <span class="hljs-keyword">return</span> Math.max(getHeight(root.left) + <span class="hljs-number">1</span>, getHeight(root.right) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108209.png" alt="image-20230514185512678"></p></blockquote><h4 id="题解：递归-3"><a href="#题解：递归-3" class="headerlink" title="题解：递归"></a>题解：递归</h4><p><strong>思路</strong>：</p><ul><li>二叉搜索树性质: 左子树都小于root, 右子树都大于root</li><li>根据上面性质，如果要找最近公共祖先节点，则该节点一定大于左子树，小于右子树<ul><li>如果两个节点都大于root节点，则说明公共祖先在右子树，递归右子树即可</li><li>如果两个节点都小于root节点，则说明公共祖先在左子树，递归左子树即可</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 当前节点值大于p、q，说明公共节点在左子树</span><br>    <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>    &#125;<br><br>    <span class="hljs-comment">// // 当前节点值小于p、q，说明公共节点在右子树</span><br>    <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a>剑指 Offer 37. 序列化二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/">https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/</a></p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示：</strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode-cn.com/hc/kb/article/1567641/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p> <img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108752.png" alt="image-20230514185732869"></p></blockquote><h4 id="题解：构建二叉树"><a href="#题解：构建二叉树" class="headerlink" title="题解：构建二叉树"></a>题解：构建二叉树</h4><p><strong>思路</strong>：这道题挺开放的，序列化方法可以自定义一个，感觉<strong>主要考点是如何构造树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Encodes a tree to a single string. 递归将数节点转为string</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 遇到空节点存为&quot;null&quot;</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null,&quot;</span>;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> root.val + <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-comment">// 递归前序遍历</span><br>    res += serialize(root.left);<br>    res += serialize(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// Decodes your encoded data to tree.</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>    <span class="hljs-comment">// 先将节点解析出来存到队列中</span><br>    String[] split = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String str : split) &#123;<br>        queue.offer(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> deserialize(queue);<br>&#125;<br><br><br><span class="hljs-comment">// 主要方法在这里，如何构造树</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Queue&lt;String&gt; queue)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> queue.poll();<br>    <span class="hljs-comment">// &quot;null&quot;节点对应数的空节点，所以返回null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;null&quot;</span>.equals(val)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先序构造一颗树</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(val));<br>    treeNode.left = deserialize(queue);<br>    treeNode.right = deserialize(queue);<br>    <span class="hljs-keyword">return</span> treeNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109837.png" alt="image-20230514190009364"></p></blockquote><h4 id="题解：根据先序和中序构建二叉树"><a href="#题解：根据先序和中序构建二叉树" class="headerlink" title="题解：根据先序和中序构建二叉树"></a>题解：根据先序和中序构建二叉树</h4><p><strong>思路</strong>：</p><p>preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</p><ol><li><p>先从前序遍历获取树的根节点，在中序遍历中根据根节点可以判断该根节点的左右子树节点以及个数</p></li><li><p>根据上一步获得的左右子树个数，可以获取前序遍历中该根节点的左右子树个数</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> preorder.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        map.put(inorder[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buildTree(preorder, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, map);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> preorder 前序遍历数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startPreOrder 当前根节点对应的子树节点在前序数组中的起始下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endPreOrder 当前根节点对应的子树节点在前序数组中的终止下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inorder 中序遍历数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startInOrder 当前根节点对应的子树节点在中序数组中的起始下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endInOrder 当前根节点对应的子树节点在中序数组中的终止下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 中序数组节点和下标映射关系，方便获取节点在中序中的位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> startPreOrder, <span class="hljs-type">int</span> endPreOrder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> startInOrder, <span class="hljs-type">int</span> endInOrder, Map&lt;Integer, Integer&gt; map)</span> &#123;<br>    <span class="hljs-comment">// 判断边界</span><br>    <span class="hljs-keyword">if</span> (startPreOrder &gt; endPreOrder) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从先序遍历中获取根节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[startPreOrder];<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>    <span class="hljs-comment">// 如果先序遍历节点是最后一个</span><br>    <span class="hljs-keyword">if</span> (startPreOrder != endPreOrder) &#123;<br>        <span class="hljs-comment">// 获取根节点在中序遍历中的下标index</span><br>        <span class="hljs-comment">// [startInOrder, index-1]是当前root的左子树</span><br>        <span class="hljs-comment">// [index+1, endInOrder]是当前root的右子树</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(rootVal);<br>        <span class="hljs-comment">// 计算前序遍历中左右子树分界线</span><br>        <span class="hljs-comment">// 根据节点在中序遍历中的位置可以确定该节点左右子树的节点个数</span><br>        <span class="hljs-comment">// 然后在前序遍历中根据左右子树个数把前序遍历分成左右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNodes</span> <span class="hljs-operator">=</span> index - startInOrder;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightNodes</span> <span class="hljs-operator">=</span> endInOrder - index - <span class="hljs-number">1</span>;<br>        root.left = buildTree(preorder, startPreOrder + <span class="hljs-number">1</span>, startPreOrder + leftNodes, inorder, startInOrder, index - <span class="hljs-number">1</span>, map);<br>        root.right = buildTree(preorder, endPreOrder - rightNodes, endPreOrder, inorder, index + <span class="hljs-number">1</span>, endInOrder, map);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-046-二叉树的右侧视图"><a href="#剑指-Offer-II-046-二叉树的右侧视图" class="headerlink" title="剑指 Offer II 046. 二叉树的右侧视图"></a>剑指 Offer II 046. 二叉树的右侧视图</h2><blockquote><p><a href="https://leetcode.cn/problems/WNC0Lk/">https://leetcode.cn/problems/WNC0Lk/</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109027.png" alt="image-20230515125911354" style="zoom:50%;" /></blockquote><h4 id="题解：层序遍历"><a href="#题解：层序遍历" class="headerlink" title="题解：层序遍历"></a>题解：层序遍历</h4><p><strong>思路</strong>：层序遍历每层最后一个节点就是右视图看到的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-comment">// 如果是队列最后一个则添加到结果集中</span><br>            <span class="hljs-keyword">if</span> (i == size - <span class="hljs-number">1</span>) &#123;<br>                res.add(node.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h2><blockquote><p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/?favorite=xb9nqhhg</a></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong>2 &lt;&#x3D; n &lt;&#x3D; 100000</p></blockquote><h3 id="题解一：-集合Set"><a href="#题解一：-集合Set" class="headerlink" title="题解一： 集合Set"></a>题解一： 集合Set</h3><p>使用集合记录数组各个数字，遇到重复数字直接返回。</p><blockquote><p>时间复杂度：O(n)，Set查找元素O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(num)) &#123;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：-原地交换数字"><a href="#题解二：-原地交换数字" class="headerlink" title="题解二： 原地交换数字"></a>题解二： 原地交换数字</h3><ol><li><p>遍历数组 nums ，设索引初始值为 i&#x3D;0 :</p><ul><li><p>若 <code>nums[i]=i</code>，说明此数字已在对应索引位置，无需交换，因此跳过；</p></li><li><p>若 <code>nums[nums[i]]=nums[i]</code>， 说明索引<code>nums[i]</code>处和索引<code>i</code>处的元素值都为<code>nums[i]</code>，即找到一组重复值；</p></li><li><p>否则，交换索引<code>i</code>和索引<code>nums[i]</code>的元素值，将此数字交换置对应索引位置。</p></li></ul></li><li><p>若遍历完未返回，返回-1.</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == i) &#123;<br>            i++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i]]) &#123;<br>            <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 交换位置，直到nums[i] = i</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[tmp];<br>        nums[tmp] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h2><blockquote><p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg</a></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,   4,  7, 11, 15]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,   5,  8, 12, 19]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[3,   6,  9, 16, 22]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[10, 13, 14, 17, 24]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[18, 21, 23, 26, 30]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。</p><p>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p></blockquote><h3 id="题解一：二分查找"><a href="#题解一：二分查找" class="headerlink" title="题解一：二分查找"></a>题解一：二分查找</h3><p>由于矩阵的行和列都是有序的，所以可以遍历行或者列使用二分查找来判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = ints.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (ints[index] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ints[index] &lt; target) &#123;<br>                l++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ints[index] &gt; target) &#123;<br>                r--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：-二叉搜索树思想（消去行列）"><a href="#题解二：-二叉搜索树思想（消去行列）" class="headerlink" title="题解二： 二叉搜索树思想（消去行列）"></a>题解二： 二叉搜索树思想（消去行列）</h3><p>如下图所示：将矩阵逆时针旋转，可以发现其类似于<strong>二叉搜索树</strong>。即每个元素，左分支元素更小，右分支元素更大。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110518.png" alt="image-20230316132855942" style="zoom:50%;" /><p>因此，以左下角元素或者右上角元素为基础<code>flag</code>，则有：</p><ul><li>若<code>target &lt; flag</code>：则<code>target</code>一定在<code>flag</code>所在行的上面，这样<code>flag</code>所在<strong>行</strong>就可以消除。</li><li>若<code>target &gt; flag</code>：则<code>target</code>一定在<code>flag</code>所在列的右方，这样<code>flag</code>所在<strong>列</strong>就可以消除。</li></ul><p>复杂度分析：</p><ul><li>时间复杂度：<code>O(M + N)</code>，M和N为矩阵行数和列数</li><li>空间复杂度：<code>O(1)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 从左下角元素开始</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) &#123;<br>            <span class="hljs-comment">// target一定在matrix[i][j]上方，消除行</span><br>            i--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;<br>            <span class="hljs-comment">// target一定在matrix[i][j]右方，消除列</span><br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/?favorite=xb9nqhhg</a></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p>【示例】：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：s = <span class="hljs-string">&quot;We are happy.&quot;</span><br>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：直接调用replace方法"><a href="#题解一：直接调用replace方法" class="headerlink" title="题解一：直接调用replace方法"></a>题解一：直接调用replace方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：遍历替换"><a href="#题解二：遍历替换" class="headerlink" title="题解二：遍历替换"></a>题解二：遍历替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sb.append(ch);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><blockquote><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/?favorite=xb9nqhhg</a></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：普通遍历"><a href="#题解：普通遍历" class="headerlink" title="题解：普通遍历"></a>题解：普通遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        res.add(head.val);<br>        head = head.next;<br>    &#125;<br>    Collections.reverse(res);<br>    <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a>剑指 Offer 51. 数组中的逆序对</h2><blockquote><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/</a></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,5,6,4]</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：归并排序"><a href="#题解一：归并排序" class="headerlink" title="题解一：归并排序"></a>题解一：归并排序</h3><p><strong>思路</strong>：求逆序对跟归并排序有啥关系？？？</p><p><strong>归并排序和逆序对关系</strong>，比如下面例子：</p><p>假设有两个已排序的序列等待合并，<code>L=&#123;8,12,16,22,100&#125;  R=&#123;9,26,55,64,91&#125;</code>。开始我们用指针 <code>lPtr = 0</code> 指向 L 的首部，<code>rPtr = 0</code> 指向 R 的头部。记已经合并好的部分为M。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">L = [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>, <span class="hljs-number">100</span>]   R = [<span class="hljs-number">9</span>, <span class="hljs-number">26</span>, <span class="hljs-number">55</span>, <span class="hljs-number">64</span>, <span class="hljs-number">91</span>]  M = []<br>     |                          |<br>   lPtr                       rPtr<br></code></pre></td></tr></table></figure><p>发现<code>lPtr</code>指向的元素小于<code>rPtr</code>指向的元素，于是把<code>lPtr</code>指向的元素放入M，并把<code>lPtr</code>向后移一位。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">L = [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>, <span class="hljs-number">100</span>]   R = [<span class="hljs-number">9</span>, <span class="hljs-number">26</span>, <span class="hljs-number">55</span>, <span class="hljs-number">64</span>, <span class="hljs-number">91</span>]  M = [<span class="hljs-number">8</span>]<br>        |                       |<br>      lPtr                     rPtr<br></code></pre></td></tr></table></figure><p>这时把8放入答案，但是发现右边没有数比8小，所以8对逆序对总数【贡献】为0。</p><p>继续合并，<strong>此时发现<code>lPtr</code>所指的位置比<code>rPtr</code>大，由于归并排序每个子数组都是有序的，则对于<code>rPtr</code>而言，<code>lPtr</code>右侧的所有数都比它大，即<code>lPtr</code>右侧每个数都能和<code>rPtr</code>构成一个逆序对。贡献为<code>mid - lPtr + 1</code>。</strong></p><hr><p>利用上述思路，可以在归并的过程中计算逆序对的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.res = <span class="hljs-number">0</span>;<br>        mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            mergeSort(nums, left, mid);<br>            mergeSort(nums, mid + <span class="hljs-number">1</span>, right);<br>            merge(nums, left, mid, right);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                tmp[k++] = nums[j++];<br>                <span class="hljs-comment">// 右边当前值比左边当前值都要小，则右边当前值对于左边剩余部分的mid-i+1个数都是逆序</span><br>                res += (mid - i + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 左边当前值小于右边当前值, 不是逆序</span><br>                tmp[k++] = nums[i++];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            tmp[k++] = nums[i++];<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            tmp[k++] = nums[j++];<br>        &#125;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; t &lt; tmp.length; t++)&#123;<br>            nums[left + t] = tmp[t];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 </p><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：二分查找"><a href="#题解：二分查找" class="headerlink" title="题解：二分查找"></a>题解：二分查找</h3><p><strong>思路</strong>:</p><p>以数组最右侧的元素x为参考比较：<strong>在最小值右侧的元素，一定小于等于x；在最小值左侧的元素，一定大于等于x。</strong></p><p>以<code>mid</code>为中点，左边界为<code>low</code>，右边界为<code>high</code>。然后将中值元素和<code>nums[high]</code>比较：</p><ul><li>如果<code>nums[mid] &lt; nums[high]</code>：则<code>nums[mid]</code>是最小值右侧元素，二分查找可以忽略右边部分，即<code>right = mid</code>；</li><li>如果<code>nums[mid] &gt; nums[high]</code>：则<code>nums[mid]</code>是最小值左侧元素，二分查找可以忽略左侧部分，即<code>left = mid + 1</code>；</li><li>如果<code>nums[mid] == nums[high]</code>：则不能判断<code>nums[mid]</code>在最小值左侧还是右侧，但不管<code>nums[high]</code>是不是最小值，都有一个值替代它，所以忽略该值即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> numbers.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 为什么以right处元素为参考？</span><br>        <span class="hljs-comment">// right处元素一定小于或等于0位置元素, 比right处还小的元素一定在最小值和right处元素之间，比right处大的元素一定在0到最小值之间</span><br>        <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;<br>            <span class="hljs-comment">// 说明nums[mid]在最小值右侧, 则right-mid这部分可以丢弃</span><br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right])&#123;<br>            <span class="hljs-comment">// 说明nums[mid]在最小值左侧, 则left~mid这部分可以丢弃</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果相等，则不能确定在最小值左侧还是右侧，但是可以忽略这个相等值</span><br>            right -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numbers[right];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h2><blockquote><p><a href="https://leetcode.cn/problems/compare-version-numbers/description/">https://leetcode.cn/problems/compare-version-numbers/description/</a></p><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.01&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.001&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：忽略前导零，<span class="hljs-string">&quot;01&quot;</span> 和 <span class="hljs-string">&quot;001&quot;</span> 都表示相同的整数 <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.0&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.0.0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：versio<span class="hljs-symbol">n1</span> 没有指定下标为 <span class="hljs-number">2</span> 的修订号，即视为 <span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;0.1&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.1&quot;</span><br>输出：<span class="hljs-number">-1</span><br>解释：versio<span class="hljs-symbol">n1</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;0&quot;</span>，versio<span class="hljs-symbol">n2</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;1&quot;</span> 。<span class="hljs-number">0</span> &lt; <span class="hljs-number">1</span>，所以 versio<span class="hljs-symbol">n1</span> &lt; versio<span class="hljs-symbol">n2</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：字符串分割"><a href="#题解一：字符串分割" class="headerlink" title="题解一：字符串分割"></a>题解一：字符串分割</h3><p><strong>思路</strong>：</p><ul><li>由于需要忽略前导零，所以以<code>.</code>为分隔符拆分，利用<code>Integer.parseInt()</code>的特性可以直接将前导零消除，将字符串转为数字。</li><li>为了优化代码结构，初始默认值设为0，这样后面不用再分别判断某一边剩余情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareVersion</span><span class="hljs-params">(String version1, String version2)</span> &#123;<br>    String[] split1 = version1.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    String[] split2 = version2.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; split1.length || j &lt; split2.length) &#123;<br>        <span class="hljs-comment">// 这里赋默认值为0：当某一version分割后数组长度短时，需要继续对另一个version进行判断，就和0比较</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, v2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; split1.length) &#123;<br>            v1 = Integer.parseInt(split1[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j &lt; split2.length) &#123;<br>            v2 = Integer.parseInt(split2[j]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (v1 &gt; v2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1 &lt; v2) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用算法积累</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="排序算法时间复杂度"><a href="#排序算法时间复杂度" class="headerlink" title="排序算法时间复杂度"></a>排序算法时间复杂度</h2><ul><li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107305.png" alt="img"></p><p><strong>图片名词解释：</strong></p><ul><li><code>n</code>: 数据规模</li><li><code>k</code>: “桶”的个数</li><li><code>In-place</code>: 占用常数内存，不占用额外内存</li><li><code>Out-place</code>: 占用额外内存</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107123.jpg" alt="img"></p><h1 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h2><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 冒泡排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-keyword">if</span> (array.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> array;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)<br>                <span class="hljs-keyword">if</span> (array[j + <span class="hljs-number">1</span>] &lt; array[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>                    array[j + <span class="hljs-number">1</span>] = array[j];<br>                    array[j] = temp;<br>                &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-算法分析"><a href="#2-3-算法分析" class="headerlink" title="2.3 算法分析"></a>2.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：当输入的数据是反序时</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：当输入的数据已经有序时，只需遍历一遍用于确认数据已有序。</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h1><p>工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-算法分析"><a href="#3-3-算法分析" class="headerlink" title="3.3 算法分析"></a>3.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最坏时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最好时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>不稳定</code></strong></li></ul><h1 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h1><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h2><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        arr[preIndex + <span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-算法分析"><a href="#4-3-算法分析" class="headerlink" title="4.3 算法分析"></a>4.3 算法分析</h2><ul><li><strong>-平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：输入数组按降序排列（完全逆序）</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：输入数组按升序排列（基本有序）</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性：<code>稳定</code></strong></li></ul><h2 id="4-4-改进方法"><a href="#4-4-改进方法" class="headerlink" title="4.4 改进方法"></a>4.4 改进方法</h2><p>改进思路一：查找插入位置时使用二分查找的方式，减少比较次数。</p><h1 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h1><p><strong>该方法实质上是一种分组插入方法</strong>，希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ul><h2 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107634.png" alt="img"></p><h2 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            temp = arr[i];<br>            <span class="hljs-comment">// 寻找前面已排序队列中比temp大的，向后移动，这里和插入排序一直，只是间距不一样</span><br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; temp) &#123;<br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap; <br>            &#125;<br>            arr[preIndex + gap] = temp;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-算法分析"><a href="#5-2-算法分析" class="headerlink" title="5.2 算法分析"></a>5.2 算法分析</h2><ul><li><p><strong>平均时间复杂度：<code>T(n) = O(n^1.5)</code></strong></p></li><li><p><strong>最坏时间复杂度：<code>T(n) = O(nlog²n）</code></strong></p></li><li><p><strong>空间复杂度: <code>O(1)</code></strong></p></li><li><p>**稳定性: <code>不稳定</code>**，由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p></li></ul><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h2 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h2><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>        mergeSort(arr, low, mid);<br>        mergeSort(arr, mid + <span class="hljs-number">1</span>, high);<br>        merge(arr, low, mid, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high - low + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> low;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= high) &#123;<br>        <span class="hljs-keyword">if</span> (arr[left] &lt; arr[right]) &#123;<br>            help[index++] = arr[left++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            help[index++] = arr[right++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= mid) &#123;<br>        help[index++] = arr[left++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (right &lt;= high) &#123;<br>        help[index++] = arr[right++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>        arr[low + i] = help[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-算法分析"><a href="#6-3-算法分析" class="headerlink" title="6.3 算法分析"></a>6.3 算法分析</h2><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(n)</code></strong></li><li>**空间复杂度: <code>O(n)</code>**，归并排序需要一个与原数组相同长度的数组做辅助来排序</li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7. 快速排序"></a>7. 快速排序</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h2 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h2 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> partition(arr, low, high);<br>        quickSort(arr, low, mid - <span class="hljs-number">1</span>);<br>        quickSort(arr, mid + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= key) &#123;<br>            high--;<br>        &#125;<br>        swap(arr, low, high);<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= key) &#123;<br>            low++;<br>        &#125;<br>        swap(arr, low, high);<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-算法分析"><a href="#7-3-算法分析" class="headerlink" title="7.3 算法分析"></a>7.3 算法分析</h2><ul><li>**最佳情况：<code>T(n) = O(nlogn)</code>**，快速排序最优的情况就是每一次取到的元素都刚好平分整个数组</li><li>**最差情况：<code>T(n) = O(n²)</code>**，最差的情况就是每一次取到的元素就是数组中最小&#x2F;最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)</li><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8. 堆排序"></a>8. 堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h2 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h2><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h2 id="8-2-代码实现"><a href="#8-2-代码实现" class="headerlink" title="8.2 代码实现"></a>8.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (arr.length / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        adjust(arr, i, arr.length);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        swap(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> -i);<br>        adjust(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> - i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjust</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bigIndex</span> <span class="hljs-operator">=</span> index;<br><br>    <span class="hljs-keyword">if</span> (leftIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[leftIndex]) &#123;<br>        bigIndex = leftIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (rightIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[rightIndex]) &#123;<br>        bigIndex = rightIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bigIndex != index) &#123;<br>        swap(arr, index, bigIndex);<br>        adjust(arr, bigIndex, len);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-算法分析"><a href="#8-3-算法分析" class="headerlink" title="8.3 算法分析"></a>8.3 算法分析</h2><p><strong>调堆：O(h)</strong><br><strong>建堆：O(n)</strong><br><strong>循环调堆：O(nlogn)</strong><br>总运行时间<code>T(n) = O(nlogn) + O(n) = O(nlogn)</code>。对于堆排序的最好情况与最坏情况的运行时间，因为最坏与最好的输入都只是影响建堆的运行时间O(1)或者O(n)，而在总体时间中占重要比例的是循环调堆的过程，即O(nlogn) + O(1) &#x3D;O(nlogn) + O(n) &#x3D; O(nlogn)。因此最好或者最坏情况下，堆排序的运行时间都是O(nlogn)。而且堆排序还是 <a href="http://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地算法（in-place algorithm）</a> 。</p><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>空间复杂度：<code>O(1)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="9-计数排序"><a href="#9-计数排序" class="headerlink" title="9. 计数排序"></a>9. 计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h2 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h2><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h2 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] countSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>            max = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>            min = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - min + <span class="hljs-number">1</span>];<br>    Arrays.fill(bucket, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> - min;      <span class="hljs-comment">// 防止数组中有负数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        bucket[arr[i] + ans]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; arr.length) &#123;<br>        <span class="hljs-keyword">if</span> (bucket[i] != <span class="hljs-number">0</span>) &#123;<br>            arr[index] = i - ans;<br>            bucket[i]--;    <span class="hljs-comment">// 该数值个数减1</span><br>            index++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-3-算法分析"><a href="#9-3-算法分析" class="headerlink" title="9.3 算法分析"></a>9.3 算法分析</h2><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k)  **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n+k)</strong></p></li></ul><h1 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10. 桶排序"></a>10. 桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h2 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h2><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize&#x3D;&#x3D;5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107423.png" alt="img"></p><h2 id="10-2-代码实现"><a href="#10-2-代码实现" class="headerlink" title="10.2 代码实现"></a>10.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 桶排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketSize</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">BucketSort</span><span class="hljs-params">(ArrayList&lt;Integer&gt; array, <span class="hljs-type">int</span> bucketSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.size() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>), min = array.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 找到最大值最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (array.get(i) &gt; max)<br>            max = array.get(i);<br>        <span class="hljs-keyword">if</span> (array.get(i) &lt; min)<br>            min = array.get(i);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(bucketCount);<br>    ArrayList&lt;Integer&gt; resultArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (bucketSize == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketArr.get(i).size(); j++)<br>                resultArr.add(bucketArr.get(i).get(j));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (bucketCount == <span class="hljs-number">1</span>)<br>                bucketSize--;<br>            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; temp.size(); j++)<br>                resultArr.add(temp.get(j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultArr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-3-算法分析"><a href="#10-3-算法分析" class="headerlink" title="10.3 算法分析"></a>10.3 算法分析</h2><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k) **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n2)</strong></p></li></ul><p>　　</p><h1 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11. 基数排序"></a>11. 基数排序</h1><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h2 id="11-1-算法描述"><a href="#11-1-算法描述" class="headerlink" title="11.1 算法描述"></a>11.1 算法描述</h2><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h2 id="11-2-代码实现"><a href="#11-2-代码实现" class="headerlink" title="11.2 代码实现"></a>11.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基数排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] RadixSort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-comment">// 1.先算出最大数的位数；</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>        max = Math.max(max, array[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDigit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>        max /= <span class="hljs-number">10</span>;<br>        maxDigit++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, div = <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        bucketList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigit; i++, mod *= <span class="hljs-number">10</span>, div *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (array[j] % mod) / div;<br>            bucketList.get(num).add(array[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketList.size(); j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; bucketList.get(j).size(); k++)<br>                array[index++] = bucketList.get(j).get(k);<br>            bucketList.get(j).clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-3-算法分析"><a href="#11-3-算法分析" class="headerlink" title="11.3 算法分析"></a>11.3 算法分析</h2><p><strong>最佳情况：T(n) &#x3D; O(n * k)  最差情况：T(n) &#x3D; O(n * k)  平均情况：T(n) &#x3D; O(n * k)</strong></p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序 LSD 从低位开始进行排序 </p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h1><p><strong>稳定</strong>的排序：<strong>冒泡排序，插入排序，归并排序</strong><br><strong>不稳定</strong>的排序：<strong>选择排序，堆排序，快速排序，希尔排序</strong></p><p><strong>平均</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>希尔排序，归并排序，快速排序，堆排序</strong><br><strong>平均</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序</strong></p><p><strong>最好</strong>时间复杂度<code>T(n) = O(n)</code>：<strong>冒泡排序，插入排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，快速排序，堆排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>简单选择排序</strong></p><p><strong>最坏</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，堆排序</strong><br><strong>最坏</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序，快速排序</strong></p><p>空间复杂度<code>O(1)</code>：<strong>冒泡排序，简单选择排序，插入排序，希尔排序，堆排序</strong><br>空间复杂度<code>O(n)</code>：<strong>归并排序</strong><br>空间复杂度<code>O(nlogn)</code>：<strong>快速排序</strong></p><h1 id="13-参考资料"><a href="#13-参考资料" class="headerlink" title="13. 参考资料"></a>13. 参考资料</h1><ul><li><a href="https://segmentfault.com/a/1190000021638663">https://segmentfault.com/a/1190000021638663</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法及其时间复杂度</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-排序算法时间复杂度"><a href="#1-排序算法时间复杂度" class="headerlink" title="1. 排序算法时间复杂度"></a>1. 排序算法时间复杂度</h1><ul><li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111128.png" alt="image-20230316225544936"></p><p><strong>图片名词解释：</strong></p><ul><li><code>n</code>: 数据规模</li><li><code>k</code>: “桶”的个数</li><li><code>In-place</code>: 占用常数内存，不占用额外内存</li><li><code>Out-place</code>: 占用额外内存</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111912.png" alt="image-20230316225626782"></p><h1 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h2><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 冒泡排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-keyword">if</span> (array.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> array;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)<br>                <span class="hljs-keyword">if</span> (array[j + <span class="hljs-number">1</span>] &lt; array[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>                    array[j + <span class="hljs-number">1</span>] = array[j];<br>                    array[j] = temp;<br>                &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-算法分析"><a href="#2-3-算法分析" class="headerlink" title="2.3 算法分析"></a>2.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：当输入的数据是反序时</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：当输入的数据已经有序时，只需遍历一遍用于确认数据已有序。</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h1><p>工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-算法分析"><a href="#3-3-算法分析" class="headerlink" title="3.3 算法分析"></a>3.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最坏时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最好时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>不稳定</code></strong></li></ul><h1 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h1><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h2><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        arr[preIndex + <span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-算法分析"><a href="#4-3-算法分析" class="headerlink" title="4.3 算法分析"></a>4.3 算法分析</h2><ul><li><strong>-平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：输入数组按降序排列（完全逆序）</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：输入数组按升序排列（基本有序）</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性：<code>稳定</code></strong></li></ul><h2 id="4-4-改进方法"><a href="#4-4-改进方法" class="headerlink" title="4.4 改进方法"></a>4.4 改进方法</h2><p>改进思路一：查找插入位置时使用二分查找的方式，减少比较次数。</p><h1 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h1><p><strong>该方法实质上是一种分组插入方法</strong>，希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ul><h2 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111680.png" alt="img"></p><h2 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            temp = arr[i];<br>            <span class="hljs-comment">// 寻找前面已排序队列中比temp大的，向后移动，这里和插入排序一直，只是间距不一样</span><br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; temp) &#123;<br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap; <br>            &#125;<br>            arr[preIndex + gap] = temp;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-算法分析"><a href="#5-2-算法分析" class="headerlink" title="5.2 算法分析"></a>5.2 算法分析</h2><ul><li><p><strong>平均时间复杂度：<code>T(n) = O(n^1.5)</code></strong></p></li><li><p><strong>最坏时间复杂度：<code>T(n) = O(nlog²n）</code></strong></p></li><li><p><strong>空间复杂度: <code>O(1)</code></strong></p></li><li><p>**稳定性: <code>不稳定</code>**，由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p></li></ul><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h2 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h2><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>        mergeSort(arr, low, mid);<br>        mergeSort(arr, mid + <span class="hljs-number">1</span>, high);<br>        merge(arr, low, mid, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high - low + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> low;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= high) &#123;<br>        <span class="hljs-keyword">if</span> (arr[left] &lt; arr[right]) &#123;<br>            help[index++] = arr[left++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            help[index++] = arr[right++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= mid) &#123;<br>        help[index++] = arr[left++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (right &lt;= high) &#123;<br>        help[index++] = arr[right++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>        arr[low + i] = help[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-算法分析"><a href="#6-3-算法分析" class="headerlink" title="6.3 算法分析"></a>6.3 算法分析</h2><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(n)</code></strong></li><li>**空间复杂度: <code>O(n)</code>**，归并排序需要一个与原数组相同长度的数组做辅助来排序</li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7. 快速排序"></a>7. 快速排序</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h2 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h2 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> partition(arr, low, high);<br>        quickSort(arr, low, mid - <span class="hljs-number">1</span>);<br>        quickSort(arr, mid + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= key) &#123;<br>            high--;<br>        &#125;<br>        swap(arr, low, high);<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= key) &#123;<br>            low++;<br>        &#125;<br>        swap(arr, low, high);<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-算法分析"><a href="#7-3-算法分析" class="headerlink" title="7.3 算法分析"></a>7.3 算法分析</h2><ul><li>**最佳情况：<code>T(n) = O(nlogn)</code>**，快速排序最优的情况就是每一次取到的元素都刚好平分整个数组</li><li>**最差情况：<code>T(n) = O(n²)</code>**，最差的情况就是每一次取到的元素就是数组中最小&#x2F;最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)</li><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8. 堆排序"></a>8. 堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h2 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h2><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h2 id="8-2-代码实现"><a href="#8-2-代码实现" class="headerlink" title="8.2 代码实现"></a>8.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (arr.length / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        adjust(arr, i, arr.length);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        swap(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> -i);<br>        adjust(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> - i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjust</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bigIndex</span> <span class="hljs-operator">=</span> index;<br><br>    <span class="hljs-keyword">if</span> (leftIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[leftIndex]) &#123;<br>        bigIndex = leftIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (rightIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[rightIndex]) &#123;<br>        bigIndex = rightIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bigIndex != index) &#123;<br>        swap(arr, index, bigIndex);<br>        adjust(arr, bigIndex, len);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-算法分析"><a href="#8-3-算法分析" class="headerlink" title="8.3 算法分析"></a>8.3 算法分析</h2><p><strong>调堆：O(h)</strong><br><strong>建堆：O(n)</strong><br><strong>循环调堆：O(nlogn)</strong><br>总运行时间<code>T(n) = O(nlogn) + O(n) = O(nlogn)</code>。对于堆排序的最好情况与最坏情况的运行时间，因为最坏与最好的输入都只是影响建堆的运行时间O(1)或者O(n)，而在总体时间中占重要比例的是循环调堆的过程，即O(nlogn) + O(1) &#x3D;O(nlogn) + O(n) &#x3D; O(nlogn)。因此最好或者最坏情况下，堆排序的运行时间都是O(nlogn)。而且堆排序还是 <a href="http://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地算法（in-place algorithm）</a> 。</p><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>空间复杂度：<code>O(1)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="9-计数排序"><a href="#9-计数排序" class="headerlink" title="9. 计数排序"></a>9. 计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h2 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h2><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h2 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] countSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>            max = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>            min = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - min + <span class="hljs-number">1</span>];<br>    Arrays.fill(bucket, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> - min;      <span class="hljs-comment">// 防止数组中有负数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        bucket[arr[i] + ans]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; arr.length) &#123;<br>        <span class="hljs-keyword">if</span> (bucket[i] != <span class="hljs-number">0</span>) &#123;<br>            arr[index] = i - ans;<br>            bucket[i]--;    <span class="hljs-comment">// 该数值个数减1</span><br>            index++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-3-算法分析"><a href="#9-3-算法分析" class="headerlink" title="9.3 算法分析"></a>9.3 算法分析</h2><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k)  **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n+k)</strong></p></li></ul><h1 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10. 桶排序"></a>10. 桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h2 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h2><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize&#x3D;&#x3D;5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111683.png" alt="img"></p><h2 id="10-2-代码实现"><a href="#10-2-代码实现" class="headerlink" title="10.2 代码实现"></a>10.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 桶排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketSize</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">BucketSort</span><span class="hljs-params">(ArrayList&lt;Integer&gt; array, <span class="hljs-type">int</span> bucketSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.size() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>), min = array.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 找到最大值最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (array.get(i) &gt; max)<br>            max = array.get(i);<br>        <span class="hljs-keyword">if</span> (array.get(i) &lt; min)<br>            min = array.get(i);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(bucketCount);<br>    ArrayList&lt;Integer&gt; resultArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (bucketSize == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketArr.get(i).size(); j++)<br>                resultArr.add(bucketArr.get(i).get(j));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (bucketCount == <span class="hljs-number">1</span>)<br>                bucketSize--;<br>            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; temp.size(); j++)<br>                resultArr.add(temp.get(j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultArr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-3-算法分析"><a href="#10-3-算法分析" class="headerlink" title="10.3 算法分析"></a>10.3 算法分析</h2><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k) **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n2)</strong></p></li></ul><p>　　</p><h1 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11. 基数排序"></a>11. 基数排序</h1><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h2 id="11-1-算法描述"><a href="#11-1-算法描述" class="headerlink" title="11.1 算法描述"></a>11.1 算法描述</h2><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h2 id="11-2-代码实现"><a href="#11-2-代码实现" class="headerlink" title="11.2 代码实现"></a>11.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基数排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] RadixSort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-comment">// 1.先算出最大数的位数；</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>        max = Math.max(max, array[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDigit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>        max /= <span class="hljs-number">10</span>;<br>        maxDigit++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, div = <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        bucketList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigit; i++, mod *= <span class="hljs-number">10</span>, div *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (array[j] % mod) / div;<br>            bucketList.get(num).add(array[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketList.size(); j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; bucketList.get(j).size(); k++)<br>                array[index++] = bucketList.get(j).get(k);<br>            bucketList.get(j).clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-3-算法分析"><a href="#11-3-算法分析" class="headerlink" title="11.3 算法分析"></a>11.3 算法分析</h2><p><strong>最佳情况：T(n) &#x3D; O(n * k)  最差情况：T(n) &#x3D; O(n * k)  平均情况：T(n) &#x3D; O(n * k)</strong></p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序 LSD 从低位开始进行排序 </p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h1><p><strong>稳定</strong>的排序：<strong>冒泡排序，插入排序，归并排序</strong><br><strong>不稳定</strong>的排序：<strong>选择排序，堆排序，快速排序，希尔排序</strong></p><p><strong>平均</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>希尔排序，归并排序，快速排序，堆排序</strong><br><strong>平均</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序</strong></p><p><strong>最好</strong>时间复杂度<code>T(n) = O(n)</code>：<strong>冒泡排序，插入排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，快速排序，堆排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>简单选择排序</strong></p><p><strong>最坏</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，堆排序</strong><br><strong>最坏</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序，快速排序</strong></p><p>空间复杂度<code>O(1)</code>：<strong>冒泡排序，简单选择排序，插入排序，希尔排序，堆排序</strong><br>空间复杂度<code>O(n)</code>：<strong>归并排序</strong><br>空间复杂度<code>O(nlogn)</code>：<strong>快速排序</strong></p><h1 id="13-参考资料"><a href="#13-参考资料" class="headerlink" title="13. 参考资料"></a>13. 参考资料</h1><ul><li><a href="https://segmentfault.com/a/1190000021638663">https://segmentfault.com/a/1190000021638663</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><blockquote><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/">https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/</a></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：两个栈"><a href="#题解：两个栈" class="headerlink" title="题解：两个栈"></a>题解：两个栈</h4><p>初始化两个栈<code>inStack</code>和<code>outStack</code>：</p><ul><li>入栈操作：直接丢进<code>inStack</code>中</li><li>出栈操作：如果<code>outStack</code>为空，则将<code>inStack</code>元素<code>pop</code>到<code>outStack</code>中，然后从<code>outStack</code>中出栈。如果<code>outStack</code>不为空，直接出栈。因为如果<code>outStack</code>不为空，则说明上一次队列元素还没有完全出栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出栈，出队使用</span><br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; outStack;<br><span class="hljs-comment">// 输入栈，当做进入队列使用</span><br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; inStack;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>    outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-comment">// 入队直接操作入栈即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    inStack.push(value);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出队时, 如果outStack为空，则把inStack里面元素pop出放入outStack中</span><br><span class="hljs-comment">     * 如果outStack不为空，则说明上一次队列元素还没有完全出栈</span><br><span class="hljs-comment">     * 如果inStack和outStack都为空，说明队内没有元素</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (inStack.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> outStack.pop();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><blockquote><p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MinStack minStack <span class="hljs-operator">=</span> new MinStack()<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>minStack.push(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -3.</span><br>minStack.pop()<span class="hljs-comment">;</span><br>minStack.top()<span class="hljs-comment">;      --&gt; 返回 0.</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -2.</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：两个栈-1"><a href="#题解：两个栈-1" class="headerlink" title="题解：两个栈"></a>题解：两个栈</h4><p>初始化两个栈：<code>minStack</code>最小值栈，<code>stack</code>存储栈</p><ul><li>入栈时：如果最小值栈为空或者新入栈元素小于等于最小值栈顶元素，则把新元素放入最小值栈<code>minStack</code>中</li><li>出栈时：如果<code>stack</code>出栈元素刚好是最小值元素，则需要把<code>minStack</code>中的元素也出栈，保证栈一致性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">// 正常元素栈</span><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack;<br><br>    <span class="hljs-comment">// 存放最小值的栈</span><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stack.push(x);<br>        <span class="hljs-comment">// 如果最小值栈为空或者新入栈的值x比最小值栈顶元素小，将x入站</span><br>        <span class="hljs-keyword">if</span> (minStack.isEmpty() || x &lt;= minStack.peek()) &#123;<br>            minStack.push(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-comment">// 如果出栈元素是最小值元素，则minStack也需要出栈删除该最小值</span><br>        <span class="hljs-keyword">if</span> (minStack.peek() == pop) &#123;<br>            minStack.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><blockquote><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一个栈"><a href="#题解：一个栈" class="headerlink" title="题解：一个栈"></a>题解：一个栈</h4><p>遇到<code>(, &#123;, [</code>直接入栈，遇到<code>], &#125;, )</code>出栈一个元素，然后比较看是否匹配。</p><p>为了方便获取对应括号，初始化一个<code>map</code>存储括号的映射关系。</p><p>最后返回栈是否为空，因为如果括号都是匹配的，栈最后一定为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span> || ch == <span class="hljs-string">&#x27;[&#x27;</span> || ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>            stack.push(ch);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果执行到此处, stack是空, 则说明肯定是]&#125;)其中之一, 前面没有[&#123;(, 就不能匹配</span><br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span> (map.get(top) != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后避免只有[(&#123;的情况, 判断stack是否为空</span><br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h2><blockquote><p><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列大顶堆"><a href="#题解：优先队列大顶堆" class="headerlink" title="题解：优先队列大顶堆"></a>题解：优先队列大顶堆</h4><ul><li>创建一个大顶堆，用于获取滑动窗口最大值。</li><li>遍历元素，维护滑动窗口内的大顶堆状态。</li><li>大顶堆比较规则：<ul><li>如果数值相等比较下标，下标大的交换位置，因为下标小的元素可能不在本次窗口中，下标大的元素一定在本次窗口。</li><li>如果数值不等比较数值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 创建一个大顶堆，规则如下：</span><br>    <span class="hljs-comment">// 如果数值相等，则比较下标，下标大的交换位置</span><br>    <span class="hljs-comment">// 如果数值不等，则比较数值，数值大的交换位置</span><br>    <span class="hljs-comment">// int[0]表示数值，int[1]表示下标</span><br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">1</span>] : o2[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 先将前k个元素放入大顶堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i], i&#125;);<br>    &#125;<br>    <span class="hljs-comment">// 初始化返回数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 将第一个窗口k的最大值放入返回窗口</span><br>    res[<span class="hljs-number">0</span>] = priorityQueue.peek()[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 从第k个元素开始遍历，获取后面窗口最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 把新元素加入滑动窗口, 构造新的大顶堆</span><br>        <span class="hljs-comment">// 这里可能会遇到值相等但下标不同的元素，所以在初始化大顶堆时比较器要筛选下标大的那个元素</span><br>        <span class="hljs-comment">// 因为滑动窗口向后移，新加入元素下标肯定比之前大</span><br>        priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i], i&#125;);<br>        <span class="hljs-comment">// 先把大顶堆中下标小于等于i-k的清除，因为这部分元素不再滑动窗口内部</span><br>        <span class="hljs-keyword">while</span> (priorityQueue.peek()[<span class="hljs-number">1</span>] &lt;= i - k) &#123;<br>            priorityQueue.poll();<br>        &#125;<br>        <span class="hljs-comment">// 接下来大顶堆里面元素都是滑动窗口内部元素, 获取最大值即可</span><br>        res[i - k + <span class="hljs-number">1</span>] = priorityQueue.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h2><blockquote><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/</a></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[3,2,1]</span>, k = 2<br>输出：<span class="hljs-comment">[1,2]</span> 或者 <span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列小顶堆"><a href="#题解：优先队列小顶堆" class="headerlink" title="题解：优先队列小顶堆"></a>题解：优先队列小顶堆</h4><p>遍历元素放入小顶堆中，然后去前k个元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 默认创建小顶堆</span><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        pq.offer(arr[i]);<br>    &#125;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        res[i] = pq.poll();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-076-数组中的第-k-大的数字"><a href="#剑指-Offer-II-076-数组中的第-k-大的数字" class="headerlink" title="剑指 Offer II 076. 数组中的第 k 大的数字"></a>剑指 Offer II 076. 数组中的第 k 大的数字</h2><blockquote><p><a href="https://leetcode.cn/problems/xx4gT2/">https://leetcode.cn/problems/xx4gT2/</a></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列大顶堆-1"><a href="#题解：优先队列大顶堆-1" class="headerlink" title="题解：优先队列大顶堆"></a>题解：优先队列大顶堆</h4><p>将元素放入优先队列中，先<code>poll</code>出前<code>k-1</code>个元素，然后下一个元素就是第<code>k</code>大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// 建立大顶堆</span><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; (o2 - o1));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        pq.offer(num);<br>    &#125;<br>    <span class="hljs-comment">// 把前k大剔除</span><br>    <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">1</span>) &#123;<br>        pq.poll();<br>    &#125;<br>    <span class="hljs-comment">// 返回第k大</span><br>    <span class="hljs-keyword">return</span> pq.poll();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a>剑指 Offer 41. 数据流中的中位数</h2><blockquote><p><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,null,<span class="hljs-number">1.50000</span>,null,<span class="hljs-number">2.00000</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列大顶堆-小顶堆"><a href="#题解：优先队列大顶堆-小顶堆" class="headerlink" title="题解：优先队列大顶堆+小顶堆"></a>题解：优先队列大顶堆+小顶堆</h4><ul><li>创建一个大顶堆，一个小顶堆</li><li>大顶堆负责存储排序后列表的前半部分值，因为这样能直接获取前半部分最大值。</li><li>小顶堆负责存储排序后列表的后半部分值，因为这样能直接获取后半部分最小值。</li><li>添加元素时保证大顶堆元素个数和小顶堆元素个数相差不超过1。这样如果列表元素个数是奇数，则直接获取小顶堆最小值就是中位数；如果是偶数，则大小顶堆最值平均。</li><li>添加元素时要先添加到大顶堆中，然后大顶堆<code>poll</code>出的元素再添加到小顶堆中。这样保证小顶堆一定是有序列表后半部分元素，大顶堆一定是有序列表前半部分元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    PriorityQueue&lt;Integer&gt; small;<br>    PriorityQueue&lt;Integer&gt; big;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 将排序后的数据流分为两部分</span><br>        <span class="hljs-comment">// 小顶堆存储排序后大的那部分值, 这样小顶堆能直接获取大的那部分最小值</span><br>        <span class="hljs-comment">// 大顶堆存储排序后小的那部分值, 这样大顶堆能直接获取小的那部分最大值</span><br>        small = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        big = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; (o2 - o1));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        big.offer(num);<br>        small.offer(big.poll());<br>        <span class="hljs-keyword">if</span> (big.size() + <span class="hljs-number">1</span> &lt; small.size()) &#123;<br>            <span class="hljs-comment">// 如果大顶堆元素比小顶堆的少两个，则把小顶堆元素poll出来一个放入大顶堆</span><br>            <span class="hljs-comment">// 永远保证大顶堆和小顶堆元素最接近中位数</span><br>            big.offer(small.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 说明是奇数</span><br>        <span class="hljs-keyword">if</span> (small.size() &gt; big.size()) <span class="hljs-keyword">return</span> small.peek();<br>        <span class="hljs-comment">// 偶数直接去平均值</span><br>        <span class="hljs-keyword">return</span> (small.peek() + big.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-036-后缀表达式"><a href="#剑指-Offer-II-036-后缀表达式" class="headerlink" title="剑指 Offer II 036. 后缀表达式"></a>剑指 Offer II 036. 后缀表达式</h2><blockquote><p><a href="https://leetcode.cn/problems/8Zf90G/">https://leetcode.cn/problems/8Zf90G/</a></p><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求该后缀表达式的计算结果。</p><p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>]<br>输出：<span class="hljs-number">9</span><br>解释：该算式转化为常见的中缀算术表达式为：((<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：栈"><a href="#题解：栈" class="headerlink" title="题解：栈"></a>题解：栈</h4><ul><li>遇到数值则入栈</li><li>遇到操作数则出栈两个数值，然后根据操作数计算，结果再入栈</li><li>出栈两个元素后计算时注意顺序，对于<code>+和/</code>来说，后出栈在前</li><li>最后返回栈最后一个值即结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>    <span class="hljs-comment">// 数字入栈</span><br>    Stack&lt;Integer&gt; val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String str : tokens) &#123;<br>        <span class="hljs-comment">// 如果是数字则直接入栈</span><br>        <span class="hljs-keyword">if</span> (isNumber(str)) &#123;<br>            val.push(Integer.parseInt(str));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 遇到操作数则出栈两个元素</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> val.pop();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> val.pop();<br>            <span class="hljs-comment">// 记录结果值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 注意计算对于/和-来说是v2在前，v1在后，因为v2先入栈</span><br>            <span class="hljs-keyword">switch</span> (str) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                    res = v2 + v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                    res = v2 - v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                    res = v2 * v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                    res = v2 / v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br>            val.push(res);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val.pop();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈、队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-红黑树的性质"><a href="#1-红黑树的性质" class="headerlink" title="1. 红黑树的性质"></a>1. 红黑树的性质</h1><ul><li>性质1：每个节点要么是黑色，要么是红色</li><li>性质2：根节点是黑色</li><li>性质3：每个叶子节点（NIL）是黑色</li><li>性质4：每个红色节点的两个子节点一定都是黑色</li><li>性质5：<strong>任意一个节点到每个叶子节点的路径都包含相同数量的黑色节点</strong></li></ul><p>从性质5又可以推出：</p><ul><li>性质5.1：如果一个节点存在黑色子节点，那么该节点一定有两个子节点</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109210.png" alt="image-20210405215250763"></p><h1 id="2-红黑树的自平衡"><a href="#2-红黑树的自平衡" class="headerlink" title="2. 红黑树的自平衡"></a>2. 红黑树的自平衡</h1><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其<strong>右子结点</strong>变为旋转结点的父结点，<strong>右子结点的左子结点</strong>变为旋转结点的<strong>右子结点</strong>，<strong>左子结点</strong>保持不变。如图3：</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109762.png" alt="image-20210405215348761"></p><ul><li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其<strong>左子结点</strong>变为旋转结点的父结点，<strong>左子结点的右子结点</strong>变为旋转结点的<strong>左子结点</strong>，<strong>右子结点</strong>保持不变。如图4。</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109185.png" alt="image-20210405215541157"></p><ul><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul><p><strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。</p><p><strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><h1 id="3-红黑树的查找"><a href="#3-红黑树的查找" class="headerlink" title="3. 红黑树的查找"></a>3. 红黑树的查找</h1><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li><p>从根结点开始查找，把根结点设置为当前结点；</p></li><li><p>若当前结点为空，返回null；</p></li><li><p>若当前结点不为空，用当前结点的key跟查找key作比较；</p></li><li><p>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</p></li><li><p>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</p></li><li><p>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</p></li></ol><h1 id="4-红黑树的插入"><a href="#4-红黑树的插入" class="headerlink" title="4. 红黑树的插入"></a>4. 红黑树的插入</h1><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109815.png" alt="image-20210405221428584"></p><h2 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h2><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。</p><p><strong>处理：把插入结点作为根结点，并把结点设置为黑色</strong>。</p><h2 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h2><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p><strong>处理：</strong></p><ul><li><strong>把I设为当前结点的颜色</strong></li><li><strong>更新当前结点的值为插入结点的值</strong></li></ul><h2 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h2><p>由于插入的结点是红色的，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p><strong>处理：直接插入</strong>。</p><h2 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h2><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。</p><p><strong>插入情景4.1：叔叔结点存在并且为红结点</strong><br> 从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图9和图10所示。</p><p><strong>处理：</strong></p><ul><li><strong>将P和S设置为黑色</strong></li><li><strong>将PP设置为红色</strong></li><li><strong>把PP设置为当前插入结点</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109201.png" alt="image-20210405221635975"></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109762.png" alt="image-20210405221646435"></p><p>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><p>我们还可以总结出另外一个经验：<strong>红黑树的生长是自底向上的</strong>。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</p><p><strong>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</strong><br> 单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><p><strong>插入情景4.2.1：插入结点是其父结点的左子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行右旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109246.png" alt="image-20210405221717510"></p><p>由图11可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。</p><p>咦，可以把P设为红色，I和PP设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把P设为红色，I和PP设为黑色。但把P设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</p><p><strong>插入情景4.2.2：插入结点是其父结点的右子结点</strong><br> 这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。</p><p><strong>处理：</strong></p><ul><li><strong>对P进行左旋</strong></li><li><strong>把P设置为插入结点，得到情景4.2.1</strong></li><li><strong>进行情景4.2.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109857.png" alt="image-20210405221738803"></p><p><strong>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</strong><br> 该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><p><strong>插入情景4.3.1：插入结点是其父结点的右子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行左旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110655.png" alt="image-20210405221924516"></p><p><strong>插入情景4.3.2：插入结点是其父结点的左子结点</strong><br><strong>处理：</strong></p><ul><li><strong>对P进行右旋</strong></li><li><strong>把P设置为插入结点，得到情景4.3.1</strong></li><li><strong>进行情景4.3.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110359.png" alt="image-20210405222000297"></p><h1 id="5-红黑树的删除"><a href="#5-红黑树的删除" class="headerlink" title="5. 红黑树的删除"></a>5. 红黑树的删除</h1><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。</p><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong>。如图16所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110521.png" alt="image-20210405222107739"></p><p>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong>话很苍白，我们看图17。在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110880.png" alt="image-20210405222125858"></p><p>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图18所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110062.png" alt="image-20210405222153108"></p><p>综上所述，<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</strong>有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如图19所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110464.png" alt="image-20210405222242793"></p><p>即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。同样的，我们还是来约定下，如图20所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110087.png" alt="image-20210405222307463"></p><p>图20的字母并不代表结点Key的大小。R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。</p><p>值得特别提醒的是，<strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</strong></p><p>万事具备，我们进入最后的也是最难的讲解。</p><h2 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h2><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p><strong>处理：颜色变为删除结点的颜色</strong></p><h2 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h2><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><p><strong>删除情景2.1：替换结点是其父结点的左子结点</strong><br> <strong>删除情景2.1.1：替换结点的兄弟结点是红结点</strong><br> 若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行左旋，得到情景2.1.2.3</strong></li><li><strong>进行情景2.1.2.3的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110730.png" alt="image-20210405222346902"></p><p><strong>删除情景2.1.2：替换结点的兄弟结点是黑结点</strong><br> 当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。</p><p><strong>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</strong><br> 即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如图22所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对P进行左旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110873.png" alt="image-20210405222406585"></p><p>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。</p><p><strong>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</strong><br> 兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。图如23所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对S进行右旋，得到情景2.1.2.1</strong></li><li><strong>进行情景2.1.2.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110170.png" alt="image-20210405222429123"></p><p><strong>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br> 好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110391.png" alt="image-20210405222449127"></p><p><strong>删除情景2.2：替换结点是其父结点的右子结点</strong><br> 好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。</p><p><strong>删除情景2.2.1：替换结点的兄弟结点是红结点</strong><br> 处理：</p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行右旋，得到情景2.2.2.3</strong></li><li><strong>进行情景2.2.2.3的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110512.png" alt="image-20210405222508495"></p><p><strong>删除情景2.2.2：替换结点的兄弟结点是黑结点</strong><br> <strong>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</strong><br> <strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对P进行右旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110727.png" alt="image-20210405222534331"></p><p><strong>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对S进行左旋，得到情景2.2.2.1</strong></li><li><strong>进行情景2.2.2.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110898.png" alt="image-20210405222551805"></p><p><strong>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110196.png" alt="image-20210405222621855"></p><p>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><h1 id="资料来自"><a href="#资料来自" class="headerlink" title="资料来自"></a>资料来自</h1><ul><li><a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归回溯专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-083-没有重复元素集合的全排列"><a href="#剑指-Offer-II-083-没有重复元素集合的全排列" class="headerlink" title="剑指 Offer II 083. 没有重复元素集合的全排列"></a>剑指 Offer II 083. 没有重复元素集合的全排列</h2><blockquote><p><a href="https://leetcode.cn/problems/VvJkup/description/">https://leetcode.cn/problems/VvJkup/description/</a></p><p>给定一个不含重复数字的整数数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：回溯"><a href="#题解：回溯" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p><strong>可以将此问题看作有<code>n</code>个排列成一行的空格，需要从左往右依次填入题目给定的<code>n</code>个数，每个数只能用一次。</strong></p><p>定义递归函数<code>backTrack(res, tmp n, first)</code>表示从左往右填到第<code>first</code>个位置，当前排列为<code>tmp</code>，递归分下面两种情况：</p><ul><li>如果<code>first==n</code>说明已经填完了<code>n</code>个位置（下标从0开始），找到一个可行的解，将<code>tmp</code>放入答案中。</li><li>如果<code>first &lt; n</code>，需要考虑第<code>first</code>个位置需要填哪个数。题目要求不能填重复的数，所以需要把填过的数和未填过的数区分开。</li></ul><p>如何区分填过的数和未填过的数？</p><p>假设已经填到第<code>first</code>个位置，则<code>nums</code>数组中<code>[0, first-1]</code>是已经填过的数的集合，<code>[first, n-1]</code>是待填的数的集合。所以肯定用<code>[first, n-1]</code>里面的数去填第<code>first</code>个数。假设待填的数下标为<code>i</code>，填完后将第<code>i</code>个数和第<code>first</code>个数交换，即能使得在填第 <code>first+1</code>个数的时候 <code>nums</code>数组的<code>[0,first]</code> 部分为已填过的数，<code>[first+1,n−1]</code> 为待填的数，回溯的时候交换回来即能完成撤销操作。</p><p>举个简单的例子，假设我们有<code>[2,5,8,9,10]</code> 这 5 个数要填入，已经填到第 3个位置，已经填了 <code>[8,9]</code> 两个数，那么这个数组目前为 <code>[8,9 ∣ 2,5,10]</code> 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填<code>[8,9,10 ∣ 2,5]</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        tmp.add(num);<br>    &#125;<br>    backTrack(res, tmp, nums.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> first)</span> &#123;<br>    <span class="hljs-keyword">if</span> (first == n) &#123;<br>        <span class="hljs-comment">// 这里需要拷贝一份，否则后面修改会改变tmp数组的值</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> first; i &lt;= n; i++) &#123;<br>            Collections.swap(tmp, first, i);<br>            backTrack(res, tmp, n, first + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 这里需要还原现场，否则first位只交换一次</span><br>            Collections.swap(tmp, first, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-084-含有重复元素集合的全排列"><a href="#剑指-Offer-II-084-含有重复元素集合的全排列" class="headerlink" title="剑指 Offer II 084. 含有重复元素集合的全排列"></a>剑指 Offer II 084. 含有重复元素集合的全排列</h2><blockquote><p><a href="https://leetcode.cn/problems/7p8L0Z/">https://leetcode.cn/problems/7p8L0Z/</a></p><p>给定一个可包含重复数字的整数集合 <code>nums</code> ，<strong>按任意顺序</strong> 返回它所有不重复的全排列。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：回溯-1"><a href="#题解：回溯-1" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p>定义递归函数 <code>backtrack(idx,perm)</code>表示当前排列为 <code>perm</code>，下一个待填入的位置是第 <code>idx</code>个位置（下标从 0 开始）。那么整个递归函数分为两个情况：</p><ul><li>如果<code>idx == n</code>，说明已经填完第<code>n</code>个位置，找到一个可行的解。</li><li>如果<code>idx &lt; n</code>，需要考虑第<code>idx</code>填哪一个数，题目要求不能填已经填过的数，所以需要一个标记数组<code>visited</code>标记已经填过的数。在填第<code>idx</code>个数的时候遍历题目给的<code>n</code>个数，如果没有被标记则填入，然后继续尝试下一个位置，即<code>backTrack(perm, idx + 1)</code>。回溯时要撤销该位置填的数和标记。</li><li>为了解决重复填值的问题，设定一个规则：保证在填第<code>idx</code>个数的时候重复数字只填入一次。对原数组进行排序，保证相同数字相邻，然后每次填入的数一定是从左往右第一个未被填过的数字。即<code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 先把数组排序，这样在回溯中可以防止重复元素</span><br>    Arrays.sort(nums);<br>    <span class="hljs-comment">// 递归过程中标记该位置元素是否已经使用过</span><br>    <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>    <span class="hljs-comment">// idx：当前填充的元素位置</span><br>    backTrack(nums, res, tmp, visited, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-comment">// 此时说明得到一个结果</span><br>    <span class="hljs-keyword">if</span> (idx == nums.length) &#123;<br>        <span class="hljs-comment">// 拷贝一份是因为tmp在递归过程中可能会变</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 如果i位置元素已经被访问到 或者 nums[i] == nums[i - 1]并且前一个数未被访问 直接跳过</span><br>            <span class="hljs-comment">// 第二个条件：保证每次填入的数是从左到右第一个未被填入的数字</span><br>            <span class="hljs-keyword">if</span> (visited[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 将通过条件的元素添加</span><br>            tmp.add(nums[i]);<br>            <span class="hljs-comment">// 标记已访问</span><br>            visited[i] = <span class="hljs-literal">true</span>;<br>            backTrack(nums, res, tmp, visited, idx + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 回溯嘛，，需要还原现场，比如获取到一个数组[1,2,3], 还有[1,3,2]，这个2后面可能再用</span><br>            visited[i] = <span class="hljs-literal">false</span>;<br>            tmp.remove(idx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><blockquote><p><a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：网格回溯模板"><a href="#题解：网格回溯模板" class="headerlink" title="题解：网格回溯模板"></a>题解：网格回溯模板</h4><blockquote><p>参考答案：<a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</a></p></blockquote><p>主要思路：在递归过程中对每次递归走到的点位赋值，最后统计有多少个岛屿点位即可。例如：每次递归都将能走过的点位置2，这样每次退出递归时该次递归寻找的岛屿都是2（同时原来矩阵中数值也变成2），所以最后只需要统计原来矩阵有多少个1开始遍历的次数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-comment">// 从陆地开始递归，</span><br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                dfs(grid, i, j);<br>                <span class="hljs-comment">// 因为在递归过程中已经访问过的点标记为2，所以每次递归都会把岛屿的点都变成2，这里使用统计剩下1的数量即可</span><br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">// 网格递归遍历基本模板</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-comment">// 如果超出网格边界，直接返回</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不是陆地, 结束递归</span><br>    <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将递归后的陆地标记一下，不然会循环递归</span><br>    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    dfs(grid, i - <span class="hljs-number">1</span>, j);<br>    dfs(grid, i + <span class="hljs-number">1</span>, j);<br>    dfs(grid, i, j - <span class="hljs-number">1</span>);<br>    dfs(grid, i, j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h2><blockquote><p><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解-回溯"><a href="#题解-回溯" class="headerlink" title="题解: 回溯"></a>题解: 回溯</h4><blockquote><p>题解一样：剑指 Offer II 084. 含有重复元素集合的全排列 <a href="https://leetcode.cn/problems/7p8L0Z/">https://leetcode.cn/problems/7p8L0Z/</a></p></blockquote><p>只是将数字换成了字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()];<br>    <span class="hljs-comment">// 将字符串转为数组，这样就和整数数组全排列一致</span><br>    <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-comment">// 排序是为了后面去重</span><br>    Arrays.sort(chars);<br>    backTrack(res, visited, sb, chars, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;&#125;);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(List&lt;String&gt; res, <span class="hljs-type">boolean</span>[] visited, StringBuilder sb, <span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-comment">// 填充元素的下标满足个数后，获取当前结果</span><br>    <span class="hljs-keyword">if</span> (idx == chars.length) &#123;<br>        <span class="hljs-comment">// 这里sb.toString()里面已经拷贝了一份</span><br>        res.add(sb.toString());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-comment">// 如果i位置元素已经被访问到 或者 chars[i] == chars[i - 1]并且前一个数未被访问 直接跳过</span><br>            <span class="hljs-comment">// 第二个条件：保证每次填入的数是从左到右第一个未被填入的字符</span><br>            <span class="hljs-keyword">if</span> (visited[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; chars[i] == chars[i - <span class="hljs-number">1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 标记已经被访问</span><br>            visited[i] = <span class="hljs-literal">true</span>;<br>            sb.append(chars[i]);<br>            backTrack(res, visited, sb, chars, idx + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 回溯嘛，，需要还原现场，比如获取到一个数组[1,2,3], 还有[1,3,2]，这个2后面可能再用</span><br>            sb.deleteCharAt(idx);<br>            visited[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><blockquote><p><a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：回溯-2"><a href="#题解：回溯-2" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p>只在序列有效时才添加<code>(</code>或<code>)</code>：</p><ul><li>如果左括号数量不大于<code>n</code>，则添加一个左括号。</li><li>如果右括号数量小于左括号数量，可以添加一个右括号。</li><li>在每次添加完递归出来需要删除进行回溯。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dfs(res, n, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;String&gt; res, <span class="hljs-type">int</span> n, StringBuilder sb, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sb.length() == <span class="hljs-number">2</span> * n) &#123;<br>        res.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先添加左括号</span><br>    <span class="hljs-keyword">if</span> (open &lt; n) &#123;<br>        sb.append(<span class="hljs-string">&quot;(&quot;</span>);<br>        dfs(res, n, sb, open + <span class="hljs-number">1</span>, close);<br>        <span class="hljs-comment">// 删除完右括号后, 会退出到这里, 删除一个左括号</span><br>        <span class="hljs-comment">// 然后又进入dfs递归, 这时close &lt; open, 就会添加), 即(()</span><br>        sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 左括号满后, 添加对应数量的右括号</span><br>    <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>        sb.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        dfs(res, n, sb, open, close + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 右括号满后, 会从这里开始出栈, 逐步删除右括号</span><br>        sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-112-最长递增路径"><a href="#剑指-Offer-II-112-最长递增路径" class="headerlink" title="剑指 Offer II 112. 最长递增路径"></a>剑指 Offer II 112. 最长递增路径</h2><blockquote><p><a href="https://leetcode.cn/problems/fpTFWP/description/">https://leetcode.cn/problems/fpTFWP/description/</a></p><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108737.png" alt="image-20230528200917267"></p></blockquote><h4 id="题解：回溯-3"><a href="#题解：回溯-3" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p>使用记忆化深度优先搜索，当访问到一个单元格 <code>(i,j)</code> 时，如果<code>memo[i][j] !=0 </code>，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果<code> memo[i][j] ==0</code>，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</p><ul><li><code>memo[i][j]</code>存储当前点位最大路径值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 四个方向</span><br>    &#123;% raw %&#125;<span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;&#123;% endraw %&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rows, cols;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        rows = matrix.length;<br>        cols = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 记忆矩阵: 记录遍历当前点位时最大路径</span><br>        <span class="hljs-type">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rows][cols];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-comment">// 遍历每个矩阵点位</span><br>                ans = Math.max(ans, dfs(matrix, i, j, memo));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] memo)</span> &#123;<br>        <span class="hljs-comment">// 如果当前点位已经遍历过，返回当前点位时路径长度</span><br>        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i][j];<br>        &#125;<br>        <span class="hljs-comment">// 遍历到当前定位, 则路径+1</span><br>        <span class="hljs-comment">// 这里先把当前这个点路长度算出来，最短就只包含当前点长度1，下面那个dfs中的+1不一定能走的到，不满足递增的话就不走那里了，这样当前点局部最长路径长度依旧要赋值为1</span><br>        memo[i][j]++;<br>        <span class="hljs-comment">// 遍历四个方向</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newI</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newJ = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 1. 判断是否越界</span><br>            <span class="hljs-comment">// 2. 判断下一步遍历的点位值是否比当前值大(贪心)</span><br>            <span class="hljs-keyword">if</span> (newI &gt;= <span class="hljs-number">0</span> &amp;&amp; newI &lt; rows &amp;&amp; newJ &gt;= <span class="hljs-number">0</span> &amp;&amp; newJ &lt; cols &amp;&amp; matrix[newI][newJ] &gt; matrix[i][j]) &#123;<br>                <span class="hljs-comment">// 每次递归路径值+1, 最后获取最大值</span><br>                memo[i][j] = Math.max(memo[i][j], dfs(matrix, newI, newJ, memo) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][j];<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-079-所有子集"><a href="#剑指-Offer-II-079-所有子集" class="headerlink" title="剑指 Offer II 079. 所有子集"></a>剑指 Offer II 079. 所有子集</h2><blockquote><p><a href="https://leetcode.cn/problems/TVdhkn/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/TVdhkn/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二进制序列"><a href="#题解：二进制序列" class="headerlink" title="题解：二进制序列"></a>题解：二进制序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 初始化2^len个序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; len; i++) &#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 针对每个序列都是一种结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-comment">// 如果该序位置是1，则添加到子集中</span><br>            <span class="hljs-comment">// 例如len=3，</span><br>            <span class="hljs-comment">// 1 &lt;&lt; 0 -&gt; 1</span><br>            <span class="hljs-comment">// 1 &lt;&lt; 1 -&gt; 10</span><br>            <span class="hljs-comment">// 1 &lt;&lt; 2 -&gt; 100</span><br>            <span class="hljs-comment">// 用(1 &lt;&lt; j)和i相与就可以得到序列中哪些位置是1了</span><br>            <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span> )&#123;<br>                tmp.add(nums[j]);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：dfs递归"><a href="#题解：dfs递归" class="headerlink" title="题解：dfs递归"></a>题解：dfs递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dfs(nums, <span class="hljs-number">0</span>, tmp);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求子集模版一</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, List&lt;Integer&gt; tmp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 选第index个元素</span><br>    tmp.add(nums[index]);<br>    dfs(nums, index + <span class="hljs-number">1</span>, tmp);<br>    <span class="hljs-comment">// 恢复现场</span><br>    tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>    dfs(nums, index + <span class="hljs-number">1</span>, tmp);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求子集模板二</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, List&lt;Integer&gt; tmp)</span> &#123;<br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>    <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>        tmp.add(nums[i]);<br>        dfs(nums, i + <span class="hljs-number">1</span>, tmp);<br>        tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-080-含有-k-个元素的组合"><a href="#剑指-Offer-II-080-含有-k-个元素的组合" class="headerlink" title="剑指 Offer II 080. 含有 k 个元素的组合"></a>剑指 Offer II 080. 含有 k 个元素的组合</h2><blockquote><p><a href="https://leetcode.cn/problems/uUsW3B/description/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/uUsW3B/description/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: n = 4, k = 2<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：dfs递归-1"><a href="#题解：dfs递归-1" class="headerlink" title="题解：dfs递归"></a>题解：dfs递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    dfs(<span class="hljs-number">1</span>, k, n);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 递归结束条件：当前tmp元素个数=k</span><br>    <span class="hljs-keyword">if</span> (tmp.size() == k) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 什么情况下递归？当i&lt;=n时</span><br>    <span class="hljs-keyword">if</span> (i &lt;= n) &#123;<br>        <span class="hljs-comment">// 选择i</span><br>        tmp.add(i);<br>        <span class="hljs-comment">// 继续递归</span><br>        dfs(i + <span class="hljs-number">1</span>, k, n);<br>        <span class="hljs-comment">// 为什么要回溯？当选了[1,2]时，还有[1,3]等需要选，所以需要把3回退</span><br>        tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>        dfs(i + <span class="hljs-number">1</span>, k, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><blockquote><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110833.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span><br>输出：<span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：穿针引线"><a href="#题解：穿针引线" class="headerlink" title="题解：穿针引线"></a>题解：穿针引线</h4><p>思路很简单，分两步：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110158.png" alt="image-20230328124651700" style="zoom:50%;" /><ol><li>先将区间部分链表反转</li><li>把<code>pre.next</code>的<code>next</code>指向反转以后的链表头结点，把反转以后的链表尾结点 <code>next</code>指针指向<code>succ</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">header</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        header.next = head;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> header;<br>        <span class="hljs-comment">// 寻找到left的前一个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>            rightNode = rightNode.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记录区间左节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-comment">// 记录区间右节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tailNode</span> <span class="hljs-operator">=</span> rightNode.next;<br>        <span class="hljs-comment">// 切断链表关系</span><br>        pre.next = <span class="hljs-literal">null</span>;<br>        rightNode.next = <span class="hljs-literal">null</span>;<br>        <br>        reverseLink(leftNode);<br>        <br>        <span class="hljs-comment">// 经过反转后, rightNode变成了头结点</span><br>        pre.next = rightNode;<br>        <span class="hljs-comment">// 尾结点变成了头结点</span><br>        leftNode.next = tailNode;<br>        <span class="hljs-keyword">return</span> header.next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseLink</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 先将下一个节点保存</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-comment">// 当前节点的next指向尾结点</span><br>            cur.next = pre;<br>            <span class="hljs-comment">// pre指向当前节点, 作为尾结点</span><br>            pre = cur;<br>            <span class="hljs-comment">// 当前指针后移一个节点</span><br>            cur = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><blockquote><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110295.png" alt="image-20230328210057463" style="zoom:50%;" /><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110585.png" alt="image-20230328210121946" style="zoom:50%;" /><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：寻找区间后反转区间链表"><a href="#题解：寻找区间后反转区间链表" class="headerlink" title="题解：寻找区间后反转区间链表"></a>题解：寻找区间后反转区间链表</h4><p><strong>思路</strong>：</p><ul><li>初始需要两个变量<code>pre</code>和<code>end</code>：<code>pre</code>记录每次需要反转链表的前一个节点，<code>end</code>记录每次反转链表的尾结点。</li><li>每次寻找k个节点，<code>end</code>指向每次反转链表的尾结点。如果<code>end</code>为<code>null</code>，说明不足k个。</li><li><code>next</code>指向<code>end.next</code>：目的是为了反转后将链表接回到原链表。</li><li><code>end.next = null</code>：每次反转前要断开与原链表的联系。</li><li><code>start</code>指向反转链表头结点：目的是为了反转链表和将反转链表链接回原链表。</li><li>一次反转后，连接反转链表注意：原来的<code>next</code>变成了头结点；原来的<code>start</code>变成了尾结点。</li><li>一次反转后，<code>pre</code>和<code>end</code>指向<code>start</code>，即下一次反转链表的前一个节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 构建一个假节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <br>        <span class="hljs-comment">// 指向每次要反转链表的头结点的上一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-comment">// 指向每次要反转链表的尾结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (end.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 循环k次, 找到需要反转的链表的结尾, 需要判断end是否为空, 不然end.next会报错</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k &amp;&amp; end != <span class="hljs-literal">null</span>; i++) &#123;<br>                end = end.next;<br>            &#125;<br>            <span class="hljs-comment">// end为null则说明反转的链表的节点数小于k, 不执行反转</span><br>            <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 记录需要反转的链表的下一个节点</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> end.next;<br>            <span class="hljs-comment">// 断开要反转的链表</span><br>            end.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 记录要反转的链表的头结点</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pre.next;<br>            <span class="hljs-comment">// 反转链表, pre.next指向反转后的链表</span><br>            pre.next = reverse(start);<br>            <span class="hljs-comment">// 反转后, 原来的链表头结点变成了尾结点, 需要链接到之前的next</span><br>            start.next = next;<br>            <span class="hljs-comment">// pre和end指向下一次要反转链表的前一个节点</span><br>            pre = start;<br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 要求背诵</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h2><blockquote><p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/">https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/</a></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：归并排序思路"><a href="#题解：归并排序思路" class="headerlink" title="题解：归并排序思路"></a>题解：归并排序思路</h4><p>设置一个虚拟头结点，遍历比较两个链表，最后记得将剩余链表直接添加上去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> l1, cur2 = l2, cur = dummy;<br>        <span class="hljs-keyword">while</span> (cur1 != <span class="hljs-literal">null</span> &amp;&amp; cur2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur1.val &lt; cur2.val) &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur1.val);<br>                cur1 = cur1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur2.val);<br>                cur2 = cur2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (cur1 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = cur1;<br>            cur1 = cur1.next;<br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (cur2 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = cur2;<br>            cur2 = cur2.next;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-078-合并排序链表"><a href="#剑指-Offer-II-078-合并排序链表" class="headerlink" title="剑指 Offer II 078. 合并排序链表"></a>剑指 Offer II 078. 合并排序链表</h2><blockquote><p><a href="https://leetcode.cn/problems/vvXgSW/description/">https://leetcode.cn/problems/vvXgSW/description/</a></p><p>给定一个链表数组，每个链表都已经按升序排列。</p><p>请将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解一：遍历-两个有序链表合并"><a href="#题解一：遍历-两个有序链表合并" class="headerlink" title="题解一：遍历+两个有序链表合并"></a>题解一：遍历+两个有序链表合并</h4><ul><li>已经有两个有序链表合并的算法，所以直接遍历这个链表数组进行合并即可。</li><li>初始化一个空链表，让它与第一个链表合并。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个空链表，用来和第一个链表合并</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (ListNode list : lists) &#123;<br>            <span class="hljs-comment">// 用每次合并后的链表去和下一个链表合并</span><br>            ans = mergTwoList(ans, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个有序链表</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergTwoList</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a == <span class="hljs-literal">null</span> ? b : a;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (a.val &lt; b.val) &#123;<br>                head.next = a;<br>                a = a.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head.next = b;<br>                b = b.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-comment">// 注意这里处理，直接将剩余链表连接即可</span><br>        head.next = a == <span class="hljs-literal">null</span> ? b : a;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：归并"><a href="#题解二：归并" class="headerlink" title="题解二：归并"></a>题解二：归并</h4><ul><li>既然每个数组都是有序，那自然可以想到归并的思路来解。</li><li>归并排序到最后也是合并两个链表，所以核心算法还是合并两个有序链表（已有）</li><li>分而治之：考虑将k个链表配对，每两个合并，这就使用到递归分治。</li><li>递归退出的条件：参考归并排序<ul><li>当<code>left &lt; right</code>：继续递归。</li><li>当<code>left &gt; right</code>：范围不对，直接返回<code>null</code>。</li><li>当<code>left == right</code>： 说明两个链表一样，此时直接返回任意一个即可。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> mergeSort(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(ListNode[] list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// 边界出错，直接返回null</span><br>        <span class="hljs-keyword">if</span> (i &gt; j) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 两个链表一样，此时直接返回任意一个即可</span><br>        <span class="hljs-keyword">if</span> (i == j) &#123;<br>            <span class="hljs-keyword">return</span> list[i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> mergeSort(list, i, mid);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> mergeSort(list, mid + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-comment">// 两两合并</span><br>        <span class="hljs-keyword">return</span> mergeTwoList(l1, l2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoList</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a == <span class="hljs-literal">null</span> ? b : a;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (a.val &lt; b.val) &#123;<br>                head.next = a;<br>                a = a.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head.next = b;<br>                b = b.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        head.next = a == <span class="hljs-literal">null</span> ? b : a;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-022-链表中环的入口节点"><a href="#剑指-Offer-II-022-链表中环的入口节点" class="headerlink" title="剑指 Offer II 022. 链表中环的入口节点"></a>剑指 Offer II 022. 链表中环的入口节点</h2><blockquote><p><a href="https://leetcode.cn/problems/c32eOV/description/">https://leetcode.cn/problems/c32eOV/description/</a></p><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111315.png" alt="image-20230406224639579"></p></blockquote><h4 id="题解：快慢指针"><a href="#题解：快慢指针" class="headerlink" title="题解：快慢指针"></a>题解：快慢指针</h4><p>快慢指针找到相遇位置并且同时能够判断是否有环。</p><p><strong>关键点</strong>： 在相等节点处, 相遇指针继续向下走的距离就等于起始指针走到环入口的距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 定义一个快慢指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = head;<br>        <span class="hljs-comment">// 遇到节点为空说明没有环</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 快指针每次走两步</span><br>            fast = fast.next.next;<br>            <span class="hljs-comment">// 慢指针每次走一步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// 如果两个指针相等，说明有环</span><br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                <span class="hljs-comment">// 在相等节点处, 相遇指针继续向下走的距离就等于起始指针走到环入口的距离</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-keyword">while</span> (res != slow) &#123;<br>                    res = res.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><blockquote><p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/</a></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：遍历"><a href="#题解：遍历" class="headerlink" title="题解：遍历"></a>题解：遍历</h4><p>先求链表长度，然后再计算走到k需要几步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 先求链表长度, 这里是0，因为结束条件是cur!=null, 会多遍历一次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            len++;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-comment">// 计算从头到k需要走几步: len - k</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len - k; i++) &#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-021-删除链表的倒数第-n-个结点"><a href="#剑指-Offer-II-021-删除链表的倒数第-n-个结点" class="headerlink" title="剑指 Offer II 021. 删除链表的倒数第 n 个结点"></a>剑指 Offer II 021. 删除链表的倒数第 n 个结点</h2><blockquote><p><a href="https://leetcode.cn/problems/SLwz0R/description/">https://leetcode.cn/problems/SLwz0R/description/</a></p><p>给定一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,4,5]</span>, n = 2<br>输出：<span class="hljs-comment">[1,2,3,5]</span><br><br>输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br><br>输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：寻找待删除节点的前一个节点"><a href="#题解：寻找待删除节点的前一个节点" class="headerlink" title="题解：寻找待删除节点的前一个节点"></a>题解：寻找待删除节点的前一个节点</h4><ul><li>链表删除节点，必须之前待删除节点的前一个节点。</li><li>删除节点操作：<code>pre.next = cur.next;</code>注意判空。</li><li>为了方便处理一个节点和空链表的情况，初始化一个虚拟节点作为<code>pre</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            len++;<br>        &#125;<br><br>        <span class="hljs-comment">// 方便处理一个节点的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dumy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dumy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dumy;<br>        <span class="hljs-comment">// 寻找到要删除节点的前一个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len - n; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-comment">// 得到要删除的节点</span><br>        cur = pre.next;<br>        <span class="hljs-comment">// 这里需要判空</span><br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            pre.next = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dumy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h2><blockquote><p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/description/">https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/description/</a></p><p>输入两个链表，找出它们的第一个公共节点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111816.png" alt="image-20230418232817164"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Reference of the node with value = <span class="hljs-number">8</span><br>输入解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111800.png" alt="image-20230418232839444"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>输入解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul></blockquote><h4 id="题解：双指针"><a href="#题解：双指针" class="headerlink" title="题解：双指针"></a>题解：双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>        <span class="hljs-comment">// 这里如果对pA.next进行判空，就会进入无限循环出不来</span><br>        <span class="hljs-comment">// 假设链表如下：</span><br>        <span class="hljs-comment">// 1 -&gt; 3 -&gt; 5 -&gt; null</span><br>        <span class="hljs-comment">//      2 -&gt; 4 -&gt; null</span><br>        <span class="hljs-comment">// 如果对pA.next判空，则每次指针到5或4都会跳转到2或1,</span><br>        <span class="hljs-comment">// 但如果对pA本身判空，则总会存在一个null相等跳出循环</span><br>        <span class="hljs-comment">// pA = pA.next == null ? headB : pA.next;</span><br>        <span class="hljs-comment">// pB = pB.next == null ? headA : pB.next;</span><br>        pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>        pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-077-链表排序"><a href="#剑指-Offer-II-077-链表排序" class="headerlink" title="剑指 Offer II 077. 链表排序"></a>剑指 Offer II 077. 链表排序</h2><blockquote><p>给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111945.png" alt="image-20230426124533401" style="zoom:50%;" /><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [-<span class="hljs-number">1,5,3,4</span>,<span class="hljs-number">0</span>]<br>输出：[-<span class="hljs-number">1,0,3,4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解一：自定向下归并排序"><a href="#题解一：自定向下归并排序" class="headerlink" title="题解一：自定向下归并排序"></a>题解一：自定向下归并排序</h4><p><strong>思路</strong>：</p><ol><li>找到链表中点，以中点为分界。找链表中点方法：快慢指针，快指针每次移2步、慢指针每次移1步，当快指针到达链表末尾时，慢指针到达链表中点</li><li>对两个子链表进行排序</li><li>将两个排序后的子链表合并，得到排序后的链表</li></ol><blockquote><p>时间复杂度：nlog(n)，空间复杂度：log(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> sortList(head, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head, ListNode tail)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (head.next == tail) &#123;<br>            head.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 快慢指针寻找链表中间节点</span><br>        <span class="hljs-comment">// fast速度是slow两倍, 所以当fast到tail节点时, slow在中间节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>        <span class="hljs-keyword">while</span> (fast != tail) &#123;<br>            <span class="hljs-comment">// 慢指针走一步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// 快指针走两步</span><br>            fast = fast.next;<br>            <span class="hljs-keyword">if</span> (fast != tail) &#123;<br>                fast = fast.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> slow;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> sortList(head, mid);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> sortList(mid, tail);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> merge(l1, l2);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &gt; l2.val) &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：-自底向上归并排序"><a href="#题解二：-自底向上归并排序" class="headerlink" title="题解二： 自底向上归并排序"></a>题解二： 自底向上归并排序</h4><p><strong>思路</strong>：每次将链表分成子链表进行两两合并排序，最初是1, 后面依次为[2, 4, 8, …]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> dummy.next, prev = dummy;<br>            <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 寻找一个链表头结点head1</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">head1</span> <span class="hljs-operator">=</span> curr;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr.next != <span class="hljs-literal">null</span>; i++) &#123;<br>                    curr = curr.next;<br>                &#125;<br>                <span class="hljs-comment">// 寻找另一个链表头结点</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">head2</span> <span class="hljs-operator">=</span> curr.next;<br>                <span class="hljs-comment">// 剪断第一个链表head1与原始链表关系</span><br>                curr.next = <span class="hljs-literal">null</span>;<br>                curr = head2;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="hljs-literal">null</span> &amp;&amp; curr.next != <span class="hljs-literal">null</span>; i++) &#123;<br>                    curr = curr.next;<br>                &#125;<br>                <span class="hljs-comment">// 先记录第二个链表head2的下一个节点, 然后减掉第二个链表head2与原始链表关系</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                    next = curr.next;<br>                    curr.next = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 合并两个子链表</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">merge</span> <span class="hljs-operator">=</span> merge(head1, head2);<br>                <span class="hljs-comment">// 将合并后的新链表接到结果链表上</span><br>                prev.next = merge;<br>                <span class="hljs-keyword">while</span> (prev.next != <span class="hljs-literal">null</span>) &#123;<br>                    prev = prev.next;<br>                &#125;<br>                <span class="hljs-comment">// 重新赋值curr，准备开始当前长度subLength的下一次链表排序合并</span><br>                curr = next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &gt; l2.val) &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-027-回文链表"><a href="#剑指-Offer-II-027-回文链表" class="headerlink" title="剑指 Offer II 027. 回文链表"></a>剑指 Offer II 027. 回文链表</h2><blockquote><p><a href="https://leetcode.cn/problems/aMhZSa/">https://leetcode.cn/problems/aMhZSa/</a></p><p>给定一个链表的 <strong>头节点</strong> <code>head</code> <strong>，</strong>请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111747.png" alt="image-20230428154907613" style="zoom:50%;" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <span class="hljs-built_in">head</span> = [1,2,3,3,2,1]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：中点后反转链表"><a href="#题解：中点后反转链表" class="headerlink" title="题解：中点后反转链表"></a>题解：中点后反转链表</h4><p><strong>思路</strong>：</p><ul><li>快慢指针寻找链表中点</li><li>反转中点后面的链表，然后和中点前链表对比，判断值是否一样</li></ul><blockquote><p><strong>注意</strong>：</p><p>这题不能直接将整个链表反转然后比较，因为反转整个链表后head指针就变了（即原链表就变了）</p><p>例如： 1-&gt;2-&gt;3-&gt;4， 反转后：1&lt;-2&lt;-3&lt;-4，反转后head指向1，但是head.next为空了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 找中点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>        <span class="hljs-keyword">while</span> (slow != <span class="hljs-literal">null</span> &amp;&amp; fast != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>            <span class="hljs-keyword">if</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>                fast = fast.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 反转中点以后的链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverseLink</span> <span class="hljs-operator">=</span> reverseLink(slow);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, reverseCur = reverseLink;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; reverseCur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val != reverseCur.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.next;<br>            reverseCur = reverseCur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseLink</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h2><blockquote><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111082.png" alt="image-20230428155628067" style="zoom:50%;" /><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出: <span class="hljs-string">[1,3,5,2,4]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：正常思路"><a href="#题解：正常思路" class="headerlink" title="题解：正常思路"></a>题解：正常思路</h4><ul><li>一次遍历链表，分别将奇数偶数挑出来存储到新链表中</li><li>将偶数链表接到奇数链表后面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">oddEvenList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">// 存储奇数链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 存储偶数链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 判断当前是奇数索引节点还是偶数索引节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// cur: 遍历链表; oddRes: 接收奇数节点; evenRes: 接收偶数节点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, oddRes = odd, evenRes = even;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        index++;<br>        <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果是奇数索引节点, 连接到奇数链表中</span><br>            oddRes.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur.val);<br>            oddRes = oddRes.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是偶数索引节点, 连接到偶数链表中</span><br>            evenRes.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur.val);<br>            evenRes = evenRes.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">// 最后将偶数结果链表接到奇数结果链表中返回</span><br>    oddRes.next = even.next;<br>    <span class="hljs-keyword">return</span> odd.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><blockquote><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/</a></p><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2,3,3]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：Set集合-链表删除"><a href="#题解：Set集合-链表删除" class="headerlink" title="题解：Set集合+链表删除"></a>题解：Set集合+链表删除</h4><ul><li>删除链表元素需要一个前置指针<code>pre</code></li><li>遍历判断元素是否在集合中，在就删除元素，不再则添加到集合中，把当前元素作为前置节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-comment">// cur: 遍历指针; pre: 因为要删除元素，所以需要一个前置指针指向第一个不重复元素, 如: [1, 1, 1] pre指向第一个1</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = cur;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(cur.val)) &#123;<br>            <span class="hljs-comment">// 遇到重复元素, 直接删除</span><br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 遇到不重复元素, 将pre指针指向当前</span><br>            set.add(cur.val);<br>            pre = cur;<br>        &#125;<br>        <span class="hljs-comment">// 遍历</span><br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h2><blockquote><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</a></p><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,3,4,4,5]</span><br>输出：<span class="hljs-comment">[1,2,5]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解一：遍历两次删除两遍"><a href="#题解一：遍历两次删除两遍" class="headerlink" title="题解一：遍历两次删除两遍"></a>题解一：遍历两次删除两遍</h4><p>在<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">删除排序链表中的重复元素</a>中是留下一个重复元素，可以在此基础上再把剩下的重复元素删除。</p><ul><li>两个<code>set</code>，第一个<code>set</code>用于删除重复节点，保留一个。第二个<code>set</code>用于存储重复的节点，用在第二次遍历中删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-comment">// 先去一遍重: 例如原链表: [1, 1, 1, 2, 2, 3, 4, 5]</span><br>    <span class="hljs-comment">// 第一遍去重后: [1, 2, 3, 4, 5], 同时将重复元素记录到tSet中</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy.next, pre = cur;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    Set&lt;Integer&gt; tSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(cur.val)) &#123;<br>            pre.next = cur.next;<br>            tSet.add(cur.val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            set.add(cur.val);<br>            pre = cur;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">// 第二遍去重: 遍历第一遍去重后链表判断元素是否在tSet中, 有则需要再去掉该元素</span><br>    <span class="hljs-comment">// 由于链表第一个元素有可能需要去掉, 所以需要记录-1节点位置</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> dummy, pro = ptr;<br>    <span class="hljs-keyword">while</span> (ptr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tSet.contains(ptr.val)) &#123;<br>            pro.next = ptr.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pro = ptr;<br>        &#125;<br>        ptr = ptr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：遍历一次删除"><a href="#题解二：遍历一次删除" class="headerlink" title="题解二：遍历一次删除"></a>题解二：遍历一次删除</h4><ul><li>每次遍历<code>cur</code>指向留下的节点并表示前置节点。</li><li>比较cur.next和cur.next.next值是否相等：相等就说明这是个重复节点，需要删除，但需要寻找出所有等于该值的节点全部删除，所以再加个<code>while</code>循环遍历寻找相等的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 关键点: cur指针始终指向前置元素</span><br><span class="hljs-comment">         * 由于是升序链表, 设当前节点是cur, 直接比较cur.next和cur.next.next值是否相等即可确定是否需要删除</span><br><span class="hljs-comment">         *      -1 -&gt; 1 -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 3</span><br><span class="hljs-comment">         *      cur  ptr ...........ptr</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.next.val == cur.next.next.val) &#123;<br>            <span class="hljs-comment">// 遍历指针, 跳出循环指向下一个不重复元素</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-keyword">while</span> (ptr != <span class="hljs-literal">null</span> &amp;&amp; ptr.val == cur.next.val) &#123;<br>                ptr = ptr.next;<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 考虑到下面这种情况, 下一次循环仍需要丢弃2元素</span><br><span class="hljs-comment">                 *      -1 -&gt; 1 -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 2</span><br><span class="hljs-comment">                 *      cur  ptr ...........ptr</span><br><span class="hljs-comment">                 */</span><br>            cur.next = ptr;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不是重复元素, cur后移</span><br>            cur = cur.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel基础概念</title>
    <link href="/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><blockquote><p><strong>任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的</strong>。需要根据系统的处理能力对流量进行控制</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307021350271.png" alt="image-20230702135042339"></p><p>流量控制有下面几个角度：</p><ul><li><strong>资源的调用关系</strong>。比如：资源调用链路、资源和资源的关系。</li><li><strong>运行的指标</strong>。比如：QPS、线程池、系统负载。</li><li><strong>控制的效果</strong>。比如：直接限流、冷启动、排队。</li></ul><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>在资源调用过程中，如果某个资源出现了不稳定，最终会导致堆积发生。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022000526.png" alt="image-20230702135741629"></p><p>Sentinel 和 Hystrix 的原则是一致的：当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候。则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p><h3 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h3><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>的方式：</p><ul><li>好处：资源和资源之间做到了最彻底的隔离。</li><li>缺点：除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。</li></ul><p>Sentinel 对这个问题采取了两种手段：</p><ol><li><strong>通过并发线程数进行限制</strong></li></ol><p>这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。<strong>当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝</strong>。堆积的线程完成任务后才开始继续接收请求。</p><ol start="2"><li><strong>通过响应时间对资源进行降级</strong></li></ol><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。<strong>当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复</strong>。</p><h2 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h2><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><h2 id="Sentinel主流程"><a href="#Sentinel主流程" class="headerlink" title="Sentinel主流程"></a>Sentinel主流程</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称以及一个 Entry。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 API 显式创建；每一个 Entry 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:、</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p>总体的框架如下：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001521.png" alt="image-20230702154412159"></p><p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001747.png" alt="image-20230702154750154"></p><h2 id="Sentinal各个Slot功能"><a href="#Sentinal各个Slot功能" class="headerlink" title="Sentinal各个Slot功能"></a>Sentinal各个Slot功能</h2><h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><blockquote><p> 这个 slot 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p></blockquote><p>使用下面代码可以创建一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextUtil.enter(<span class="hljs-string">&quot;entrance1&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> <span class="hljs-type">Entry</span> <span class="hljs-variable">nodeA</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br><br> ContextUtil.enter(<span class="hljs-string">&quot;entrance2&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> nodeA = SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001547.png" alt="image-20230702160008744"></p><h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><blockquote><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。</p></blockquote><p>存储的信息示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>: nodeA<br>idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total <br>1   caller1 0         0         0          0        0     0         0          0        <br>2   caller2 0         0         0          0        0     0         0          0        <br></code></pre></td></tr></table></figure><h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><blockquote><p><code>StatisticSlot</code> 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</p></blockquote><ul><li><code>clusterNode</code>：资源唯一标识的 ClusterNode 的 runtime 统计</li><li><code>origin</code>：根据来自不同调用者的统计信息</li><li><code>defaultnode</code>: 根据上下文条目名称和资源 ID 的 runtime 统计</li><li>入口的统计</li></ul><p>Sentinel 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001258.png" alt="image-20230702160429033"></p><h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>这个 slot 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p><ul><li>指定应用生效的规则，即针对调用方限流的；</li><li>调用方为 other 的规则；</li><li>调用方为 default 的规则。</li></ul><h3 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h3><p>这个 slot 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p><h3 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h3><p>这个 slot 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p><p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">核心类解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel流量控制</title>
    <link href="/Sentinel/Sentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/Sentinel/Sentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p><p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p><p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>count</code>: 限流阈值</li><li><code>grade</code>: 限流阈值类型，QPS 或线程数</li><li><code>strategy</code>: 根据调用关系选择策略</li></ul><h2 id="基于QPS-x2F-并发数的流量控制"><a href="#基于QPS-x2F-并发数的流量控制" class="headerlink" title="基于QPS&#x2F;并发数的流量控制"></a>基于QPS&#x2F;并发数的流量控制</h2><p>流量控制主要有两种统计类型，一种是<strong>统计线程数</strong>，另外一种则是统计 QPS。类型由 <code>FlowRule.grade</code> 字段来定义。其中，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。其中线程数、QPS 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p><p>内容格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">idx</span> id   thread  pass  blocked   success  total Rt   <span class="hljs-number">1</span>m-pass   <span class="hljs-number">1</span>m-block   <span class="hljs-number">1</span>m-<span class="hljs-literal">all</span>   exeption<br><span class="hljs-attribute">2</span>   abc647 <span class="hljs-number">0</span>     <span class="hljs-number">46</span>     <span class="hljs-number">0</span>           <span class="hljs-number">46</span>     <span class="hljs-number">46</span>   <span class="hljs-number">1</span>       <span class="hljs-number">2763</span>      <span class="hljs-number">0</span>         <span class="hljs-number">2763</span>     <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>thread： 代表当前处理该资源的线程数；</li><li>pass： 代表一秒内到来到的请求；</li><li>blocked： 代表一秒内被流量控制的请求数量；</li><li>success： 代表一秒内成功处理完的请求；</li><li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li><li>RT： 代表一秒内该资源的平均响应时间；</li><li>1m-pass： 则是一分钟内到来的请求；</li><li>1m-block： 则是一分钟内被阻止的请求；</li><li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li><li>exception： 则是一秒内业务本身异常的总和。</li></ul><h3 id="2-1-并发线程数流量控制"><a href="#2-1-并发线程数流量控制" class="headerlink" title="2.1 并发线程数流量控制"></a>2.1 并发线程数流量控制</h3><p>线程数限流用于保护业务线程数不被耗尽。</p><p>Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。</p><h3 id="2-2-QPS流量控制"><a href="#2-2-QPS流量控制" class="headerlink" title="2.2 QPS流量控制"></a>2.2 QPS流量控制</h3><p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p><h4 id="直接拒绝"><a href="#直接拒绝" class="headerlink" title="直接拒绝"></a>直接拒绝</h4><p>直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。</p><h4 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h4><p>冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p><h4 id="匀速排队"><a href="#匀速排队" class="headerlink" title="匀速排队"></a>匀速排队</h4><p>匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p><p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><blockquote><p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022335925.png" alt="image-20230702223524513"></p><h2 id="基于调用关系的流量控制"><a href="#基于调用关系的流量控制" class="headerlink" title="基于调用关系的流量控制"></a>基于调用关系的流量控制</h2><p>调用关系包括调用方、被调用方；一个方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterBuilderSlot</code> 记录每个资源的实时统计信息。</p><h3 id="3-1-根据调用方限流"><a href="#3-1-根据调用方限流" class="headerlink" title="3.1 根据调用方限流"></a>3.1 根据调用方限流</h3><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。</p><p>调用数据示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>: nodeA<br>idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total <br>1   caller1 0         0         0          0        0     0         0          0<br>2   caller2 0         0         0          0        0     0         0          0<br></code></pre></td></tr></table></figure><p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p><p>流控规则中的 <code>limitApp</code> 字段用于根据调用来源进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p><ul><li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li><li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li><li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li></ul><p>同一个资源名可以配置多条规则，规则的生效顺序为：**{some_origin_name}&gt;other&gt;default**</p><blockquote><p>注意：调用来源的数目不要太多（一般不要超过几百个），否则内存占用会非常多（调用来源的统计节点最大数目&#x3D;资源数目*来源数目）。</p></blockquote><h3 id="3-2-根据调用链路入口限流：链路限流"><a href="#3-2-根据调用链路入口限流：链路限流" class="headerlink" title="3.2 根据调用链路入口限流：链路限流"></a>3.2 根据调用链路入口限流：链路限流</h3><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p><p>一棵典型的调用树如下图所示：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">          machine-root<br>              /       <span class="hljs-string">\</span><br>             /         <span class="hljs-string">\</span><br>       Entrance1     Entrance2<br>          /             <span class="hljs-string">\</span><br>         /               <span class="hljs-string">\</span><br>DefaultNode(nodeA)   DefaultNode(nodeA)<br></code></pre></td></tr></table></figure><p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_CHAIN</code>，同时设置 <code>refResource</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而不关心经 <code>Entrance2</code> 到来的调用。</p><p>调用链的入口（上下文）是通过 API 方法 <code>ContextUtil.enter(contextName)</code> 定义的，其中 contextName 即对应调用链路入口名称。</p><h3 id="3-3-具有关系的资源流量控制：关联流量控制"><a href="#3-3-具有关系的资源流量控制：关联流量控制" class="headerlink" title="3.3 具有关系的资源流量控制：关联流量控制"></a>3.3 具有关系的资源流量控制：关联流量控制</h3><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们<strong>可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_RELATE</code> 同时设置 <code>refResource</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel集群流控（未完待续）</title>
    <link href="/Sentinel/Sentinel%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7/"/>
    <url>/Sentinel/Sentinel%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p><p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p><p>集群流控中共有两种身份：</p><ul><li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li><li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li></ul><h2 id="此处先省略"><a href="#此处先省略" class="headerlink" title="此处先省略"></a>此处先省略</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">集群流控官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
