<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>缓存一致性方案思考</title>
    <link href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、缓存的查询"><a href="#一、缓存的查询" class="headerlink" title="一、缓存的查询"></a>一、缓存的查询</h2><p>先查询缓存，如果缓存查询失败，就去查询数据库，然后重新生成缓存。</p><h2 id="二、缓存的更新"><a href="#二、缓存的更新" class="headerlink" title="二、缓存的更新"></a>二、缓存的更新</h2><p>在高并发的情况下，需要考虑下面两个问题：</p><ul><li>是先更新数据库还是先更新缓存？</li><li>是更新缓存还是删除缓存？</li></ul><h4 id="1-先更新数据库再更新缓存"><a href="#1-先更新数据库再更新缓存" class="headerlink" title="1. 先更新数据库再更新缓存"></a>1. 先更新数据库再更新缓存</h4><p>线程A：更新数据库（第1s）——&gt;  更新缓存（第10s）</p><p>线程B：更新数据库 （第3s）——&gt; 更新缓存（第5s）</p><p>上面情况，就会导致线程B的缓存值被线程A覆盖，<strong>缓存中存的是线程A的旧值</strong>，产生脏数据并且直到缓存失效（如果有过期时间）。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252234.png" alt="image-20230620164505738" style="zoom:50%;" /><h4 id="2-先更新缓存再更新数据库"><a href="#2-先更新缓存再更新数据库" class="headerlink" title="2. 先更新缓存再更新数据库"></a>2. 先更新缓存再更新数据库</h4><p>线程A：更新缓存（第1s）——&gt; 更新数据库（第10s）</p><p>线程B： 更新缓存（第3s）——&gt;  更新数据库（第5s）</p><p>和前面一种情况相反，<strong>缓存中是线程B的新值，而数据库中是线程A的旧值。</strong></p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252759.png" alt="image-20230620170050262" style="zoom:50%;" /><p>﻿前两种方式之所以会在并发场景下出现异常，<strong>本质上是因为更新缓存和更新数据库是两个操作</strong>。</p><p>如果把它化简，更新时只更新数据库，同时删除缓存。等待下一次查询时命中不到缓存，再去重建缓存，是不是就解决了这个问题？</p><h4 id="3-先删除缓存再更新数据库"><a href="#3-先删除缓存再更新数据库" class="headerlink" title="3. 先删除缓存再更新数据库"></a>3. 先删除缓存再更新数据库</h4><p>通过这种方式，两个线程都值修改数据库，不管谁先，数据库以后修改的数据为准。</p><p>但这时另一个<strong>并发场景</strong>：两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的。很显然，这种状况也不是我们想要的。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252794.png" alt="image-20230620170016670" style="zoom:50%;" /><p><strong>解决方案</strong>：</p><h5 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h5><p>对于<strong>请求</strong>A，做一下操作：</p><ol><li><p>删除缓存</p></li><li><p>更新数据库</p></li><li><p><strong>睡眠一段时间</strong></p></li><li><p><strong>再次删除缓存</strong></p></li></ol><p>添加一个睡眠时间，主要是为了确保请求A在睡眠的时候，请求B能在这段时间内完成<strong>从数据库读取数据，再把缺失的数据写入缓存</strong>的操作，然后请求A睡眠完，再删除缓存。</p><p>所以请求A的睡眠时间就需要大于请求B<strong>从数据库读取数据+写入数据</strong>的时间。<strong>但是这个时间不好评估</strong>。</p><p><strong>所以不建议这种方案</strong>。</p><h4 id="4-先更新数据库再删除缓存（cache-aside）"><a href="#4-先更新数据库再删除缓存（cache-aside）" class="headerlink" title="4. 先更新数据库再删除缓存（cache aside）"></a>4. 先更新数据库再删除缓存（cache aside）</h4><p><strong>场景</strong>：一个是查询操作，一个是更新操作的并发，我们先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，删除操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会方案3一样，后续的查询操作一直在取老的数据。如下图：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252546.png" alt="image-20230619202426780" style="zoom: 50%;" /><p>但是，这种策略也不是一定完美。看下面这个场景：</p><p>一个读操作没有命中缓存，然后就去数据库中获取数据。此时有一个写操作，写完数据库后，让缓存失效。然后之前的读操作再把老的数据写回缓存，这样就造成脏数据。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252030.png" alt="image-20230620170340552" style="zoom:50%;" /><p>上面的例子理论上会出现，但是出现概率比较低。因为条件需要读缓存时缓存正好失效，并且此时并发一个写操作。而数据库写操作比读操作慢的多，而读操作读操作必须在写操作之前，又要晚于写操作更新缓存。所有条件在一起的可能性并不大。</p><h2 id="三、操作失败如何"><a href="#三、操作失败如何" class="headerlink" title="三、操作失败如何"></a>三、操作失败如何</h2><p>在实际生产中，由于网络抖动、服务下线等原因，对数据库和缓存的操作可能失败。</p><p>举例说明：应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252746.png" alt="image-20230620170950273" style="zoom:50%;" /><p>那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有删除，所以会缓存命中，但是读到的却是旧值 1。</p><p>其实<strong>不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题</strong>。</p><p>问题原因知道了，该怎么解决呢？有两种方法：</p><ul><li>重试机制</li><li>订阅MySQL binlog，再操作缓存</li></ul><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p>举个例子，来说明重试机制的过程：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252738.png" alt="image-20230620171258860" style="zoom:50%;" /><h4 id="订阅-MySQL-binlog，再操作缓存"><a href="#订阅-MySQL-binlog，再操作缓存" class="headerlink" title="订阅 MySQL binlog，再操作缓存"></a>订阅 MySQL binlog，再操作缓存</h4><p><strong>先更新数据库，再删缓存</strong>的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p><p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p><p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p><p>下图是 Canal 的工作原理：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262253576.png" alt="image-20230619225953489"></p><p>综上，<strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</strong></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="1-cache-aside并非万能"><a href="#1-cache-aside并非万能" class="headerlink" title="1. cache aside并非万能"></a>1. cache aside并非万能</h3><p>虽然说cache aside可以被称之为缓存使用的最佳实践，但与此同时，它引入了缓存的命中率降低的问题，（每次都删除缓存自然导致更不容易命中了），因此它更适用于对缓存命中率要求并不是特别高的场景。<strong>如果要求较高的缓存命中率，依然需要采用更新数据库后同时更新缓存的方案</strong>。</p><h3 id="2-缓存数据不一致的解决方案"><a href="#2-缓存数据不一致的解决方案" class="headerlink" title="2. 缓存数据不一致的解决方案"></a>2. 缓存数据不一致的解决方案</h3><p>在更新数据库后同时更新缓存，会在并发的场景下出现数据不一致，有下面方案：</p><h4 id="引入分布式锁"><a href="#引入分布式锁" class="headerlink" title="引入分布式锁"></a>引入分布式锁</h4><p>在更新缓存之前尝试获取锁，如果已经被占用就先阻塞住线程，等待其他线程释放锁后再尝试更新。但这会影响并发操作的性能。</p><h4 id="设置较短缓存时间"><a href="#设置较短缓存时间" class="headerlink" title="设置较短缓存时间"></a>设置较短缓存时间</h4><p>设置较短的缓存过期时间能够使得数据不一致问题存在的时间也比较短，对业务的影响相对较小。但是与此同时，其实这也使得缓存命中率降低，又回到了前面的问题里…</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li><a href="https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY">https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel基础概念</title>
    <link href="/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><blockquote><p><strong>任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的</strong>。需要根据系统的处理能力对流量进行控制</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307021350271.png" alt="image-20230702135042339"></p><p>流量控制有下面几个角度：</p><ul><li><strong>资源的调用关系</strong>。比如：资源调用链路、资源和资源的关系。</li><li><strong>运行的指标</strong>。比如：QPS、线程池、系统负载。</li><li><strong>控制的效果</strong>。比如：直接限流、冷启动、排队。</li></ul><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>在资源调用过程中，如果某个资源出现了不稳定，最终会导致堆积发生。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022000526.png" alt="image-20230702135741629"></p><p>Sentinel 和 Hystrix 的原则是一致的：当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候。则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p><h3 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h3><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>的方式：</p><ul><li>好处：资源和资源之间做到了最彻底的隔离。</li><li>缺点：除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。</li></ul><p>Sentinel 对这个问题采取了两种手段：</p><ol><li><strong>通过并发线程数进行限制</strong></li></ol><p>这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。<strong>当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝</strong>。堆积的线程完成任务后才开始继续接收请求。</p><ol start="2"><li><strong>通过响应时间对资源进行降级</strong></li></ol><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。<strong>当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复</strong>。</p><h2 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h2><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><h2 id="Sentinel主流程"><a href="#Sentinel主流程" class="headerlink" title="Sentinel主流程"></a>Sentinel主流程</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称以及一个 Entry。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 API 显式创建；每一个 Entry 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:、</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p>总体的框架如下：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001521.png" alt="image-20230702154412159"></p><p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001747.png" alt="image-20230702154750154"></p><h2 id="Sentinal各个Slot功能"><a href="#Sentinal各个Slot功能" class="headerlink" title="Sentinal各个Slot功能"></a>Sentinal各个Slot功能</h2><h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><blockquote><p> 这个 slot 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p></blockquote><p>使用下面代码可以创建一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextUtil.enter(<span class="hljs-string">&quot;entrance1&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> <span class="hljs-type">Entry</span> <span class="hljs-variable">nodeA</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br><br> ContextUtil.enter(<span class="hljs-string">&quot;entrance2&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> nodeA = SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001547.png" alt="image-20230702160008744"></p><h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><blockquote><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。</p></blockquote><p>存储的信息示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>: nodeA<br>idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total <br>1   caller1 0         0         0          0        0     0         0          0        <br>2   caller2 0         0         0          0        0     0         0          0        <br></code></pre></td></tr></table></figure><h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><blockquote><p><code>StatisticSlot</code> 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</p></blockquote><ul><li><code>clusterNode</code>：资源唯一标识的 ClusterNode 的 runtime 统计</li><li><code>origin</code>：根据来自不同调用者的统计信息</li><li><code>defaultnode</code>: 根据上下文条目名称和资源 ID 的 runtime 统计</li><li>入口的统计</li></ul><p>Sentinel 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001258.png" alt="image-20230702160429033"></p><h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>这个 slot 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p><ul><li>指定应用生效的规则，即针对调用方限流的；</li><li>调用方为 other 的规则；</li><li>调用方为 default 的规则。</li></ul><h3 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h3><p>这个 slot 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p><h3 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h3><p>这个 slot 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p><p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">核心类解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
