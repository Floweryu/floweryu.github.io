<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dubbo超时时间原理</title>
    <link href="/Dubbo/Dubbo%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E5%8E%9F%E7%90%86/"/>
    <url>/Dubbo/Dubbo%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><p>服务端：方法控制——&gt;接口控制——&gt;全局控制<br>消费端：方法控制——&gt;接口控制——&gt;全局控制</p><p><strong>超时设置的优先级</strong></p><blockquote><p>可以这样理解：如果服务端设置了超时，则消费端可以不用设置超时时间，默认会使用服务端超时配置</p></blockquote><p>优先级为：<strong>消费端方法级 &gt; 消费端接口级 &gt; 消费端全局 &gt; 服务端方法级 &gt; 服务端接口级 &gt; 服务端全局</strong></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel熔断降级</title>
    <link href="/Sentinel/Sentinel%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
    <url>/Sentinel/Sentinel%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202309182244737.png" alt="image-20230918224359647"></p><p>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p><h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>Sentinel 提供以下几种熔断策略：</p><ul><li><p>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置以下参数：</p><ul><li>允许的慢调用 RT（即最大的响应时间）：请求的响应时间大于该值则统计为慢调用。</li><li><strong>单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值</strong>，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li></ul></li><li><p>异常比例 (<code>ERROR_RATIO</code>)：当<strong>单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值</strong>，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</p></li><li><p>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的<strong>异常数目</strong>超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</p></li></ul><p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>  entry = SphU.entry(resource);<br><br>  <span class="hljs-comment">// Write your biz code here.</span><br>  <span class="hljs-comment">// &lt;&lt;BIZ CODE&gt;&gt;</span><br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>  <span class="hljs-keyword">if</span> (!BlockException.isBlockException(t)) &#123;<br>    Tracer.trace(t);<br>  &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>    entry.exit();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="熔断降级规则说明"><a href="#熔断降级规则说明" class="headerlink" title="熔断降级规则说明"></a>熔断降级规则说明</h2><p>熔断降级规则（DegradeRule）包含下面几个重要的属性：</p><table><thead><tr><th align="left">Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td align="left">resource</td><td>资源名，即规则的作用对象</td><td></td></tr><tr><td align="left">grade</td><td>熔断策略，支持<strong>慢调用比例</strong>、<strong>异常比例</strong>、<strong>异常数策略</strong></td><td>慢调用比例</td></tr><tr><td align="left">count</td><td><strong>慢调用比例</strong>模式下：慢调用临界 RT（超出该值计为慢调用）；<strong>异常比例&#x2F;异常数模式</strong>：为对应的阈值</td><td></td></tr><tr><td align="left">timeWindow</td><td>熔断时长，单位为 s</td><td></td></tr><tr><td align="left">minRequestAmount</td><td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td><td>5</td></tr><tr><td align="left">statIntervalMs</td><td>统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td><td>1000 ms</td></tr><tr><td align="left">slowRatioThreshold</td><td>慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td><td></td></tr></tbody></table><h2 id="熔断器事件监听"><a href="#熔断器事件监听" class="headerlink" title="熔断器事件监听"></a>熔断器事件监听</h2><p>Sentinel 支持注册自定义的事件监听器监听熔断器状态变换事件（state change event）。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">EventObserverRegistry.getInstance().addStateChangeObserver(<span class="hljs-string">&quot;logging&quot;</span>,<br>    (prevState, newState, rule, snapshotValue) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (newState == State.OPEN) &#123;<br>            <span class="hljs-comment">// 变换至 OPEN state 时会携带触发时的值</span><br>            System.err.println(String.format(<span class="hljs-string">&quot;%s -&gt; OPEN at %d, snapshotValue=%.2f&quot;</span>, prevState.name(),<br>                TimeUtil.currentTimeMillis(), snapshotValue));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.err.println(String.format(<span class="hljs-string">&quot;%s -&gt; %s at %d&quot;</span>, prevState.name(), newState.name(),<br>                TimeUtil.currentTimeMillis()));<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConfigurationClassPostProcessor源码理解</title>
    <link href="/Spring/ConfigurationClassPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/Spring/ConfigurationClassPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring执行BeanFactoryPostProcessor源码理解</title>
    <link href="/Spring/Spring%E6%89%A7%E8%A1%8CBeanFactoryPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/Spring/Spring%E6%89%A7%E8%A1%8CBeanFactoryPostProcessor%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307302031012.png" alt="image-20230730203029711"></p><h2 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h2><p>源码位于<code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</code>方法，这里省略了上下文，需要知道该方法是在<code>BeanFactory</code>准备完成后调用，位置如下图所示：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307302031111.png" alt="image-20230730203053823"></p><p>关于代码的理解都写在注释中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;<br><br><span class="hljs-comment">// WARNING: Although it may appear that the body of this method can be easily</span><br><span class="hljs-comment">// refactored to avoid the use of multiple loops and multiple lists, the use</span><br><span class="hljs-comment">// of multiple lists and multiple passes over the names of processors is</span><br><span class="hljs-comment">// intentional. We must ensure that we honor the contracts for PriorityOrdered</span><br><span class="hljs-comment">// and Ordered processors. Specifically, we must NOT cause processors to be</span><br><span class="hljs-comment">// instantiated (via getBean() invocations) or registered in the ApplicationContext</span><br><span class="hljs-comment">// in the wrong order.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Before submitting a pull request (PR) to change this method, please review the</span><br><span class="hljs-comment">// list of all declined PRs involving changes to PostProcessorRegistrationDelegate</span><br><span class="hljs-comment">// to ensure that your proposal does not result in a breaking change:</span><br><span class="hljs-comment">// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22</span><br><br><span class="hljs-comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="hljs-comment">// 无论什么情况，优先执行BeanDefinitionRegistryPostProcessors</span><br><span class="hljs-comment">// 将已经执行过的BFPP存储在processedBeans中，防止重复执行</span><br>Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-comment">// 判断beanFactory是否是BeanDefinitionRegistry类型，此处是DefaultListableBeanFactory，实现了BeanDefinitionRegistry接口，所以是true</span><br><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry registry) &#123;<br><span class="hljs-comment">// BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子集</span><br><span class="hljs-comment">// BeanDefinitionRegistryPostProcessor主要针对对象是BeanDefinition，BeanFactoryPostProcessor主要针对对象是BeanFactory</span><br><br><span class="hljs-comment">// 存放BeanFactoryPostProcessor的集合</span><br>List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 存放BeanDefinitionRegistryPostProcessor的集合</span><br>List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 1. 先处理外部集合传入的beanFactoryPostProcessors</span><br><span class="hljs-comment">// 将BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor区分开</span><br><span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<br><span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor registryProcessor) &#123;<br><span class="hljs-comment">// 直接执行下面方法</span><br>registryProcessor.postProcessBeanDefinitionRegistry(registry);<br><span class="hljs-comment">// 添加到registryProcessors集合中，后续会执行postProcessBeanFactory方法</span><br>registryProcessors.add(registryProcessor);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 添加到regularPostProcessors集合中，后续会执行postProcessBeanFactory方法</span><br>regularPostProcessors.add(postProcessor);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="hljs-comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="hljs-comment">// PriorityOrdered, Ordered, and the rest.</span><br><span class="hljs-comment">// 保存本次要执行的BeanDefinitionRegistryPostProcessors</span><br>List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="hljs-comment">// 2. 调用所有实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类</span><br><span class="hljs-comment">// 找到所有实现BeanDefinitionRegistryPostProcessor接口的bean的name</span><br>String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 遍历处理所有符合规则的postProcessorNames</span><br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-comment">// 检查是否实现了PriorityOrdered接口</span><br><span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br><span class="hljs-comment">// 获取名字对应的bean实例，添加到currentRegistryProcessors中</span><br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br><span class="hljs-comment">// 将要被执行的BFPP名称添加到processedBeans中，避免后续重复执行</span><br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 按照优先级进行排序操作</span><br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br><span class="hljs-comment">// 添加到registryProcessors中，用于最后执行postProcessBeanFactory方法</span><br><span class="hljs-comment">// 前面第一步添加的是外部定义的BeanDefinitionRegistryPostProcessor，这一步将有排序的添加进去</span><br>registryProcessors.addAll(currentRegistryProcessors);<br><span class="hljs-comment">// 遍历currentRegistryProcessors，执行postProcessBeanDefinitionRegistry方法</span><br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br><span class="hljs-comment">// 执行完毕后清空currentRegistryProcessors</span><br>currentRegistryProcessors.clear();<br><br><span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="hljs-comment">// 3. 调用所有实现Ordered接口的BeanDefinitionRegistryPostProcessors实现类</span><br><span class="hljs-comment">// 找到所有实现BeanDefinitionRegistryPostProcessor接口的bean的name</span><br><span class="hljs-comment">// 为什么和第2步重复？因为在上面执行过程中可能会新增其他的BeanDefinitionRegistryPostProcessor</span><br>postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-comment">// 检查是否实现了Ordered接口，并且还未执行过</span><br><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br><span class="hljs-comment">// 获取名字对应的bean实例，添加到currentRegistryProcessors中</span><br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br><span class="hljs-comment">// 将要被执行的BFPP名称添加到processedBeans中，避免后续重复执行</span><br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 按照优先级进行排序操作</span><br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br><span class="hljs-comment">// 添加到registryProcessors中，用于最后执行postProcessBeanFactory方法</span><br>registryProcessors.addAll(currentRegistryProcessors);<br><span class="hljs-comment">// 遍历currentRegistryProcessors，执行postProcessBeanDefinitionRegistry方法</span><br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br><span class="hljs-comment">// 执行完毕后清空currentRegistryProcessors</span><br>currentRegistryProcessors.clear();<br><br><span class="hljs-comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="hljs-comment">// 最后，调用剩下的BeanDefinitionRegistryPostProcessor</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">reiterate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (reiterate) &#123;<br>reiterate = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 找到所有实现BeanDefinitionRegistryPostProcessor接口的bean的name</span><br>postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-comment">// 跳过已经执行过的</span><br><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;<br><span class="hljs-comment">// 获取名字对应的bean实例，添加到currentRegistryProcessors中</span><br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br><span class="hljs-comment">// 将要被执行的BFPP名称添加到processedBeans中，避免后续重复执行</span><br>processedBeans.add(ppName);<br><span class="hljs-comment">// 这里为true的原因是：</span><br><span class="hljs-comment">// 如果还有未处理的，下面会进行处理逻辑，在执行过程中很可能会再产生BeanDefinitionRegistryPostProcessor</span><br>reiterate = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 按照优先级进行排序操作</span><br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br><span class="hljs-comment">// 添加到registryProcessors中，用于最后执行postProcessBeanFactory方法</span><br>registryProcessors.addAll(currentRegistryProcessors);<br><span class="hljs-comment">// 遍历currentRegistryProcessors，执行postProcessBeanDefinitionRegistry方法</span><br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br><span class="hljs-comment">// 执行完毕后清空currentRegistryProcessors</span><br>currentRegistryProcessors.clear();<br>&#125;<br><br><span class="hljs-comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="hljs-comment">// 调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法</span><br><span class="hljs-comment">// 因为实现了BeanDefinitionRegistryPostProcessor接口一定也实现了BeanFactoryPostProcessor接口</span><br>invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);<br><span class="hljs-comment">// 调用入参beanFactoryPostProcessors中所有普通BeanFactoryPostProcessor的postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);<br>&#125;<br><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Invoke factory processors registered with the context instance.</span><br><span class="hljs-comment">// 如果beanFactory不属于BeanDefinitionRegistry类型，直接执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);<br>&#125;<br><br><span class="hljs-comment">// 到此为止，入参beanFactoryPostProcessors和容器中所有的BeanDefinitionRegistryPostProcessors已经全部处理完毕，</span><br><span class="hljs-comment">// 下面开始处理容器中通过@Component注解提供的BeanFactoryPostProcessor，而不是ac.addBeanFactoryPostProcessor提供的</span><br><span class="hljs-comment">// 上面执行的，仅仅是程序员通过add到spring容器中的beanFactoryPostProcessor</span><br><br><span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="hljs-comment">// 找到所有实现BeanFactoryPostProcessor的类</span><br>String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="hljs-comment">// Ordered, and the rest.</span><br><span class="hljs-comment">// 用于存放实现了PriorityOrdered接口BeanFactoryPostProcessor</span><br>List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 用于存放实现了Ordered接口BeanFactoryPostProcessor的name</span><br>List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 用于存放普通BeanFactoryPostProcessor的name</span><br>List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 遍历postProcessorNames，将实现的PriorityOrdered接口、rdered接口、普通三种区别开</span><br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;<br><span class="hljs-comment">// skip - already processed in first phase above</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>orderedPostProcessorNames.add(ppName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>nonOrderedPostProcessorNames.add(ppName);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="hljs-comment">// 对实现PriorityOrdered接口的BeanFactoryPostProcessor进行排序</span><br>sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><span class="hljs-comment">// 遍历实现PriorityOrdered接口的BeanFactoryPostProcessor，执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="hljs-comment">// 创建存放Ordered接口的集合</span><br>List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;<br><span class="hljs-comment">// 将实现Ordered接口的BeanFactoryPostProcessor添加到集合中</span><br>orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>&#125;<br><span class="hljs-comment">// 对实现Ordered接口的BeanFactoryPostProcessor进行排序</span><br>sortPostProcessors(orderedPostProcessors, beanFactory);<br><span class="hljs-comment">// 遍历实现Ordered接口的BeanFactoryPostProcessor，执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="hljs-comment">// 创建存放普通对象的集合</span><br>List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;<br><span class="hljs-comment">// 将普通的BeanFactoryPostProcessor添加到集合中</span><br>nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>&#125;<br><span class="hljs-comment">// 遍历普通的BeanFactoryPostProcessor，执行postProcessBeanFactory方法</span><br>invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span><br><span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="hljs-comment">// 清除元数据缓存（mergeBeanDefinitions、allBeanNamesByType、singletonBeanNameByType）</span><br><span class="hljs-comment">// 因为后置处理器可能已经修改了原始数据，比如：替换值中的占位符</span><br>beanFactory.clearMetadataCache();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-095-最长公共子序列"><a href="#剑指-Offer-II-095-最长公共子序列" class="headerlink" title="剑指 Offer II 095. 最长公共子序列"></a>剑指 Offer II 095. 最长公共子序列</h2><blockquote><p><a href="https://leetcode.cn/problems/qJnOS7/">https://leetcode.cn/problems/qJnOS7/</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：动态规划"><a href="#题解：动态规划" class="headerlink" title="题解：动态规划"></a>题解：动态规划</h4><p>状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;text1[i-<span class="hljs-number">1</span>]==text2[j-<span class="hljs-number">1</span>]<br>dp[i][j] = Max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);text1[i-<span class="hljs-number">1</span>]!=text2[j-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>最终计算得到<code>dp[len1][len2]</code>就是text1和text2的最长公共子序列长度。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162000920.png" alt="image-20230716200028347"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> text1.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> text2.length();<br>    <span class="hljs-comment">// 定义dp数组： 这里特殊处理，由于后面需要判断i-1和j-1，所以dp[0][0]、dp[0][j]、dp[i][0]需要预留，防止为空</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-099-最小路径之和"><a href="#剑指-Offer-II-099-最小路径之和" class="headerlink" title="剑指 Offer II 099. 最小路径之和"></a>剑指 Offer II 099. 最小路径之和</h2><blockquote><p><a href="https://leetcode.cn/problems/0i0mDW/description/">https://leetcode.cn/problems/0i0mDW/description/</a></p><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>一个机器人每次只能向下或者向右移动一步。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162022825.png" alt="image-20230716202256838"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维数组dp"><a href="#题解：二维数组dp" class="headerlink" title="题解：二维数组dp"></a>题解：二维数组dp</h4><p>动态转移方程：<code>dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-keyword">if</span> (grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][col];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 第一行特殊处理，直接在前一列基础上累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>    &#125;<br>    <span class="hljs-comment">// 第一列特殊处理，直接在前一行基础上累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// 其他情况去上下相邻的最小值累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>            dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维数组dp"><a href="#题解：一维数组dp" class="headerlink" title="题解：一维数组dp"></a>题解：一维数组dp</h4><p>优化空间的思路见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-keyword">if</span> (grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[col];<br>    dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 第一行特殊处理，直接在前一列基础上累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>        dp[j] = dp[j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>    &#125;<br>    <span class="hljs-comment">// 其他情况去上下相邻的最小值累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i ++) &#123;<br>        <span class="hljs-comment">// 遍历到第0列时，其实原二维第[i-1][0]位置记录已经无效了，可以压缩到dp[0]转为1维数组</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 例如：</span><br><span class="hljs-comment">             *  1 3 1</span><br><span class="hljs-comment">             *  1 5 1</span><br><span class="hljs-comment">             *  4 2 1</span><br><span class="hljs-comment">             *  i = 0时, dp为：1 3 1</span><br><span class="hljs-comment">             *  i = 1时, dp[0]为 1+1=2，此时dp数组为：2 3 1</span><br><span class="hljs-comment">             *  接上一步j = 1时，dp[1] = min(dp[0], dp[1]) + grid[1][1]</span><br><span class="hljs-comment">             *  实则还是dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="hljs-comment">             *  只是dp[0][0]处元素在i=1和j=1时没用，将dp[1][0]滚动到dp[0][0]而已，就优化成一维数组</span><br><span class="hljs-comment">             */</span><br>        dp[<span class="hljs-number">0</span>] += grid[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>            dp[j] = Math.min(dp[j - <span class="hljs-number">1</span>], dp[j]) + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[col - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-089-房屋偷盗"><a href="#剑指-Offer-II-089-房屋偷盗" class="headerlink" title="剑指 Offer II 089. 房屋偷盗"></a>剑指 Offer II 089. 房屋偷盗</h2><blockquote><p><a href="https://leetcode.cn/problems/Gu0c2T/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/Gu0c2T/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：数组dp"><a href="#题解：数组dp" class="headerlink" title="题解：数组dp"></a>题解：数组dp</h4><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 <code>k (k&gt;2) </code>间房屋，有两个选项：</p><ul><li><p>偷窃第 k 间房屋，那么就不能偷窃第 <code>k−1</code>间房屋，偷窃总金额为前 <code>k−2</code> 间房屋的最高总金额与第 k间房屋的金额之和。</p></li><li><p>不偷窃第 k 间房屋，偷窃总金额为前 <code>k−1</code> 间房屋的最高总金额。</p></li></ul><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前k 间房屋能偷窃到的最高总金额。</p><p>用<code>dp[i]</code> 表示前 <code>i</code>间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><p><code>dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);</code></p><p>边界条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">// 只有一间房屋，则偷窃该房屋</span><br>dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 只有两间房屋，选择其中金额较高的房屋进行偷窃</span><br></code></pre></td></tr></table></figure><p>最终的答案即为<code>dp[len - 1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果房间梳理大于两间，有两个选项：</span><br><span class="hljs-comment"> * 1. 偷窃第k个房屋，就不能偷第k-1个房屋，偷窃总额为前k-2个房屋最高总额与第k间房屋的金额之和</span><br><span class="hljs-comment"> * 2. 不偷窃第k个房屋，偷窃总金额为前k-1间房屋最高总金额</span><br><span class="hljs-comment"> * dp[i]表示前i间房屋能偷窃的最大金额，状态转移方程如下：</span><br><span class="hljs-comment"> * dp[i] = Max(dp[i - 2] + nums[i], dp[i - 1])</span><br><span class="hljs-comment"> * 边界条件：</span><br><span class="hljs-comment"> * dp[0] = nums[0] 只有一间房屋</span><br><span class="hljs-comment"> * dp[1] = max(nums[0], nums[1]) 只有两间房屋</span><br><span class="hljs-comment"> * 最后结果：dp[nums.length - 1]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 对每个房间都有偷与不偷两种选择</span><br>        <span class="hljs-comment">// 假如偷：则上一个房间被偷的只能是i-2，加上本间房金额为：dp[i-2]+nums[i]</span><br>        <span class="hljs-comment">// 加入不偷：则上一次被偷的房间是i-1，当前房间由于不被偷，总价值还是dp[i-1]</span><br>        <span class="hljs-comment">// 两则去最大值</span><br>        dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：滚动数组"><a href="#题解：滚动数组" class="headerlink" title="题解：滚动数组"></a>题解：滚动数组</h4><p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], second = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> second;<br>            second = Math.max(first + nums[i], second);<br>            first = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-090-环形房屋偷盗"><a href="#剑指-Offer-II-090-环形房屋偷盗" class="headerlink" title="剑指 Offer II 090. 环形房屋偷盗"></a>剑指 Offer II 090. 环形房屋偷盗</h2><blockquote><p><a href="https://leetcode.cn/problems/PzWKhm/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/PzWKhm/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：分两段dp"><a href="#题解：分两段dp" class="headerlink" title="题解：分两段dp"></a>题解：分两段dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 由于相邻房屋不能偷窃，又由于房屋是环形的，所以有以下规则</span><br><span class="hljs-comment"> * 1. 偷窃了第一间房屋则不能偷窃最后一间，此时偷窃的房屋范围是[0, length - 2]</span><br><span class="hljs-comment"> * 2. 偷窃了最后一间房屋则不能偷窃第一间，此时偷窃的房屋范围是[1, length - 1]</span><br><span class="hljs-comment"> * 所以，分别寻找上面两个范围的偷窃最大值，然后再取两个范围最大值即为结果</span><br><span class="hljs-comment"> * 寻找单个区间范围最大值思路和房屋偷盗思路一样，只不过不用数据，而是用变量来记录最大值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>     &#125;<br>     <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>) &#123;<br>         <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>     &#125;<br>     <span class="hljs-keyword">return</span> Math.max(robDp(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>), robDp(nums, <span class="hljs-number">1</span>, nums.length));<br> &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> Math.max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 假设nums如下： 1     2    3     3  4</span><br><span class="hljs-comment">         *              fir  sec   i</span><br><span class="hljs-comment">         *              每次second和nums[i]+first</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">2</span>; i &lt; end; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> second;<br>        second = Math.max(nums[i] + first, second);<br>        first = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> second;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-091-粉刷房子"><a href="#剑指-Offer-II-091-粉刷房子" class="headerlink" title="剑指 Offer II 091. 粉刷房子"></a>剑指 Offer II 091. 粉刷房子</h2><blockquote><p><a href="https://leetcode.cn/problems/JEj789/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/JEj789/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>假如有一排房子，共 <code>n</code> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 <code>n x 3</code> 的正整数矩阵 <code>costs</code> 来表示的。</p><p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成绿色的花费，以此类推。</p><p>请计算出粉刷完所有房子最少的花费成本。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: costs = <span class="hljs-string">[[17,2,17],[16,16,5],[14,3,19]]</span><br>输出: <span class="hljs-number">10</span><br>解释: 将 <span class="hljs-number">0</span> 号房子粉刷成蓝色，<span class="hljs-number">1</span> 号房子粉刷成绿色，<span class="hljs-number">2</span> 号房子粉刷成蓝色。<br>     最少花费: <span class="hljs-number">2</span> + <span class="hljs-number">5</span> + <span class="hljs-number">3</span> = <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维数组dp-1"><a href="#题解：二维数组dp-1" class="headerlink" title="题解：二维数组dp"></a>题解：二维数组dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] costs)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> costs.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][<span class="hljs-number">3</span>];<br>    System.arraycopy(costs[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) + costs[i][<span class="hljs-number">0</span>];<br>        dp[i][<span class="hljs-number">1</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) + costs[i][<span class="hljs-number">1</span>];<br>        dp[i][<span class="hljs-number">2</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) + costs[i][<span class="hljs-number">2</span>];<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> Arrays.stream(dp[row - <span class="hljs-number">1</span>]).min().getAsInt();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维dp"><a href="#题解：一维dp" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostV2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] costs)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> costs.length;<br>    <span class="hljs-comment">// 二维dp数组简化为一维</span><br>    <span class="hljs-comment">// 因为dp数组只需要记录前面一间房最小花费即可</span><br>    <span class="hljs-comment">// dp数组含义：刷到当前房间时每种颜色的最小花费</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>    System.arraycopy(costs[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, dp, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 从第2行开始计算，因为第1间房最小花费不用计算</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-comment">// 因为dp数组在为每一间房赋值过程中不能变化，所以需要有一个临时数组</span><br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-comment">// 这里巧妙的使用(j + 1) % 3和(j + 2) % 3来使相邻房间颜色不重复</span><br>            <span class="hljs-comment">// 只需要去前面一间房最小费用当前房间颜色花费保存即可</span><br>            tmp[j] = Math.min(dp[(j + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], dp[(j + <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>]) + costs[i][j];<br>        &#125;<br>        dp = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Arrays.stream(dp).min().getAsInt();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-092-翻转字符"><a href="#剑指-Offer-II-092-翻转字符" class="headerlink" title="剑指 Offer II 092. 翻转字符"></a>剑指 Offer II 092. 翻转字符</h2><blockquote><p><a href="https://leetcode.cn/problems/cyJERH/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/cyJERH/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>如果一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串，是以一些 <code>&#39;0&#39;</code>（可能没有 <code>&#39;0&#39;</code>）后面跟着一些 <code>&#39;1&#39;</code>（也可能没有 <code>&#39;1&#39;</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p><p>我们给出一个由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串 s，我们可以将任何 <code>&#39;0&#39;</code> 翻转为 <code>&#39;1&#39;</code> 或者将 <code>&#39;1&#39;</code> 翻转为 <code>&#39;0&#39;</code>。</p><p>返回使 s <strong>单调递增</strong> 的最小翻转次数。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00110&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：我们翻转最后一位得到 <span class="hljs-number">00111</span>.<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：dp"><a href="#题解：dp" class="headerlink" title="题解：dp"></a>题解：dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// dp0表示遍历到第i个元素如果是0最小翻转次数</span><br>    <span class="hljs-comment">// dp1表示遍历到第i个元素如果是1最小翻转次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, dp1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) &#123;<br>        <span class="hljs-comment">// 遍历到第i个元素时如果取1，则i-1个元素可以是1，也可以是0，所以需要取两者最小值</span><br>        dp1 = Math.min(dp1, dp0) + (ch == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        dp0 += (ch == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.min(dp0, dp1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-093-最长斐波那契数列"><a href="#剑指-Offer-II-093-最长斐波那契数列" class="headerlink" title="剑指 Offer II 093. 最长斐波那契数列"></a>剑指 Offer II 093. 最长斐波那契数列</h2><blockquote><p><a href="https://leetcode.cn/problems/Q91FMA/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/Q91FMA/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p><ul><li><code>n &gt;= 3</code></li><li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_&#123;i+1&#125; = X_&#123;i+2&#125;</code></li></ul><p>给定一个<strong>严格递增</strong>的正整数数组形成序列 <code>arr</code> ，找到 <code>arr</code> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p><p><em>（回想一下，子序列是从原序列 <code>arr</code> 中派生出来的，它从 <code>arr</code> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: arr = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>]<br>输出: <span class="hljs-number">5</span><br>解释: 最长的斐波那契式子序列为 [<span class="hljs-number">1,2,3,5</span>,<span class="hljs-number">8</span>] 。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp"><a href="#题解：二维dp" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-comment">// 由于arr是递增有序的，所以判断下标即可判断arr中是否有该值</span><br>    Map&lt;Integer, Integer&gt; indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        indexMap.put(arr[i], i);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历arr数组，以每个arr[i]作为第3个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 遍历arr[0, i)的元素，作为第2个元素</span><br>        <span class="hljs-comment">// 这里为了少遍历，增加了一个条件arr[j] * 2 &gt; arr[i]</span><br>        <span class="hljs-comment">// 原因：假设第一个元素为arr[index], 则有arr[index]+arr[j]=arr[i]，同时index&lt;j&lt;i并且arr[index]&lt;arr[j]&lt;arr[i]</span><br>        <span class="hljs-comment">// 所以欲满足arr[index]+arr[j]=arr[i]，必有arr[j]+arr[j]&gt;arr[i]，这样可以省去遍历很多元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] * <span class="hljs-number">2</span> &gt; arr[i]; j--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> indexMap.getOrDefault(arr[i] - arr[j], -<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 如果存在第一个值，则说明找到一个序列index, j, i可以组成斐波那契数列</span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果index, j之前就是斐波那数列，则第i个元素也满足就相当于在之前数列上延续，直接+1</span><br>                <span class="hljs-comment">// 否则找到一个序列就是长度为3，比如一开始的1,2,3</span><br>                dp[j][i] = Math.max(dp[index][j] + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>            &#125;<br>            ans = Math.max(ans, dp[j][i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-096-字符串交织"><a href="#剑指-Offer-II-096-字符串交织" class="headerlink" title="剑指 Offer II 096. 字符串交织"></a>剑指 Offer II 096. 字符串交织</h2><blockquote><p><a href="https://leetcode.cn/problems/IY6buf/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/IY6buf/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请判断 <code>s3</code> 能不能由 <code>s1</code> 和 <code>s2</code> <strong>交织（交错）</strong> 组成。</p><p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交织</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p><ul><li><code>s = s1 + s2 + ... + sn</code></li><li><code>t = t1 + t2 + ... + tm</code></li><li><code>|n - m| &lt;= 1</code></li><li><strong>交织</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li></ul><p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbcbcac&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-1"><a href="#题解：二维dp-1" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> s2.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len3</span> <span class="hljs-operator">=</span> s3.length();<br>    <span class="hljs-keyword">if</span> (len1 + len2 != len3) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// dp[i][j]含义：s1的前i个字符和s2的前j个字符是否能交织成s3前i+j-1个字符</span><br>    <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 设置初始值，因为s1[0],s2[0]不一定能组成s3[0]，所以下面遍历从下标1开始</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 矩阵按行从左到右更新，每次更新仅需本行当前更新元素的前一个元素及前一行的同列元素</span><br>            <span class="hljs-comment">// 即每次更新只需要矩阵左侧和上侧元素，所以可以转为一维数组</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 这里需要判断s1是否满足, 所以要或一下dp[i][j]，表示s1或s2有一个满足条件即可</span><br>                dp[i][j] = dp[i][j] || dp[i][j - <span class="hljs-number">1</span>] &amp;&amp; s2.charAt(j - <span class="hljs-number">1</span>) == s3.charAt(k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维dp-1"><a href="#题解：一维dp-1" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> s2.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len3</span> <span class="hljs-operator">=</span> s3.length();<br>    <span class="hljs-keyword">if</span> (len1 + len2 != len3) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len2 + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] = dp[j] &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] = dp[j] || (dp[j - <span class="hljs-number">1</span>] &amp;&amp; s2.charAt(j - <span class="hljs-number">1</span>) == s3.charAt(k));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len2];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-098-路径的数目"><a href="#剑指-Offer-II-098-路径的数目" class="headerlink" title="剑指 Offer II 098. 路径的数目"></a>剑指 Offer II 098. 路径的数目</h2><blockquote><p><a href="https://leetcode.cn/problems/2AoeFn/description/">https://leetcode.cn/problems/2AoeFn/description/</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162038839.png" alt="image-20230716203818229"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-2"><a href="#题解：二维dp-2" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 第一行和第一列默认为1</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; j != <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：一维dp-2"><a href="#题解：一维dp-2" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[j] += dp[j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-100-三角形中最小路径之和"><a href="#剑指-Offer-II-100-三角形中最小路径之和" class="headerlink" title="剑指 Offer II 100. 三角形中最小路径之和"></a>剑指 Offer II 100. 三角形中最小路径之和</h2><blockquote><p><a href="https://leetcode.cn/problems/IlPe0q/description/">https://leetcode.cn/problems/IlPe0q/description/</a></p><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-3"><a href="#题解：二维dp-3" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三角形数组</span><br><span class="hljs-comment"> * 2    0   0   0</span><br><span class="hljs-comment"> * 3    4   0   0</span><br><span class="hljs-comment"> * 6    5   7   0</span><br><span class="hljs-comment"> * 4    1   8   3</span><br><span class="hljs-comment"> * 构造一个dp数组，长宽和上面一致</span><br><span class="hljs-comment"> * 设置dp[0][0] = t[0][0]，因为是起点</span><br><span class="hljs-comment"> * dp状态转移方程分下面几个情况：</span><br><span class="hljs-comment"> * 1. 如果是第一列，则dp[i][0] = dp[i - 1][0] + t[i][0]，因为第一列只能通过上一层来改变</span><br><span class="hljs-comment"> * 2. 如果是对角线，则dp[i][i] = dp[i-1][j-1] + t[i][i]，因为对角线状态的更改只能通过[i-1][j-1]处来改变</span><br><span class="hljs-comment"> * 3. 其他情况：dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + t[i][j];</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.get(m - <span class="hljs-number">1</span>).size();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 第一列特殊处理</span><br>                dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + triangle.get(i).get(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 其他情况取最小值</span><br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 对角线状态的更改只能通过[i-1][j-1]处来改变特殊处理</span><br>        dp[i][i] = dp[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + triangle.get(i).get(i);<br>    &#125;<br>    <span class="hljs-comment">// 寻找最后一行最小值即可</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        ans = Math.min(ans, dp[m - <span class="hljs-number">1</span>][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-101-分割等和子集"><a href="#剑指-Offer-II-101-分割等和子集" class="headerlink" title="剑指 Offer II 101. 分割等和子集"></a>剑指 Offer II 101. 分割等和子集</h2><blockquote><p><a href="https://leetcode.cn/problems/NUPfPr/description/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/NUPfPr/description/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定一个非空的正整数数组 <code>nums</code> ，请判断能否将这些数字分成元素和相等的两部分。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：nums 可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> 。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：0-1背包问题"><a href="#题解：0-1背包问题" class="headerlink" title="题解：0-1背包问题"></a>题解：0-1背包问题</h4><p>题目可以转换为：从数组Nums中寻找元素能装满sum(nums)&#x2F;2容量的背包。</p><p>前面有些细节条件可以去掉很多测试用例：</p><ol><li>数组元素之和不能被2整除</li><li>数组中最大值比所有元素之和一半还大</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        maxNum = Math.max(maxNum, num);<br>    &#125;<br>    <span class="hljs-comment">// 数组元素相加和不能被2整除，说明不能分为两个相等的部分</span><br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 如果最大值比总和一半还大，也不n呢个分为两个相等的部分</span><br>    <span class="hljs-keyword">if</span> (maxNum &gt; target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义数组，使用0-1背包来解决此问题</span><br>    <span class="hljs-comment">// 问题转化为在数组中能否选取合适元素，使得和为target</span><br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= num; j--) &#123;<br>            <span class="hljs-comment">// 当前容量状态取决于不装num和装num，不装num是dp[j]，装num是dp[j-num]</span><br>            dp[j] |= dp[j - num];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-102-加减的目标值"><a href="#剑指-Offer-II-102-加减的目标值" class="headerlink" title="剑指 Offer II 102. 加减的目标值"></a>剑指 Offer II 102. 加减的目标值</h2><blockquote><p><a href="https://leetcode.cn/problems/YaVDxD/description/">https://leetcode.cn/problems/YaVDxD/description/</a></p><p>给定一个正整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：0-1背包问题-1"><a href="#题解：0-1背包问题-1" class="headerlink" title="题解：0-1背包问题"></a>题解：0-1背包问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 问题可以转化为0-1背包问题：</span><br><span class="hljs-comment"> * 对数组[1,1,1,1,1]</span><br><span class="hljs-comment"> * 设添加+号的元素之和为pos，添加-号的元素之和为neg</span><br><span class="hljs-comment"> * 则有：pos + neg = sum, pos - neg = target</span><br><span class="hljs-comment"> * 组合方程得到：pos = (sum + target) / 2,  neg = (sum - target) / 2</span><br><span class="hljs-comment"> * 所以上面问题化为：给定一个背包neg，从数组中找到一些数字（每个数字可以选一次），使得选出的数字和刚好等于pos或者neg。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-comment">// 去掉特殊情况</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> sum - target;<br>    <span class="hljs-keyword">if</span> (sum &lt; target || diff % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算背包容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">neg</span> <span class="hljs-operator">=</span> diff / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 0-1 背包</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[neg + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 背包容量为0时，可以选择不选任何数，所以有一种方案</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> neg; j &gt;= num; j--) &#123;<br>            <span class="hljs-comment">// dp[j]表示容量为j时刚好装满的方案数</span><br>            dp[j] += dp[j - num];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[neg];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-103-最少的硬币数目"><a href="#剑指-Offer-II-103-最少的硬币数目" class="headerlink" title="剑指 Offer II 103. 最少的硬币数目"></a>剑指 Offer II 103. 最少的硬币数目</h2><blockquote><p><a href="https://leetcode.cn/problems/gaM7Ch/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/gaM7Ch/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>+ 1<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一维dp-3"><a href="#题解：一维dp-3" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// dp[i]表示装满容量i需要的最少硬币数目</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 容量最大为amount，假设硬币有1，则需要的最多的硬币数据为amount，这里初始化数组为最大值（表示每个容量默认都不可能装满）</span><br>    Arrays.fill(dp, amount + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 容量为0不需要装</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 针对每个容量，使用不同币种去填充，然后不同币种取最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= amount; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>            <span class="hljs-comment">// 如果该coin小于本次要装的背包容量</span><br>            <span class="hljs-keyword">if</span> (coin &lt;= i) &#123;<br>                <span class="hljs-comment">// 因为有多个币种，所以取最小的那个币种的方案</span><br>                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? -<span class="hljs-number">1</span> : dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-104-排列的数目"><a href="#剑指-Offer-II-104-排列的数目" class="headerlink" title="剑指 Offer II 104. 排列的数目"></a>剑指 Offer II 104. 排列的数目</h2><blockquote><p><a href="https://leetcode.cn/problems/D0F0SV/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/D0F0SV/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定一个由 <strong>不同</strong> 正整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p><p>题目数据保证答案符合 32 位整数范围。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一维dp-4"><a href="#题解：一维dp-4" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><p>用 <code>dp[x] </code>表示选取的元素之和等于 x 的方案数，目标是求 <code>dp[target]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= target; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &lt;= i) &#123;<br>                dp[i] += dp[i - num];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2770-达到末尾下标所需的最大跳跃次数"><a href="#2770-达到末尾下标所需的最大跳跃次数" class="headerlink" title="2770. 达到末尾下标所需的最大跳跃次数"></a>2770. 达到末尾下标所需的最大跳跃次数</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/description/">https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/description/</a></p><p>给你一个下标从 <strong>0</strong> 开始、由 <code>n</code> 个整数组成的数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>你的初始位置在下标 <code>0</code> 。在一步操作中，你可以从下标 <code>i</code> 跳跃到任意满足下述条件的下标 <code>j</code> ：</p><ul><li><code>0 &lt;= i &lt; j &lt; n</code></li><li><code>-target &lt;= nums[j] - nums[i] &lt;= target</code></li></ul><p>返回到达下标 <code>n - 1</code> 处所需的 <strong>最大跳跃次数</strong> 。</p><p>如果无法到达下标 <code>n - 1</code> ，返回 <code>-1</code> 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,3,6,4,1,2], target = 2<br>输出：3<br>解释：要想以最大跳跃次数从下标<span class="hljs-number"> 0 </span>到下标 n -<span class="hljs-number"> 1 </span>，可以按下述跳跃序列执行操作：<br>- 从下标<span class="hljs-number"> 0 </span>跳跃到下标<span class="hljs-number"> 1 </span>。 <br>- 从下标<span class="hljs-number"> 1 </span>跳跃到下标<span class="hljs-number"> 3 </span>。 <br>- 从下标<span class="hljs-number"> 3 </span>跳跃到下标<span class="hljs-number"> 5 </span>。 <br>可以证明，从<span class="hljs-number"> 0 </span>到 n -<span class="hljs-number"> 1 </span>的所有方案中，不存在比<span class="hljs-number"> 3 </span>步更长的跳跃序列。因此，答案是<span class="hljs-number"> 3 </span>。 <br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一维dp-5"><a href="#题解：一维dp-5" class="headerlink" title="题解：一维dp"></a>题解：一维dp</h4><p>定义<code>dp[i]</code>表示跳跃到i位置时最大跳跃次数。</p><p> 对于位置<code>nums[i]</code>来说，必然从<code>[0, i-1]</code>中某个位置跳转得来，即<code>dp[i] = dp[j] + 1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumJumps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    <span class="hljs-comment">// 初始值每个位置设为不可达，即-1</span><br>    Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 位置0时最大跳跃数为0</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-comment">// 如果符合条件，并且j位置可达，说明i位置可以从j跳跃而来 dp[i] = dp[j] + 1</span><br>            <span class="hljs-comment">// 由于要取最大跳跃数，所以要取最大值</span><br>            <span class="hljs-keyword">if</span> (Math.abs(nums[i] - nums[j]) &lt;= target &amp;&amp; dp[j] != -<span class="hljs-number">1</span>) &#123;<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931. 下降路径最小和"></a>931. 下降路径最小和</h2><blockquote><p><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">https://leetcode.cn/problems/minimum-falling-path-sum/</a></p><p>给你一个 <code>n x n</code> 的 <strong>方形</strong> 整数数组 <code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong> 的 <strong>最小和</strong> 。</p><p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307162107722.png" alt="image-20230716210708184" style="zoom:50%;" /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[2,1,3],[6,5,4],[7,8,9]]</span><br>输出：<span class="hljs-number">13</span><br>解释：如图所示，为和最小的两条下降路径<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二维dp-4"><a href="#题解：二维dp-4" class="headerlink" title="题解：二维dp"></a>题解：二维dp</h4><p>给你一个<code> n x n</code> 的方形 整数数组 <code>matrix </code>，请你找出并返回通过 <code>matrix </code>的下降路径 的 最小和 。</p><p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。</p><p>在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。</p><p>具体来说，位置 <code>(row, col)</code> 的下一个元素应当是<code> (row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者<code> (row + 1, col + 1)</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= row; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = Integer.MAX_VALUE;<br>    &#125;<br><br>    Arrays.fill(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= col; j++) &#123;<br>            dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], j + <span class="hljs-number">1</span> &lt;= col ? dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] : Integer.MAX_VALUE))<br>                + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= col; i++) &#123;<br>        ans = Math.min(dp[row][i], ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-075-数组相对排序"><a href="#剑指-Offer-II-075-数组相对排序" class="headerlink" title="剑指 Offer II 075. 数组相对排序"></a>剑指 Offer II 075. 数组相对排序</h2><blockquote><p><a href="https://leetcode.cn/problems/0H97ZC/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/0H97ZC/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定两个数组，<code>arr1</code> 和 <code>arr2</code>，</p><ul><li><code>arr2</code> 中的元素各不相同</li><li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li></ul><p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr1 = [<span class="hljs-number">2,3,1,3</span>,<span class="hljs-number">2,4,6,7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">19</span>], arr2 = [<span class="hljs-number">2,1,4,3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">2,2,2,1</span>,<span class="hljs-number">4,3,3,9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：计数排序"><a href="#题解：计数排序" class="headerlink" title="题解：计数排序"></a>题解：计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] relativeSortArray(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>    <span class="hljs-comment">// 为节省空间，可以先算出数组中最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr1) &#123;<br>        max = Math.max(v, max);<br>    &#125;<br>    <span class="hljs-comment">// 初始化max+1空间数组</span><br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 统计arr1中每个数字出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr1) &#123;<br>        count[v]++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr1.length];<br>    <span class="hljs-comment">// 此时以arr2数组中的顺序为主（计数排序是以统计次数的数组下标来遍历，因为下标是有序的）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr2) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count[v]; i++) &#123;<br>            res[index++] = v;<br>        &#125;<br>        <span class="hljs-comment">// 每个数填完后次数归0</span><br>        count[v] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后遍历计数数组，按照下标遍历，因为这样arr1中剩下数组就会按照有序排列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= max; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; count[i]; j++) &#123;<br>            res[index++] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql的limit原理及分页查询优化</title>
    <link href="/MySQL/LIMIT%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/"/>
    <url>/MySQL/LIMIT%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在进行分页查询的时候，通常会使用LIMIT加偏移量的办法实现，但当偏移量非常大的时候，例如：LIMIT 10000， 20这样的查询，这是MySQL需要查询10020条记录然后只返回20条，前面的10000条都将会抛弃。这样的代价就非常高。</p></blockquote><p>优化上述查询，有两种方案供选择：</p><ul><li>在页面中限制分页的数量</li><li>优化大偏移量的性能</li></ul><p><strong>使用索引覆盖扫描，不查询所有的列，然后根据需要进行一次关联，再返回所需的列</strong></p><p>例如下面查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5;<br></code></pre></td></tr></table></figure><p>当偏移量很大的时候，可以改成下面查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film.film_id, film.description FROM sakila.film INNER JOIN (<br>SELECT film_id FROM sakila.film ORDER BY title LIMIT 50, 5<br>) AS lim USING(film_id);<br></code></pre></td></tr></table></figure><p>这里先获取需要访问的记录，然后再根据关联列回原表查询所需要的列。</p><hr><p><strong>将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得到对应的结果</strong></p><p>可以根据索引列，预先计算边界值，上面查询可以修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film_id, description FROM sakila.film<br>WHERE position BETWEEN 50 AND 54 ORDER BY position;<br></code></pre></td></tr></table></figure><hr><blockquote><p>LIMIT和OFFSET的问题，实际上是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。</p></blockquote><p><strong>可以使用标记记录上次读取数据的位置，下次就可以直接从该标记的位置开始扫描，这样可以避免OFFSET</strong></p><p>假设使用下面查询获取第一条结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM sakila.rental<br>ORDER BY rental_id DESC LIMIT 20;<br></code></pre></td></tr></table></figure><p>假设上面查询的是主键16049到16030的租界记录，下一页查询就可以从16030这个点开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM sakila.rental<br>WHERE rental_id &lt; 16030<br>ORDER BY rental_id DESC LIMIT 2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel限流原理</title>
    <link href="/Sentinel/Sentinel%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86/"/>
    <url>/Sentinel/Sentinel%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="SphU-entry-入口"><a href="#SphU-entry-入口" class="headerlink" title="SphU.entry 入口"></a>SphU.entry 入口</h2><p>从<code>SphU.entry()</code>方法向下执行，会进入到下面这个方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">entryWithPriority</span><span class="hljs-params">(ResourceWrapper resourceWrapper, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>       <span class="hljs-keyword">throws</span> BlockException &#123;<br>       <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> ContextUtil.getContext();<br>       <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> NullContext) &#123;<br>           <span class="hljs-comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span><br>           <span class="hljs-comment">// so here init the entry only. No rule checking will be done.</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// Using default context.</span><br>           context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);<br>       &#125;<br><br>       <span class="hljs-comment">// Global switch is close, no rule checking will do.</span><br>       <span class="hljs-comment">// 1. 全局开关关闭，说明没有规则检查，直接返回一个CtEntry对象，不再进行后续的限流检测</span><br>       <span class="hljs-keyword">if</span> (!Constants.ON) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-comment">// 2. 根据包装过的资源获取对应的SlotChain</span><br>       ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;,</span><br><span class="hljs-comment">        * so no rule checking will be done.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, chain, context, count, args);<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 3. 执行SlotChain的entry方法，如果SlotChain的entry方法抛出了BlockException，则将该异常继续向上抛出，如果SlotChain的entry方法正常执行了，则最后会将该entry对象返回</span><br>           chain.entry(context, resourceWrapper, <span class="hljs-literal">null</span>, count, prioritized, args);<br>       &#125; <span class="hljs-keyword">catch</span> (BlockException e1) &#123;<br>           e.exit(count, args);<br>           <span class="hljs-comment">// 4. 如果上层方法捕获了BlockException，则说明请求被限流了，否则请求能正常执行</span><br>           <span class="hljs-keyword">throw</span> e1;<br>       &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br>           <span class="hljs-comment">// This should not happen, unless there are errors existing in Sentinel internal.</span><br>           RecordLog.info(<span class="hljs-string">&quot;Sentinel unexpected exception&quot;</span>, e1);<br>       &#125;<br>       <span class="hljs-keyword">return</span> e;<br>   &#125;<br></code></pre></td></tr></table></figure><p>该方法主要实现了下面几点：</p><ol><li>全局开关关闭，说明没有规则检查，直接返回一个 CtEntry 对象，不再进行后续的限流检测。</li><li>根据包装过的资源获取对应的 SlotChain。</li><li>执行 SlotChain 的 entry 方法，如果 SlotChain 的 entry 方法抛出了 BlockException，则将该异常继续向上抛出，如果 SlotChain 的 entry 方法正常执行了，则最后会将该 entry 对象返回。</li><li>如果上层方法捕获了 BlockException，则说明请求被限流了，否则请求能正常执行。</li></ol><h2 id="SlotChain-的链路获取"><a href="#SlotChain-的链路获取" class="headerlink" title="SlotChain 的链路获取"></a>SlotChain 的链路获取</h2><p>重点关注一下<strong>SlotChain</strong>链路的获取逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java">ProcessorSlot&lt;Object&gt; <span class="hljs-title function_">lookProcessChain</span><span class="hljs-params">(ResourceWrapper resourceWrapper)</span> &#123;<br>    <span class="hljs-comment">// 这里使用两次判断为null(双重检查锁或缓存机制)的原因如下：</span><br>    <span class="hljs-comment">// 假设有两个线程A，B同时到达第一个if，都为null，此时A线程进入synchronized</span><br>    <span class="hljs-comment">// 遇到第二个if，当然还是null，A线程就会执行第二个if里面的语句，创建一个chain，然后存到缓存中，退出synchronized</span><br>    <span class="hljs-comment">// B线程进入synchronized，获取chain，但此时缓存命中，就不用再执行第二个if里面的语句了，减少了synchronized锁的时间</span><br>    <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> chainMap.get(resourceWrapper);<br>    <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>            chain = chainMap.get(resourceWrapper);<br>            <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Entry size limit.</span><br>                <span class="hljs-keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br><span class="hljs-comment">// 构造SlotChain</span><br>                chain = SlotChainProvider.newSlotChain();<br><br>               <span class="hljs-comment">// map扩容</span><br>                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;ResourceWrapper, ProcessorSlotChain&gt;(<br>                    chainMap.size() + <span class="hljs-number">1</span>);<br>                newMap.putAll(chainMap);<br>                <span class="hljs-comment">// 将资源和slot-chain映射</span><br>                newMap.put(resourceWrapper, chain);<br>                chainMap = newMap;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> chain;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessorSlotChain <span class="hljs-title function_">newSlotChain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (slotChainBuilder != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> slotChainBuilder.build();<br>    &#125;<br><br>    <span class="hljs-comment">// Resolve the slot chain builder SPI.</span><br>    <span class="hljs-comment">// 从com.alibaba.csp.sentinel.slotchain.ProcessorSlot文件中读取slot构建slot chain</span><br>    slotChainBuilder = SpiLoader.of(SlotChainBuilder.class).loadFirstInstanceOrDefault();<br><br>    <span class="hljs-comment">// 确保slotChainBuilder不为null</span><br>    <span class="hljs-keyword">if</span> (slotChainBuilder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Should not go through here.</span><br>        RecordLog.warn(<span class="hljs-string">&quot;[SlotChainProvider] Wrong state when resolving slot chain builder, using default&quot;</span>);<br>        slotChainBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSlotChainBuilder</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        RecordLog.info(<span class="hljs-string">&quot;[SlotChainProvider] Global slot chain builder resolved: &#123;&#125;&quot;</span>,<br>                       slotChainBuilder.getClass().getCanonicalName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> slotChainBuilder.build();<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSlotChainBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SlotChainBuilder</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ProcessorSlotChain <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultProcessorSlotChain</span>();<br><br>        List&lt;ProcessorSlot&gt; sortedSlotList = SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted();<br>        <span class="hljs-keyword">for</span> (ProcessorSlot slot : sortedSlotList) &#123;<br>            <span class="hljs-keyword">if</span> (!(slot <span class="hljs-keyword">instanceof</span> AbstractLinkedProcessorSlot)) &#123;<br>                RecordLog.warn(<span class="hljs-string">&quot;The ProcessorSlot(&quot;</span> + slot.getClass().getCanonicalName() + <span class="hljs-string">&quot;) is not an instance of AbstractLinkedProcessorSlot, can&#x27;t be added into ProcessorSlotChain&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            chain.addLast((AbstractLinkedProcessorSlot&lt;?&gt;) slot);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> chain;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Sentinel 里面，所有的资源都对应一个资源名称（<code>resourceName</code>），每次资源调用都会创建一个 <code>Entry</code> 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>SphU</code> API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p><ul><li>**<code>NodeSelectorSlot</code>**：收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</li><li><strong><code>ClusterBuilderSlot</code></strong> ：用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><strong><code>StatisticSlot</code></strong> ：用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><strong><code>SystemSlot</code></strong> ：通过系统的状态，来控制总的入口流量；</li><li><strong><code>AuthoritySlot</code></strong> ：根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><strong><code>FlowSlot</code></strong> ：用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><strong><code>DegradeSlot</code></strong> ：通过统计信息以及预设的规则，来做熔断降级；</li></ul><p>下面借用官网的图片：官方链接如下：<a href="https://sentinelguard.io/zh-cn/docs/basic-implementation.html">https://sentinelguard.io/zh-cn/docs/basic-implementation.html</a></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906761.png" alt="image-20220801191458948"></p><p>上面 slot 的排序规则根据下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(sortedClassList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">S</span>&gt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Class&lt;? extends S&gt; o1, Class&lt;? extends S&gt; o2)</span> &#123;<br>        <span class="hljs-type">Spi</span> <span class="hljs-variable">spi1</span> <span class="hljs-operator">=</span> o1.getAnnotation(Spi.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">order1</span> <span class="hljs-operator">=</span> spi1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : spi1.order();<br><br>        <span class="hljs-type">Spi</span> <span class="hljs-variable">spi2</span> <span class="hljs-operator">=</span> o2.getAnnotation(Spi.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> spi2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : spi2.order();<br><br>        <span class="hljs-keyword">return</span> Integer.compare(order1, order2);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>其中<code>spi2.order()</code>是<code>@Spi</code>注解定义的，每个 slot 的顺序如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_NODE_SELECTOR_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_CLUSTER_BUILDER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">9000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_LOG_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_STATISTIC_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">7000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_AUTHORITY_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_SYSTEM_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_FLOW_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEFAULT_CIRCUIT_BREAKER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1500</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEGRADE_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>整个调用链中最核心的就是 **<code>StatisticSlot</code>(<strong>用于记录、统计不同纬度的 runtime 指标监控信息) 以及</strong><code>FlowSlot</code>(**根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制）</p><p>可以查看**<code>DefaultProcessorSlotChain.java</code>**类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultProcessorSlotChain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ProcessorSlotChain</span> &#123;<br><br>    <span class="hljs-comment">// 先创建头结点</span><br>    AbstractLinkedProcessorSlot&lt;?&gt; first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractLinkedProcessorSlot</span>&lt;Object&gt;() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>            <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-built_in">super</span>.fireEntry(context, resourceWrapper, t, count, prioritized, args);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, <span class="hljs-type">int</span> count, Object... args)</span> &#123;<br>            <span class="hljs-built_in">super</span>.fireExit(context, resourceWrapper, count, args);<br>        &#125;<br><br>    &#125;;<br>    <span class="hljs-comment">// 创建尾结点，直接指向头结点</span><br>    AbstractLinkedProcessorSlot&lt;?&gt; end = first;<br>    ....<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出<strong>ProcessorSlotChain</strong>是一个链表，里面有两个<strong>AbstractLinkedProcessorSlot</strong>类型的链表：first 和 end，即链表的头结点和尾结点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906376.png" alt="image-20220801191557361"></p><p>然后添加通过<code>addLast</code>方法添加节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span> &#123;<br>    end.setNext(protocolProcessor);<span class="hljs-comment">// 由于end=first，所以是在first.next下面添加节点</span><br>    end = protocolProcessor;<span class="hljs-comment">// 然后调整end的指针指向新节点</span><br>&#125;<br><br><span class="hljs-comment">// AbstractLinkedProcessorSlot抽象类中的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(AbstractLinkedProcessorSlot&lt;?&gt; next)</span> &#123;<br>    <span class="hljs-built_in">this</span>.next = next;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906704.png" alt="image-20220801191607238"></p><p>然后依次类推，可以得到下面的链路 SlotChain：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906079.png" alt="image-20220801191620840"></p><h2 id="SlotChain-的链路执行"><a href="#SlotChain-的链路执行" class="headerlink" title="SlotChain 的链路执行"></a>SlotChain 的链路执行</h2><p><code>lookProcessChain</code>方法获得的第一个<code>ProcessorSlotChain</code>的实例是<code>DefaultProcessorSlotChain</code>，那么执行 chain.entry 方法，就会执行<code>DefaultProcessorSlotChain</code>的<code>entry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 触发下一个slot</span><br>    first.transformEntry(context, resourceWrapper, t, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着调用父类<code>AbstractLinkedProcessorSlot </code>的<code>transformEntry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 触发下一个节点entry逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireEntry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>        next.transformEntry(context, resourceWrapper, obj, count, prioritized, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transformEntry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object o, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (T)o;<br>    <span class="hljs-comment">// 触发节点entry逻辑</span><br>    entry(context, resourceWrapper, t, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟着代码<code>debug</code>可以知道，上面代码会触发第一个 slot 节点，也就是<code>NodeSelectorSlot</code>。这里先不介绍这个 slot 的具体逻辑。</p><h2 id="Slot-中的-entry-逻辑"><a href="#Slot-中的-entry-逻辑" class="headerlink" title="Slot 中的 entry 逻辑"></a>Slot 中的 entry 逻辑</h2><h3 id="滑动窗口限流原理"><a href="#滑动窗口限流原理" class="headerlink" title="滑动窗口限流原理"></a>滑动窗口限流原理</h3><h4 id="从-StatisticSlot-中的-entry-进入"><a href="#从-StatisticSlot-中的-entry-进入" class="headerlink" title="从 StatisticSlot 中的 entry 进入"></a>从 StatisticSlot 中的 entry 进入</h4><p><code>StaticSlot</code>主要是统计指标数据，用来给<code>FlowSlot</code>进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        Iterator var8;<br>        ProcessorSlotEntryCallback handler;<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// Do some checking.</span><br>            <span class="hljs-comment">// 1. 做一些检查，执行AuthoritySlot、SystemSlot、FlowSlot、DefaultCircuitBreakerSlot方法</span><br>            <span class="hljs-comment">// 如果规则不通过，就会抛出BlockException异常。反之，会在node中统计通过的请求数和线程数等信息。</span><br>            <span class="hljs-built_in">this</span>.fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>            <span class="hljs-comment">// 执行到这里表示通过了检查，没有被限流</span><br>            node.increaseThreadNum();<br>            <span class="hljs-comment">// 2. 记录通过规则的请求</span><br>            node.addPassRequest(count);<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseThreadNum();<br>                context.getCurEntry().getOriginNode().addPassRequest(count);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseThreadNum();<br>                Constants.ENTRY_NODE.addPassRequest(count);<br>            &#125;<br><br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">var13</span> <span class="hljs-operator">=</span> StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var13.hasNext()) &#123;<br>                ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler = (ProcessorSlotEntryCallback)var13.next();<br>                handler.onPass(context, resourceWrapper, node, count, args);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (PriorityWaitException var10) &#123;<br>            node.increaseThreadNum();<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseThreadNum();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseThreadNum();<br>            &#125;<br><br>            var8 = StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;<br>                handler = (ProcessorSlotEntryCallback)var8.next();<br>                handler.onPass(context, resourceWrapper, node, count, args);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException var11) &#123;<br>            <span class="hljs-type">BlockException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> var11;<br>            context.getCurEntry().setBlockError(var11);<br>            node.increaseBlockQps(count);<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseBlockQps(count);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseBlockQps(count);<br>            &#125;<br><br>            var8 = StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;<br>                handler = (ProcessorSlotEntryCallback)var8.next();<br>                handler.onBlocked(e, context, resourceWrapper, node, count, args);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>            context.getCurEntry().setError(var12);<br>            <span class="hljs-keyword">throw</span> var12;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><code>node.addPassRequest</code>方法是在<code>fireEntry</code>执行后才执行的，也就是说，当前请求通过了 sentinel 的流控规则，此时需要将当次请求记录下来，也就是执行<code>addPassRequest</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPassRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-built_in">super</span>.addPassRequest(count);<br>    <span class="hljs-built_in">this</span>.clusterNode.addPassRequest(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面方法在<code>DefaultNode</code>对象中。</p><ul><li><code>DefaultNode</code>：保存着某个 resource 在某个 context 中的实时指标，每个 DefaultNode 都指向一个 ClusterNode</li><li><code>ClusterNode</code>：保存着某个 resource 在所有 context 中实时指标的总和，同样的 resource 会共享同一个 ClusterNode，不管他在哪个 context 中</li></ul><p>在<code>StatisticNode</code>类中对<code>ArrayMetric</code>进行了初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.rollingCounterInSecond = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL);<br><span class="hljs-built_in">this</span>.rollingCounterInMinute = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(<span class="hljs-number">60</span>, <span class="hljs-number">60000</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPassRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-built_in">this</span>.rollingCounterInSecond.addPass(count);<br>    <span class="hljs-built_in">this</span>.rollingCounterInMinute.addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加指标用的 addPass 方法是一个<code>ArrayMetric</code>的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LeapArray&lt;MetricBucket&gt; data;<br><br><span class="hljs-comment">// SAMPLE_COUNT=2  INTERVAL=1000 上面传递的静态变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayMetric</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs)</span> &#123;<br>    <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OccupiableBucketLeapArray</span>(sampleCount, intervalInMs);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPass</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    WindowWrap&lt;MetricBucket&gt; wrap = <span class="hljs-built_in">this</span>.data.currentWindow();<br>    ((MetricBucket)wrap.value()).addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就跟窗口有关系了，这里使用<code>data</code>来获取当前窗口，窗口大小为 2。data 的类型是<code>MetricBucket</code>对象，用来保存各项指标，变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LongAdder[] counters;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> minRt;<br></code></pre></td></tr></table></figure><p><code>WindowWrap</code>对象的变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间窗口的长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowLengthInMs;<br><span class="hljs-comment">// 时间窗口的开始时间，单位是毫秒</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> windowStart;<br><span class="hljs-comment">//时间窗口的内容，在 WindowWrap 中是用泛型表示这个值的，但实际上就是 MetricBucket 类, 参考上面代码</span><br><span class="hljs-keyword">private</span> T value;<br></code></pre></td></tr></table></figure><p><code>LeapArray</code>对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeapArray</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 时间窗口的长度</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> windowLengthInMs;<br>    <span class="hljs-comment">// 采样窗口的个数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> sampleCount;<br>    <span class="hljs-comment">// 以毫秒为单位的时间间隔</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> intervalInMs;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> intervalInSecond;<br>    <span class="hljs-comment">// 采样的时间窗口数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">updateLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LeapArray</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs)</span> &#123;<br>        AssertUtil.isTrue(sampleCount &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;bucket count is invalid: &quot;</span> + sampleCount);<br>        AssertUtil.isTrue(intervalInMs &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;total time interval of the sliding window should be positive&quot;</span>);<br>        AssertUtil.isTrue(intervalInMs % sampleCount == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;time span needs to be evenly divided&quot;</span>);<br>        <span class="hljs-built_in">this</span>.windowLengthInMs = intervalInMs / sampleCount;<br>        <span class="hljs-built_in">this</span>.intervalInMs = intervalInMs;<br>        <span class="hljs-built_in">this</span>.intervalInSecond = (<span class="hljs-type">double</span>)intervalInMs / <span class="hljs-number">1000.0D</span>;<br>        <span class="hljs-comment">// 时间窗口的采样个数，默认为2个采样窗口</span><br>        <span class="hljs-built_in">this</span>.sampleCount = sampleCount;<br>        <span class="hljs-built_in">this</span>.array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceArray</span>(sampleCount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>LeapArray</code>中创建了一个<code>AtomicReferenceArray</code>数组，用来对时间窗口中的统计值进行采样。通过采样的统计值计算出平均值，即最终的实时指标的值。</p><p>重点是<code>this.data.currentWindow();</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateTimeIdx</span><span class="hljs-params">(<span class="hljs-comment">/*@Valid*/</span> <span class="hljs-type">long</span> timeMillis)</span> &#123;<br>    <span class="hljs-comment">// 获取时间窗口个数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">timeId</span> <span class="hljs-operator">=</span> timeMillis / windowLengthInMs;<br>    <span class="hljs-comment">// Calculate current index so we can map the timestamp to the leap array.</span><br>    <span class="hljs-comment">// 获取当前时间在实际窗口array数组中的索引</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(timeId % array.length());<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title function_">calculateWindowStart</span><span class="hljs-params">(<span class="hljs-comment">/*@Valid*/</span> <span class="hljs-type">long</span> timeMillis)</span> &#123;<br>    <span class="hljs-comment">// 获取时间窗口的起始时间。如下：</span><br>    <span class="hljs-comment">// 时间点：0    1    2   3   4   5   6</span><br>    <span class="hljs-comment">// 时间窗口windowLengthInMs为：2</span><br>    <span class="hljs-comment">// 当前时间为timeMillis为：5</span><br>    <span class="hljs-comment">// 当前时间所在的窗口起始时间= 5 - 5 % 2 = 4</span><br>    <span class="hljs-comment">// timeMillis % windowLengthInMs = 当前时间在当前时间窗口已经跑过的距离</span><br>    <span class="hljs-keyword">return</span> timeMillis - timeMillis % windowLengthInMs;<br>&#125;<br><br><span class="hljs-comment">// 传进来的是当前时间</span><br><span class="hljs-keyword">public</span> WindowWrap&lt;T&gt; <span class="hljs-title function_">currentWindow</span><span class="hljs-params">(<span class="hljs-type">long</span> timeMillis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (timeMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><span class="hljs-comment">// 时间窗口个数对2（假如默认值）取模</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> calculateTimeIdx(timeMillis);<br>        <span class="hljs-comment">// Calculate current bucket start time.</span><br>    <span class="hljs-comment">// 时间窗口的起始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">windowStart</span> <span class="hljs-operator">=</span> calculateWindowStart(timeMillis);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Get bucket item at given time from the array.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * (1) Bucket is absent, then just create a new bucket and CAS update to circular array.</span><br><span class="hljs-comment">         * (2) Bucket is up-to-date, then just return the bucket.</span><br><span class="hljs-comment">         * (3) Bucket is deprecated, then reset current bucket and clean all deprecated buckets.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 根据索引获取缓存的时间窗口</span><br>            WindowWrap&lt;T&gt; old = array.get(idx);<br>           <span class="hljs-comment">// 这里如果没有从缓存中取到，就会创建一个新的时间窗口，所以array的长度不能太大，不然不容易命中</span><br>            <span class="hljs-keyword">if</span> (old == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            bucket is empty, so create new and update</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the old bucket is absent, then we create a new bucket at &#123;@code windowStart&#125;,</span><br><span class="hljs-comment">                 * then try to update circular array via a CAS operation. Only one thread can</span><br><span class="hljs-comment">                 * succeed to update, while other threads yield its time slice.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-comment">// (1) 没取到缓存，则创建一个新的时间窗口</span><br>                WindowWrap&lt;T&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>                <span class="hljs-comment">// 通过CAS将新创建的窗口置换到缓存数组中去</span><br>                <span class="hljs-keyword">if</span> (array.compareAndSet(idx, <span class="hljs-literal">null</span>, window)) &#123;<br>                    <span class="hljs-comment">// 设置成功就返回该窗口</span><br>                    <span class="hljs-keyword">return</span> window;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 否则当前线程让出时间片，等待</span><br>                    Thread.<span class="hljs-keyword">yield</span>();<br>                &#125;<br>            <span class="hljs-comment">// (2) 如果当前窗口的开始时间与old的开始时间相等，则直接返回old窗口</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart == old.windowStart()) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2     B3      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            startTime of Bucket 3: 800, so it&#x27;s up-to-date</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If current &#123;@code windowStart&#125; is equal to the start timestamp of old bucket,</span><br><span class="hljs-comment">                 * that means the time is within the bucket, so directly return the bucket.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">return</span> old;<br>            <span class="hljs-comment">// 如果当前时间窗口的开始时间已经超过了old窗口的开始时间，则放弃old窗口</span><br>            <span class="hljs-comment">// 并将time设置为新的时间窗口的开始时间，此时窗口向前滑动</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &gt; old.windowStart()) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *   (old)</span><br><span class="hljs-comment">                 *             B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * |_______||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * ...    1200     1400    1600    1800    2000    2200  timestamp</span><br><span class="hljs-comment">                 *                              ^</span><br><span class="hljs-comment">                 *                           time=1676</span><br><span class="hljs-comment">                 *          startTime of Bucket 2: 400, deprecated, should be reset</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the start timestamp of old bucket is behind provided time, that means</span><br><span class="hljs-comment">                 * the bucket is deprecated. We have to reset the bucket to current &#123;@code windowStart&#125;.</span><br><span class="hljs-comment">                 * Note that the reset and clean-up operations are hard to be atomic,</span><br><span class="hljs-comment">                 * so we need a update lock to guarantee the correctness of bucket update.</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * The update lock is conditional (tiny scope) and will take effect only when</span><br><span class="hljs-comment">                 * bucket is deprecated, so in most cases it won&#x27;t lead to performance loss.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (updateLock.tryLock()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// (3) Successfully get the update lock, now we reset the bucket.</span><br>                        <span class="hljs-keyword">return</span> resetWindowTo(old, windowStart);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        updateLock.unlock();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span><br>                    Thread.<span class="hljs-keyword">yield</span>();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &lt; old.windowStart()) &#123;<br>                <span class="hljs-comment">// Should not go through here, as the provided time is already behind.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面代码实际可以分成以下几步：</p><ol><li>根据当前时间，算出该时间的 timeId，并根据 timeId 算出当前窗口在采样窗口数组中的索引 idx。</li><li>根据当前时间算出当前窗口的应该对应的开始时间 time，以毫秒为单位。</li><li>根据索引 idx，在采样窗口数组中取得一个时间窗口。</li><li>循环判断直到获取到一个当前时间窗口 old 。<ol><li>如果 old 为空，则创建一个时间窗口，并将它插入到 array 的第 idx 个位置，array 上面已经分析过了，是一个 AtomicReferenceArray。</li><li>如果当前窗口的开始时间 time 与 old 的开始时间相等，那么说明 old 就是当前时间窗口，直接返回 old。</li><li>如果当前窗口的开始时间 time 大于 old 的开始时间，则说明 old 窗口已经过时了，将 old 的开始时间更新为最新值：time，进入下一次得循环再判断当前窗口的开始时间 time 与 old 的开始时间相等的时候返回。</li><li>如果当前窗口的开始时间 time 小于 old 的开始时间，实际上这种情况是不可能存在的，因为 time 是当前时间，old 是过去的一个时间。</li></ol></li></ol><p><strong>timeId（即时间窗口的个数）是会随着时间的增长而增加，当前时间每增长一个 windowLength 的长度，timeId 就加 1。但是 idx 不会增长，只会在 0 和 1 之间变换，因为 array 数组的长度是 2，只有两个采样时间窗口。</strong></p><p>为什么默认只有两个采样窗口？可能是因为时间窗口中保存着很多统计数据，如果时间窗口过多的话，一方面会占用过多内存，另一方面时间窗口过多就意味着时间窗口的长度会变小，如果时间窗口长度变小，就会导致时间窗口过于频繁的滑动。</p><p><strong>下面看看 currentWindow 代码逻辑</strong>：</p><p>根据当前时间除于 <code>windowLength </code>得到一个 timeId，再用 timeId 跟取样窗口的长度进行一个取模，那么值一定会落在 0，1 两个位置的其中一个。然后根据当前时间算出当前窗口的应该对应的开始时间 time。由于刚刚开始的时候 array 是空的，那么获取到的 old 应当是 null，那么会创建一个新的实例，用图看一下初始化的 LeapArray：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091850289.png" alt="image-20230709184837045"></p><p>当 old 获取到的是 null，那么初始的时候 arrays 数组中只有一个窗口（可能是第一个(idx&#x3D;0)，也可能是第二个(idx&#x3D;1)），每个时间窗口的长度是 500ms，这就意味着只要当前时间与时间窗口的差值在 500ms 之内，时间窗口就不会向前滑动。例如，假如当前时间走到 300 或者 500 时，当前时间窗口仍然是相同的那个：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091854811.png" alt="image-20230709185358381"></p><p>时间继续往前走，当超过 500ms 时，时间窗口就会向前滑动到下一个，这时就会更新当前窗口的开始时间,时间继续往前走，只要不超过 1000ms，则当前窗口不会发生变化，其中代码实现是 resetWindowTo 方法：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091857034.png" alt="image-20230709185704628"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WindowWrap&lt;MetricBucket&gt; <span class="hljs-title function_">resetWindowTo</span><span class="hljs-params">(WindowWrap&lt;MetricBucket&gt; w, <span class="hljs-type">long</span> time)</span> &#123;<br>    <span class="hljs-comment">// Update the start time and reset value.</span><br>    w.resetTo(time);<br>    <span class="hljs-type">MetricBucket</span> <span class="hljs-variable">borrowBucket</span> <span class="hljs-operator">=</span> borrowArray.getWindowValue(time);<br>    <span class="hljs-keyword">if</span> (borrowBucket != <span class="hljs-literal">null</span>) &#123;<br>        w.value().reset();<br>        w.value().addPass((<span class="hljs-type">int</span>)borrowBucket.pass());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        w.value().reset();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br></code></pre></td></tr></table></figure><p>当时间继续往前走，当前时间超过 1000ms 时，就会再次进入下一个时间窗口，此时 arrays 数组中的窗口将会有一个失效，会有另一个新的窗口进行替换：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906190.png" alt="image-20220814153836045"></p><p>这样，在当前时间点中进入的请求，会被统计到当前时间对应的窗口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPass</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    WindowWrap&lt;MetricBucket&gt; wrap = data.currentWindow();<br>    wrap.value().addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>获得窗口后，会执行下面语句，增加当前窗口通过的请求数 QPS。这里的<code>wrap.value()</code>得到的是<code>MetricBucket</code>，在 Sentinel 中 QPS 相关数据的统计结果就维护在这个类中<code>LongAddr[]</code>中，最终由这个指标来与我们设置好的规则进行匹配，查看是否限流，也就是<code>StatisticSlot</code>的 entry 方法中的<code>fireEntry</code>，都要先进入到<code>FlowSlot</code>的<code>entry</code>方法进行限流过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 在此方法里面进行限流规则检查</span><br>    checkFlow(resourceWrapper, context, node, count, prioritized);<br><br>    fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>FlowRuleChecker</code>类中，循环规则匹配资源进行限流过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkFlow</span><span class="hljs-params">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span><br><span class="hljs-params">                      Context context, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized)</span> <span class="hljs-keyword">throws</span> BlockException &#123;<br>    <span class="hljs-keyword">if</span> (ruleProvider == <span class="hljs-literal">null</span> || resource == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());<br>    <span class="hljs-keyword">if</span> (rules != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (FlowRule rule : rules) &#123;<br>            <span class="hljs-keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowException</span>(rule.getLimitApp(), rule);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/wuzhenzhao/p/11453649.html">https://www.cnblogs.com/wuzhenzhao/p/11453649.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存一致性方案思考</title>
    <link href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、缓存的查询"><a href="#一、缓存的查询" class="headerlink" title="一、缓存的查询"></a>一、缓存的查询</h2><p>先查询缓存，如果缓存查询失败，就去查询数据库，然后重新生成缓存。</p><h2 id="二、缓存的更新"><a href="#二、缓存的更新" class="headerlink" title="二、缓存的更新"></a>二、缓存的更新</h2><p>在高并发的情况下，需要考虑下面两个问题：</p><ul><li>是先更新数据库还是先更新缓存？</li><li>是更新缓存还是删除缓存？</li></ul><h4 id="1-先更新数据库再更新缓存"><a href="#1-先更新数据库再更新缓存" class="headerlink" title="1. 先更新数据库再更新缓存"></a>1. 先更新数据库再更新缓存</h4><p>线程A：更新数据库（第1s）——&gt;  更新缓存（第10s）</p><p>线程B：更新数据库 （第3s）——&gt; 更新缓存（第5s）</p><p>上面情况，就会导致线程B的缓存值被线程A覆盖，<strong>缓存中存的是线程A的旧值</strong>，产生脏数据并且直到缓存失效（如果有过期时间）。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252234.png" alt="image-20230620164505738" style="zoom:50%;" /><h4 id="2-先更新缓存再更新数据库"><a href="#2-先更新缓存再更新数据库" class="headerlink" title="2. 先更新缓存再更新数据库"></a>2. 先更新缓存再更新数据库</h4><p>线程A：更新缓存（第1s）——&gt; 更新数据库（第10s）</p><p>线程B： 更新缓存（第3s）——&gt;  更新数据库（第5s）</p><p>和前面一种情况相反，<strong>缓存中是线程B的新值，而数据库中是线程A的旧值。</strong></p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252759.png" alt="image-20230620170050262" style="zoom:50%;" /><p>﻿前两种方式之所以会在并发场景下出现异常，<strong>本质上是因为更新缓存和更新数据库是两个操作</strong>。</p><p>如果把它化简，更新时只更新数据库，同时删除缓存。等待下一次查询时命中不到缓存，再去重建缓存，是不是就解决了这个问题？</p><h4 id="3-先删除缓存再更新数据库"><a href="#3-先删除缓存再更新数据库" class="headerlink" title="3. 先删除缓存再更新数据库"></a>3. 先删除缓存再更新数据库</h4><p>通过这种方式，两个线程都值修改数据库，不管谁先，数据库以后修改的数据为准。</p><p>但这时另一个<strong>并发场景</strong>：两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的。很显然，这种状况也不是我们想要的。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252794.png" alt="image-20230620170016670" style="zoom:50%;" /><p><strong>解决方案</strong>：</p><h5 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h5><p>对于<strong>请求</strong>A，做一下操作：</p><ol><li><p>删除缓存</p></li><li><p>更新数据库</p></li><li><p><strong>睡眠一段时间</strong></p></li><li><p><strong>再次删除缓存</strong></p></li></ol><p>添加一个睡眠时间，主要是为了确保请求A在睡眠的时候，请求B能在这段时间内完成<strong>从数据库读取数据，再把缺失的数据写入缓存</strong>的操作，然后请求A睡眠完，再删除缓存。</p><p>所以请求A的睡眠时间就需要大于请求B<strong>从数据库读取数据+写入数据</strong>的时间。<strong>但是这个时间不好评估</strong>。</p><p><strong>所以不建议这种方案</strong>。</p><h4 id="4-先更新数据库再删除缓存（cache-aside）"><a href="#4-先更新数据库再删除缓存（cache-aside）" class="headerlink" title="4. 先更新数据库再删除缓存（cache aside）"></a>4. 先更新数据库再删除缓存（cache aside）</h4><p><strong>场景</strong>：一个是查询操作，一个是更新操作的并发，我们先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，删除操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会方案3一样，后续的查询操作一直在取老的数据。如下图：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252546.png" alt="image-20230619202426780" style="zoom: 50%;" /><p>但是，这种策略也不是一定完美。看下面这个场景：</p><p>一个读操作没有命中缓存，然后就去数据库中获取数据。此时有一个写操作，写完数据库后，让缓存失效。然后之前的读操作再把老的数据写回缓存，这样就造成脏数据。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252030.png" alt="image-20230620170340552" style="zoom:50%;" /><p>上面的例子理论上会出现，但是出现概率比较低。因为条件需要读缓存时缓存正好失效，并且此时并发一个写操作。而数据库写操作比读操作慢的多，而读操作读操作必须在写操作之前，又要晚于写操作更新缓存。所有条件在一起的可能性并不大。</p><h2 id="三、操作失败如何"><a href="#三、操作失败如何" class="headerlink" title="三、操作失败如何"></a>三、操作失败如何</h2><p>在实际生产中，由于网络抖动、服务下线等原因，对数据库和缓存的操作可能失败。</p><p>举例说明：应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252746.png" alt="image-20230620170950273" style="zoom:50%;" /><p>那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有删除，所以会缓存命中，但是读到的却是旧值 1。</p><p>其实<strong>不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题</strong>。</p><p>问题原因知道了，该怎么解决呢？有两种方法：</p><ul><li>重试机制</li><li>订阅MySQL binlog，再操作缓存</li></ul><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p>举个例子，来说明重试机制的过程：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252738.png" alt="image-20230620171258860" style="zoom:50%;" /><h4 id="订阅-MySQL-binlog，再操作缓存"><a href="#订阅-MySQL-binlog，再操作缓存" class="headerlink" title="订阅 MySQL binlog，再操作缓存"></a>订阅 MySQL binlog，再操作缓存</h4><p><strong>先更新数据库，再删缓存</strong>的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p><p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p><p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p><p>下图是 Canal 的工作原理：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262253576.png" alt="image-20230619225953489"></p><p>综上，<strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</strong></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="1-cache-aside并非万能"><a href="#1-cache-aside并非万能" class="headerlink" title="1. cache aside并非万能"></a>1. cache aside并非万能</h3><p>虽然说cache aside可以被称之为缓存使用的最佳实践，但与此同时，它引入了缓存的命中率降低的问题，（每次都删除缓存自然导致更不容易命中了），因此它更适用于对缓存命中率要求并不是特别高的场景。<strong>如果要求较高的缓存命中率，依然需要采用更新数据库后同时更新缓存的方案</strong>。</p><h3 id="2-缓存数据不一致的解决方案"><a href="#2-缓存数据不一致的解决方案" class="headerlink" title="2. 缓存数据不一致的解决方案"></a>2. 缓存数据不一致的解决方案</h3><p>在更新数据库后同时更新缓存，会在并发的场景下出现数据不一致，有下面方案：</p><h4 id="引入分布式锁"><a href="#引入分布式锁" class="headerlink" title="引入分布式锁"></a>引入分布式锁</h4><p>在更新缓存之前尝试获取锁，如果已经被占用就先阻塞住线程，等待其他线程释放锁后再尝试更新。但这会影响并发操作的性能。</p><h4 id="设置较短缓存时间"><a href="#设置较短缓存时间" class="headerlink" title="设置较短缓存时间"></a>设置较短缓存时间</h4><p>设置较短的缓存过期时间能够使得数据不一致问题存在的时间也比较短，对业务的影响相对较小。但是与此同时，其实这也使得缓存命中率降低，又回到了前面的问题里…</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li><a href="https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY">https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU缓存算法</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="双向链表-哈希表（非线程安全）"><a href="#双向链表-哈希表（非线程安全）" class="headerlink" title="双向链表+哈希表（非线程安全）"></a>双向链表+哈希表（非线程安全）</h2><p><a href="https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/">https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LRU算法: 哈希表+双向链表实现</span><br><span class="hljs-comment"> * 1. 双向链表按照被使用的顺序来存储, 靠近头部的节点是最近使用的, 靠近尾部的节点是最久未使用的</span><br><span class="hljs-comment"> * 2. 哈希表存储key和node映射关系, 通过key能快速定位到链表中的节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhangjunfeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2023/2/2 16:15</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">()</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value)</span> &#123;<br>            key = _key;<br>            value = _value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode head, tail;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> _capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity = _capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 先判断key是否存在, 不存在返回-1</span><br><span class="hljs-comment">     * 2. 若key存在, 则key对应的节点就是最近访问节点, 通过哈希表映射到在双向链表中的位置, 然后将节点移动到链表头部</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// key存在则移动到链表头部, 表示最近访问</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 如果key不存在, 创建一个新节点并在链表头部添加该节点, 判断链表长度是否超出容量限制, 若超出容量, 则删除链表尾部结点</span><br><span class="hljs-comment">     * 2. 如果key存在, 覆盖旧值, 将节点移动到头部</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// node不存在, 则创建一个新节点</span><br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache.put(key, newNode);<br>            <span class="hljs-comment">// 添加到链表头部, 表示最近访问</span><br>            addToHead(newNode);<br>            <span class="hljs-comment">// 链表长度加1</span><br>            ++size;<br>            <span class="hljs-comment">// 如果超出缓存容量</span><br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 删除链表最后一个结点, 去掉最长时间未访问的</span><br>                <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> removeTail();<br>                <span class="hljs-comment">// 去掉哈希表中对应节点</span><br>                cache.remove(tail.key);<br>                <span class="hljs-comment">// 减小链表长度</span><br>                --size;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果缓存中有</span><br>            <span class="hljs-comment">// 先覆盖旧值</span><br>            node.value = value;<br>            <span class="hljs-comment">// 再将节点移到链表头部, 表示最近访问</span><br>            moveToHead(node);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个结点需要修改四条链</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(DLinkedNode node)</span> &#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除一个结点需要修改两条链</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(DLinkedNode node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 把结点移到头部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span> &#123;<br>        <span class="hljs-comment">// 先删除节点</span><br>        removeNode(node);<br>        <span class="hljs-comment">// 再将该节点移到头部</span><br>        addToHead(node);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除尾结点并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> tail.prev;<br>        removeNode(last);<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;key: &quot;</span> + cur.key + <span class="hljs-string">&quot;; value: &quot;</span> + cur.value);<br>            cur = cur.next;<br>            <br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="线程安全版本"><a href="#线程安全版本" class="headerlink" title="线程安全版本"></a>线程安全版本</h2><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p><code>ConcurrentHashMap</code> + <code>ConcurrentLinkedQueue</code> +<code>ReadWriteLock</code></p><h3 id="ConcurrentLinkedQueue简单介绍"><a href="#ConcurrentLinkedQueue简单介绍" class="headerlink" title="ConcurrentLinkedQueue简单介绍"></a><strong>ConcurrentLinkedQueue简单介绍</strong></h3><p><strong>ConcurrentLinkedQueue是一个基于单向链表的无界无锁线程安全的队列，适合在高并发环境下使用，效率比较高。</strong> 我们在使用的时候，可以就把它理解为我们经常接触的数据结构——队列，不过是增加了多线程下的安全性保证罢了。<strong>和普通队列一样，它也是按照先进先出(FIFO)的规则对接点进行排序。</strong> 另外，队列元素中不可以放置null元素。</p><p><code>ConcurrentLinkedQueue中</code>最主要的两个方法是：<code>offer(value)</code>和<code>poll()</code>，分别实现队列的两个重要的操作：入队和出队(<code>offer(value)</code>等价于 <code>add(value)</code>)。</p><p>我们添加一个元素到队列的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。</p><p>利用<code>ConcurrentLinkedQueue</code>队列先进先出的特性，每当我们 <code>put</code>&#x2F;<code>get</code>(缓存被使用)元素的时候，我们就将这个元素存放在队列尾部，这样就能保证队列头部的元素是最近最少使用的。</p><h3 id="ReadWriteLock简单介绍"><a href="#ReadWriteLock简单介绍" class="headerlink" title="ReadWriteLock简单介绍"></a><strong>ReadWriteLock简单介绍</strong></h3><p><code>ReadWriteLock</code> 是一个接口，位于<code>java.util.concurrent.locks</code>包下，里面只有两个方法分别返回读锁和写锁：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">public interface ReadWriteLock &#123;<br>    /**<br>     * 返回读锁<br>     */<br>    Lock readLock();<br><br>    /**<br>     * 返回写锁<br>     */<br>    Lock writeLock();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code> 是<code>ReadWriteLock</code>接口的具体实现类。</p><p><strong>读写锁还是比较适合缓存这种读多写少的场景。读写锁可以保证多个线程和同时读取，但是只有一个线程可以写入。但是，有一个问题是当读锁被线程持有的时候，读锁是无法被其它线程申请的，会处于阻塞状态，直至读锁被释放。</strong></p><p>另外，<strong>同一个线程持有写锁时是可以申请读锁，但是持有读锁的情况下不可以申请写锁。</strong></p><h3 id="ScheduledExecutorService-简单介绍"><a href="#ScheduledExecutorService-简单介绍" class="headerlink" title="ScheduledExecutorService 简单介绍"></a><strong>ScheduledExecutorService 简单介绍</strong></h3><p><code>ScheduledExecutorService</code> 是一个接口，<code>ScheduledThreadPoolExecutor</code> 是其主要实现类。</p><p><strong><code>ScheduledThreadPoolExecutor</code></strong> <strong>主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目用到的比较少，因为有其他方案选择比如<code>quartz</code>。但是，在一些需求比较简单的场景下还是非常有用的！</p><p><strong><code>ScheduledThreadPoolExecutor</code></strong> <strong>使用的任务队列</strong> <strong><code>DelayQueue</code></strong> <strong>封装了一个</strong> <strong><code>PriorityQueue</code>，<code>PriorityQueue</code></strong> <strong>会对队列中的任务进行排序，执行所需时间短的放在前面先被执行，如果执行所需时间相同则先提交的任务将被先执行。</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>LRU缓存指的是当缓存大小已达到最大分配容量的时候，如果再要去缓存新的对象数据的话，就需要将缓存中最近访问最少的对象删除掉以便给新来的数据腾出空间。</p><p><code>ConcurrentHashMap</code> 是线程安全的Map，我们可以利用它缓存 key,value形式的数。<code>ConcurrentLinkedQueue</code>是一个线程安全的基于链表的队列（先进先出），我们可以用它来维护 key 。每当我们put&#x2F;get(缓存被使用)元素的时候，我们就将这个元素对应的 key 存放在队列尾部，这样就能保证队列头部的元素是最近最少使用的。当我们的缓存容量不够的时候，我们直接移除队列头部对应的key以及这个key对应的缓存即可！</p><p>另外，我们用到了<code>ReadWriteLock</code>(读写锁)来保证线程安全。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 使用 ConcurrentHashMap+ConcurrentLinkedQueue+ReadWriteLock实现线程安全的 LRU 缓存</span><br><span class="hljs-comment"> * 这里只是为了学习使用，本地缓存推荐使用 Guava 自带的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLruCache</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxCapacity;<br><br>    <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;K, V&gt; cacheMap;<br>    <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;K&gt; keys;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读写锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLruCache</span><span class="hljs-params">(<span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (maxCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal max capacity: &quot;</span> + maxCapacity);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxCapacity = maxCapacity;<br>        cacheMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(maxCapacity);<br>        keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-comment">// 加写锁</span><br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                moveToTailOfQueue(key);<br>                cacheMap.put(key, value);<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>            <span class="hljs-comment">//2.是否超出缓存容量，超出的话就移除队列头部的元素以及其对应的缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.size() == maxCapacity) &#123;<br>                System.out.println(<span class="hljs-string">&quot;maxCapacity of cache reached&quot;</span>);<br>                removeOldestKey();<br>            &#125;<br>            <span class="hljs-comment">//3.key不存在于当前缓存。将key添加到队列的尾部并且缓存key及其对应的元素</span><br>            keys.add(key);<br>            cacheMap.put(key, value);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-comment">//加读锁</span><br>        readLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在的话就将key移动到队列的尾部</span><br>                moveToTailOfQueue(key);<br>                <span class="hljs-keyword">return</span> cacheMap.get(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> &#123;<br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在移除队列和Map中对应的Key</span><br>                keys.remove(key);<br>                <span class="hljs-keyword">return</span> cacheMap.remove(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将元素添加到队列的尾部(put/get的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTailOfQueue</span><span class="hljs-params">(K key)</span> &#123;<br>        keys.remove(key);<br>        keys.add(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除队列头部的元素以及其对应的缓存 (缓存容量已满的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeOldestKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">oldestKey</span> <span class="hljs-operator">=</span> keys.poll();<br>        <span class="hljs-keyword">if</span> (oldestKey != <span class="hljs-literal">null</span>) &#123;<br>            cacheMap.remove(oldestKey);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cacheMap.size();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//init cache</span><br>MyLruCache&lt;String, Integer&gt; myLruCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLruCache</span>&lt;&gt;(batchSize * <span class="hljs-number">10</span>);<br><span class="hljs-comment">//init thread pool with 10 threads</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(threadNum);<br><span class="hljs-comment">//init CountDownLatch with 10 count</span><br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; t &lt; threadNum; t++) &#123;<br>    fixedThreadPool.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; batchSize; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> atomicInteger.incrementAndGet();<br>            myLruCache.put(<span class="hljs-string">&quot;id&quot;</span> + value, value);<br>        &#125;<br>        latch.countDown();<br>    &#125;);<br>&#125;<br><span class="hljs-comment">//wait for 10 threads to complete the task</span><br>latch.await();<br>fixedThreadPool.shutdown();<br>System.out.println(<span class="hljs-string">&quot;Cache size:&quot;</span> + myLruCache.size());<span class="hljs-comment">//Cache size:100</span><br><span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> endTime - startTime;<br>System.out.println(String.format(<span class="hljs-string">&quot;Time cost：%dms&quot;</span>, duration));<span class="hljs-comment">//Time cost：511ms</span><br></code></pre></td></tr></table></figure><h2 id="线程安全并且带有过期时间"><a href="#线程安全并且带有过期时间" class="headerlink" title="线程安全并且带有过期时间"></a>线程安全并且带有过期时间</h2><p>实际上就是在我们上面时间的LRU缓存的基础上加上一个定时任务去删除缓存，单纯利用 JDK 提供的类，我们实现定时任务的方式有很多种：</p><ol><li><code>Timer</code> :不被推荐，多线程会存在问题。</li><li><code>ScheduledExecutorService</code> ：定时器线程池，可以用来替代 <code>Timer</code></li><li><code>DelayQueue</code> ：延时队列</li><li><code>quartz</code> ：一个很火的开源任务调度框架，很多其他框架都是基于 <code>quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案</li><li>……</li></ol><p>最终我们选择了 <code>ScheduledExecutorService</code>，主要原因是它易用（基于<code>DelayQueue</code>做了很多封装）并且基本能满足我们的大部分需求。</p><p>我们在我们上面实现的线程安全的 LRU 缓存基础上，简单稍作修改即可！我们增加了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAfterExpireTime</span><span class="hljs-params">(K key, <span class="hljs-type">long</span> expireTime)</span> &#123;<br>    scheduledExecutorService.schedule(() -&gt; &#123;<br>        <span class="hljs-comment">//过期后清除该键值对</span><br>        cacheMap.remove(key);<br>        keys.remove(key);<br>    &#125;, expireTime, TimeUnit.MILLISECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们put元素的时候，如果通过这个方法就能直接设置过期时间。</p><h3 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 使用 ConcurrentHashMap+ConcurrentLinkedQueue+ReadWriteLock+ScheduledExecutorService实现线程安全的 LRU 缓存</span><br><span class="hljs-comment"> * 这里只是为了学习使用，本地缓存推荐使用 Guava 自带的，使用 Spring 的话，推荐使用Spring Cache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLruCacheWithExpireTime</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxCapacity;<br><br>    <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;K, V&gt; cacheMap;<br>    <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;K&gt; keys;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读写锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();<br><br>    <span class="hljs-keyword">private</span> ScheduledExecutorService scheduledExecutorService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLruCacheWithExpireTime</span><span class="hljs-params">(<span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (maxCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal max capacity: &quot;</span> + maxCapacity);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxCapacity = maxCapacity;<br>        cacheMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(maxCapacity);<br>        keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>        scheduledExecutorService = Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value, <span class="hljs-type">long</span> expireTime)</span> &#123;<br>        <span class="hljs-comment">// 加写锁</span><br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                moveToTailOfQueue(key);<br>                cacheMap.put(key, value);<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>            <span class="hljs-comment">//2.是否超出缓存容量，超出的话就移除队列头部的元素以及其对应的缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.size() == maxCapacity) &#123;<br>                System.out.println(<span class="hljs-string">&quot;maxCapacity of cache reached&quot;</span>);<br>                removeOldestKey();<br>            &#125;<br>            <span class="hljs-comment">//3.key不存在于当前缓存。将key添加到队列的尾部并且缓存key及其对应的元素</span><br>            keys.add(key);<br>            cacheMap.put(key, value);<br>            <span class="hljs-keyword">if</span> (expireTime &gt; <span class="hljs-number">0</span>) &#123;<br>                removeAfterExpireTime(key, expireTime);<br>            &#125;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-comment">//加读锁</span><br>        readLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在的话就将key移动到队列的尾部</span><br>                moveToTailOfQueue(key);<br>                <span class="hljs-keyword">return</span> cacheMap.get(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> &#123;<br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//key是否存在于当前缓存</span><br>            <span class="hljs-keyword">if</span> (cacheMap.containsKey(key)) &#123;<br>                <span class="hljs-comment">// 存在移除队列和Map中对应的Key</span><br>                keys.remove(key);<br>                <span class="hljs-keyword">return</span> cacheMap.remove(key);<br>            &#125;<br>            <span class="hljs-comment">//不存在于当前缓存中就返回Null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将元素添加到队列的尾部(put/get的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTailOfQueue</span><span class="hljs-params">(K key)</span> &#123;<br>        keys.remove(key);<br>        keys.add(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除队列头部的元素以及其对应的缓存 (缓存容量已满的时候执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeOldestKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">oldestKey</span> <span class="hljs-operator">=</span> keys.poll();<br>        <span class="hljs-keyword">if</span> (oldestKey != <span class="hljs-literal">null</span>) &#123;<br>            cacheMap.remove(oldestKey);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAfterExpireTime</span><span class="hljs-params">(K key, <span class="hljs-type">long</span> expireTime)</span> &#123;<br>        scheduledExecutorService.schedule(() -&gt; &#123;<br>            <span class="hljs-comment">//过期后清除该键值对</span><br>            cacheMap.remove(key);<br>            keys.remove(key);<br>        &#125;, expireTime, TimeUnit.MILLISECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cacheMap.size();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试效果：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">MyLruCacheWithExpireTime&lt;Integer,String&gt; myLruCache = new MyLruCacheWithExpireTime&lt;&gt;(3);<br>myLruCache.put(1,&quot;Java&quot;,3;<br>myLruCache.put(2,&quot;C++&quot;,3;<br>myLruCache.put(3,&quot;Python&quot;,1500);<br>System.out.println(myLruCache.size());//3<br>Thread.sleep(2;<br>System.out.println(myLruCache.size());//2<br></code></pre></td></tr></table></figure><h2 id="资料来自"><a href="#资料来自" class="headerlink" title="资料来自"></a>资料来自</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/135936339">https://zhuanlan.zhihu.com/p/135936339</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="二分4-寻找两个正序数组的中位数"><a href="#二分4-寻找两个正序数组的中位数" class="headerlink" title="二分4. 寻找两个正序数组的中位数"></a>二分4. 寻找两个正序数组的中位数</h2><blockquote><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">https://leetcode.cn/problems/median-of-two-sorted-arrays/description/</a></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：递归-二分查找排序第k值"><a href="#题解一：递归-二分查找排序第k值" class="headerlink" title="题解一：递归+二分查找排序第k值"></a>题解一：递归+二分查找排序第k值</h3><p><strong>时间复杂度</strong>：<code>O(log(m+n))</code></p><p><strong>思路</strong>：</p><ol><li>迭代核心是找排序为第k的数（剩余总序列里），然后剪掉前<code>k/2</code>个数。 （剔除前<code>k/2</code>个较小的后，在剩下的里面找第<code>k-(k/2)</code>个，即最开始想要的第<code>k</code>个，然后继续迭代这个过程）</li><li>终结的条件为找第<code>k=1</code>个<strong>or</strong>剪到边剪得啥都不剩了。 （k&#x3D;1说明找第一小的数，返回最小值即可。剪的啥都不剩了说明一个数组完全大于另一个，直接返回中位数即可）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 迭代核心是找排序为第k的数（剩余总序列里），然后剪掉前`k/2`个数。 （剔除前`k/2`个较小的后，在剩下的里面找第`k-(k/2)`个，即最开始想要的第`k`个，然后继续迭代这个过程）</span><br><span class="hljs-comment">     * 2. 终结的条件为找第`k=1`个**or**剪到边剪得啥都不剩了。 （k=1说明找第一小的数，返回最小值即可。剪的啥都不剩了说明一个数组完全大于另一个，直接返回中位数即可）</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>    <span class="hljs-comment">// 按照下面思路: left + right 可以满足奇数和偶数所有情况</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> (fingKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, left) + fingKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, right)) / <span class="hljs-number">2.0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fingKth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// nums1为空数组</span><br>    <span class="hljs-keyword">if</span> (nums1.length &lt;= i) <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// nums2为空数组</span><br>    <span class="hljs-keyword">if</span> (nums2.length &lt;= j) <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// k==1说明找第一小的数(剩余序列)</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>    &#125;<br>    <span class="hljs-comment">// k: 本次两个数组的中间下标</span><br>    <span class="hljs-comment">// i + k/2 - 1: k/2是因为现在在单个数组中, 该步骤表示nums1中有没有第k/2个数</span><br>    <span class="hljs-comment">// 为什么赋最大值？</span><br>    <span class="hljs-comment">// 假如nums1长度为2, nums2长度为12, 则k为(2+12)/2=7, k/2=3</span><br>    <span class="hljs-comment">// 因为nums1长度小于3, 则无法判断中位数是否在nums1中; 而nums2中前3个肯定不是中位数</span><br>    <span class="hljs-comment">// 所以当k/2不存在时,将其设置为最大值,这样可以保留继续下一次循环</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">midVal1</span> <span class="hljs-operator">=</span> (i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">midVal2</span> <span class="hljs-operator">=</span> (j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>    <span class="hljs-keyword">if</span> (midVal1 &lt; midVal2) &#123;<br>        <span class="hljs-comment">// 说明nums1的前i+k/2个数都被舍弃, 因为在整体数组前半部分比midVal2小, 说明中位数可能在nums2中</span><br>        <span class="hljs-comment">// 下一轮的中位数下标要在舍弃的基础上计算: k/2是舍弃部分, 所以是: k - k / 2</span><br>        <span class="hljs-keyword">return</span> fingKth(nums1, i + k / <span class="hljs-number">2</span>, nums2, j, k - k / <span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fingKth(nums1, i, nums2, j + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：归并排序"><a href="#题解二：归并排序" class="headerlink" title="题解二：归并排序"></a>题解二：归并排序</h3><p><strong>思路</strong>：因为两个数组都是有序数组，所以直接使用归并排序一次即可合并成整个有序数组，然后再取中位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-comment">// 先归并排序, 因为两个都是有序数组</span><br>    <span class="hljs-type">int</span>[] res = mergeSort(nums1, nums2);<br>    <span class="hljs-comment">// 这里使用一个小trick, 不用判断奇偶长度</span><br>    <span class="hljs-keyword">return</span> (res[(res.length + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + res[(res.length + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2.0</span>;<br>&#125;<br><br><span class="hljs-comment">// 归并排序底层实现: 合并两个有序数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length, len2 = nums2.length;<br>    <span class="hljs-keyword">if</span> (len1 &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums2;<br>    <span class="hljs-keyword">if</span> (len2 &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums1;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + len2];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;<br>        res[index++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; len1) &#123;<br>        res[index++] = nums1[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt; len2) &#123;<br>        res[index++] = nums2[j++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分34-在排序数组中查找元素的第一个和最后一个位置"><a href="#二分34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="二分34. 在排序数组中查找元素的第一个和最后一个位置"></a>二分34. 在排序数组中查找元素的第一个和最后一个位置</h2><blockquote><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：二分查找分别寻找最左边界和最右边界"><a href="#题解：二分查找分别寻找最左边界和最右边界" class="headerlink" title="题解：二分查找分别寻找最左边界和最右边界"></a>题解：二分查找分别寻找最左边界和最右边界</h3><p><strong>思路</strong>：</p><ol><li>二分查找可以寻找最左边界和最右边界</li><li>找到边界后需要判断边界是否合法</li></ol><p><strong>普通代码结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">// 寻找最左边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            <span class="hljs-comment">// 这时不需要mid-1, 因为右区间本来就不存在数字</span><br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断一下边界和是否等于target</span><br>    <span class="hljs-keyword">if</span> (left &lt; nums.length &amp;&amp; nums[left] == target) res[<span class="hljs-number">0</span>] = left;<br><br>    <span class="hljs-comment">// 寻找最右边界</span><br>    left = <span class="hljs-number">0</span>;<br>    right = nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>            <span class="hljs-comment">// 因为是寻找右边界, 所以left相等也先舍弃</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 这时不需要mid-1, 因为右区间本来就不存在数字</span><br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断一下边界和是否等于target</span><br>    <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; nums[right - <span class="hljs-number">1</span>] == target) res[<span class="hljs-number">1</span>] = right - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化代码结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 寻找左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 寻找右边界，由于返回的是第一个&gt;=target 但是索引+1的值, 所以要减1（参考left=mid+1后才返回，这时多加了个1）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &lt; nums.length &amp;&amp; right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-comment">// flag=true表示寻找最左边界</span><br>    <span class="hljs-comment">// 左右边界都可以返回left. 原因: 因为结束条件是left &lt; right, 所以跳出循环时一定是left=right, 所以返回left和right都行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">boolean</span> flag)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (flag &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ul><li>二分查找算法的几种情况：<a href="https://floweryu.blog.csdn.net/article/details/112378419">https://floweryu.blog.csdn.net/article/details/112378419</a></li></ul><h2 id="二分35-搜索插入位置"><a href="#二分35-搜索插入位置" class="headerlink" title="二分35. 搜索插入位置"></a>二分35. 搜索插入位置</h2><blockquote><p><a href="https://leetcode.cn/problems/search-insert-position/description/">https://leetcode.cn/problems/search-insert-position/description/</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：二分寻找目标值最左边界"><a href="#题解：二分寻找目标值最左边界" class="headerlink" title="题解：二分寻找目标值最左边界"></a>题解：二分寻找目标值最左边界</h3><p><strong>思路</strong>：</p><p>返回将要被插入的位置，其实就是寻找到target的最左边界, 找到最接近小于target的值的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分74-搜索二维矩阵"><a href="#二分74-搜索二维矩阵" class="headerlink" title="二分74. 搜索二维矩阵"></a>二分74. 搜索二维矩阵</h2><blockquote><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109603.png" alt="image-20230316132305748" style="zoom:25%;" /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：-二叉搜索树思想（消去行列）"><a href="#题解：-二叉搜索树思想（消去行列）" class="headerlink" title="题解： 二叉搜索树思想（消去行列）"></a>题解： 二叉搜索树思想（消去行列）</h3><p>详情可见：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg">剑指Offer.04 二维数组中的查找</a></p><p><strong>思路</strong>：</p><ul><li>以矩阵左下角位置<code>tmp</code>为观察点: 小于<code>tmp</code>的元素都在<code>tmp</code>所在行之上, 大于<code>tmp</code>的元素都在<code>tmp</code>所在列向右</li><li>所以, 每次比较<code>tmp</code>和<code>target</code>的值, 然后舍弃行列即可, 规则如下：<ul><li>若<code>target &gt; tmp</code>, 则说明<code>tmp</code>该列向左的元素都小于<code>target</code>, 所以舍弃该列，即<code>j++</code></li><li>若<code>target &lt; tmp</code>, 则说明<code>target</code>在<code>tmp</code>所在行之上，所以舍弃该行，即<code>i--</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (target &gt; matrix[i][j]) &#123;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; matrix[i][j]) &#123;<br>            i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分162-寻找峰值"><a href="#二分162-寻找峰值" class="headerlink" title="二分162. 寻找峰值"></a>二分162. 寻找峰值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-peak-element/description/">https://leetcode.cn/problems/find-peak-element/description/</a></p><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,1,3,5,6,4]</span><br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span> <br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；<br>     或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ol><li>由于是严格递增的，所以二分时只需要判断<code>nums[mid] &gt; nums[mid + 1]</code>即可。</li><li>由于需要将<code>mid</code>和<code>mid + 1</code>进行比较，所以<code>while</code>条件必须是<code>left &lt; right</code>，如果是<code>left &lt;= right</code>，则在一个元素时，会数组越界。</li><li><code>right</code>的初始化条件不能用<code>nums.lenght</code>，当只有一个元素时，是需要结束<code>while</code>循环的，所以当只有一个元素时，<code>left</code>和<code>right</code>必须相等。</li><li>由于<code>nums[nums.length]=负无穷</code>，所以二分查找大的那一半一定存在峰值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这里必须使用nums.length - 1, 因为只有一个元素时, left等于right直接返回</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这里必须是 &lt; , 如果是&lt;=, 则下面mid会越界</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">https://leetcode.cn/problems/binary-tree-preorder-traversal/description/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p></blockquote><h4 id="二叉树前序遍历："><a href="#二叉树前序遍历：" class="headerlink" title="二叉树前序遍历："></a>二叉树前序遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    res.add(root.val);<br>    preorderTraversal(root.left);<br>    preorderTraversal(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    inorderTraversal(root.left);<br>    res.add(root.val);<br>    inorderTraversal(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    postorderTraversal(root.left);<br>    postorderTraversal(root.right);<br>    res.add(root.val);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108652.png" alt="image-20230428173147211" style="zoom:50%;" /><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 记录每次层个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-comment">// 每一层放入一个列表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            tmp.add(poll.val);<br>            <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.right);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h2><blockquote><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/description/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/description/</a></p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108728.png" alt="image-20230514152733905"></p></blockquote><h4 id="题解：层序遍历对每层进行奇偶判断"><a href="#题解：层序遍历对每层进行奇偶判断" class="headerlink" title="题解：层序遍历对每层进行奇偶判断"></a>题解：层序遍历对每层进行奇偶判断</h4><p>层序遍历二叉树，初始化一个下标<code>index</code>用来判断是奇数层还是偶数层</p><ul><li>如果是奇数层则正常添加元素</li><li>如果是偶数层则向结果集倒着添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                tmp.addLast(poll.val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp.addFirst(poll.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(poll.right);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a>剑指 Offer 55 - I. 二叉树的深度</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/</a></p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108745.png" alt="image-20230514153159332"></p></blockquote><h3 id="题解：递归"><a href="#题解：递归" class="headerlink" title="题解：递归"></a>题解：递归</h3><ul><li>递归左子树和右子树，每次递归深度+1</li><li>每次递归都比较左右子树深度，取深度大的返回</li></ul><p>【可以背一下】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a>剑指 Offer 34. 二叉树中和为某一值的路径</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108969.png" alt="image-20230514155635577"></p></blockquote><h4 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h4><p><strong>思路</strong>：深度优先搜索枚举每条从根节点到叶子节点，当遍历到叶节点时并且此时路径和恰好是目标和时，就找到一条满足条件的路径。</p><blockquote><p>需要注意的是添加路径时要拷贝一份数组，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>    dfs(root, target, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target, List&lt;Integer&gt; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    arr.add(root.val);<br>    dfs(root.left, target - root.val, arr);<br>    dfs(root.right, target - root.val, arr);<br><br>    <span class="hljs-keyword">if</span> (target == root.val &amp;&amp; root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 这里不能直接加入arr, 而是要复制一份</span><br>        <span class="hljs-comment">// 因为直接加入是引用, arr后面还会变</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(arr));<br>        <span class="hljs-comment">// 这里也不能return, 因为该节点不能影响其他节点, 还需要将它移除</span><br>    &#125;<br>    <span class="hljs-comment">// 如果当前叶子节点不满足target, 需要把他移除, 该节点不影响其他节点</span><br>    arr.remove(arr.size() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(N^2)，其中N是树的节点数。最坏情况每条路径都符合要求，路径数目是N，节点数目也是N（这里是拷贝数组时的复杂度）。</p><p><strong>空间复杂度</strong>：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p><h4 id="题解二：广度优先搜索"><a href="#题解二：广度优先搜索" class="headerlink" title="题解二：广度优先搜索"></a>题解二：广度优先搜索</h4><p>遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，就找到了一条满足条件的路径。</p><p>为了节省空间，使用哈希表<code>map</code>记录树中的每一个节点的父节点。每次找到一个满足条件的节点，就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 存储最终结果</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 存储节点的父结点, 便于寻找完成路径 key: 节点 value: 父结点</span><br>    Map&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 层序遍历队列存储节点</span><br>    Queue&lt;TreeNode&gt; queueNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 存储层序遍历到当前节点时，前面已经累加的sum</span><br>    Queue&lt;Integer&gt; sumQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queueNode.offer(root);<br>    sumQueue.offer(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (!queueNode.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queueNode.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rec</span> <span class="hljs-operator">=</span> sumQueue.poll() + poll.val;<br><br>        <span class="hljs-keyword">if</span> (poll.left == <span class="hljs-literal">null</span> &amp;&amp; poll.right == <span class="hljs-literal">null</span> &amp;&amp; rec == target) &#123;<br>            getPath(poll, res, map);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 记录left的父结点</span><br>                map.put(poll.left, poll);<br>                queueNode.offer(poll.left);<br>                <span class="hljs-comment">// 说明还有叶节点，还需要继续遍历</span><br>                sumQueue.offer(rec);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                map.put(poll.right, poll);<br>                queueNode.offer(poll.right);<br>                sumQueue.offer(rec);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据叶节点获取完整路径</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode node, List&lt;List&lt;Integer&gt;&gt; res, Map&lt;TreeNode, TreeNode&gt; map)</span> &#123;<br>    LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>        tmp.addFirst(node.val);<br>        node = map.get(node);<br>    &#125;<br>    res.add(tmp);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(N^2)，其中 N 是树的节点数。</p><p><strong>空间复杂度</strong>：O(N)，其中 N是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数。</p><h2 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/">https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/</a></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108201.png" alt="image-20230514172511622"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108672.png" alt="image-20230514172535408"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p></blockquote><h4 id="题解：递归中序遍历-链表构造"><a href="#题解：递归中序遍历-链表构造" class="headerlink" title="题解：递归中序遍历+链表构造"></a>题解：递归中序遍历+链表构造</h4><p>算法流程：</p><ul><li><ol><li>中序遍历：二叉搜索树中序遍历结果是一个有序集</li></ol></li><li><ol start="2"><li>递归左子树，即midDfs(root.left)</li></ol></li><li><ol start="3"><li>构造链表：</li></ol><ul><li>当pre不为空时，修改双向节点引用，即：pre.right &#x3D; node, node.left &#x3D; pre</li><li>当pre为空时，表示正在访问头结点，即为head</li><li>保存node节点，作为下一个pre节点</li></ul></li><li><ol start="4"><li>递归右子树，即midDfs(root.right)</li></ol></li><li><ol start="5"><li>递归完成后，需要将头尾节点相连，此时pre就是尾结点。即：pre.right &#x3D; head, head.left &#x3D; pre</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">Node head, pre;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    midDfs(root);<br>    pre.right = head;<br>    head.left = pre;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">midDfs</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    midDfs(node.left);<br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>        pre.right = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 说明是第一个节点</span><br>        head = node;<br>    &#125;<br>    node.left = pre;<br>    pre = node;<br>    midDfs(node.right);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/</a></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108713.png" alt="image-20230514183743231"></p></blockquote><h4 id="题解：递归-1"><a href="#题解：递归-1" class="headerlink" title="题解：递归"></a>题解：递归</h4><ul><li>遇到不相等的节点返回<code>false</code></li><li>如果两个节点都为<code>null</code>，返回<code>true</code></li><li>如果只有一个节点为<code>null</code>，那肯定不是对称二叉树，返回<code>false</code></li><li>递归时判断的两个节点也有要求，怎么判断对称呢？<ul><li>左子树左节点跟右子树右节点比较</li><li>左子树右节点跟右子树左节点比较</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 根节点为null, 返回true</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 递归遍历左右子树</span><br>    <span class="hljs-keyword">return</span> dfs(root.left, root.right);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>    <span class="hljs-comment">// 左节点和右节点都为空, 返回true</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 左节点和右节点有一个为空, 返回false</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 节点值不相等 返回false</span><br>    <span class="hljs-keyword">if</span> (left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 判断 left节点的左节点和right的右节点 并且 left的右节点和right的左节点 是否对称</span><br>    <span class="hljs-keyword">return</span> dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">https://leetcode.cn/problems/merge-two-binary-trees/description/</a></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108138.png" alt="image-20230514184148616"></p></blockquote><h4 id="题解：递归-树的构建"><a href="#题解：递归-树的构建" class="headerlink" title="题解：递归+树的构建"></a>题解：递归+树的构建</h4><p>【建议背着】：递归构建树的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>    <span class="hljs-comment">// 遇到null，直接赋值另一个节点</span><br>    <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>    <span class="hljs-comment">// 都不是null相加构建一个新节点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">merge</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root1.val + root2.val);<br>    <span class="hljs-comment">// 构建新节点的左子树，对应的root1和root2的左子树</span><br>    merge.left = mergeTrees(root1.left, root2.left);<br>    <span class="hljs-comment">// 构建新节点的右子树，对应的root1和root2的右子树</span><br>    merge.right = mergeTrees(root1.right, root2.right);<br>    <span class="hljs-keyword">return</span> merge;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/">https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/</a></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108009.png" alt="image-20230514184616170"></p></blockquote><h4 id="题解一：递归-1"><a href="#题解一：递归-1" class="headerlink" title="题解一：递归"></a>题解一：递归</h4><p>深度优先搜索：递归交换左右子树节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root.left;<br>    <span class="hljs-comment">// 左右子树节点交换</span><br>    root.left = mirrorTree(root.right);<br>    root.right = mirrorTree(tmp);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：广度优先搜索-1"><a href="#题解二：广度优先搜索-1" class="headerlink" title="题解二：广度优先搜索"></a>题解二：广度优先搜索</h4><p>层序遍历交换左右节点，每次交换后，子树节点都被交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree2</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        <span class="hljs-comment">// 这里交换完node后，node的子树都被交换位置了</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.left;<br>        node.left = node.right;<br>        node.right = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li><p>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</p></li><li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108015.png" alt="image-20230514185014977"></p></li></ul></blockquote><h4 id="题解：中序遍历"><a href="#题解：中序遍历" class="headerlink" title="题解：中序遍历"></a>题解：中序遍历</h4><p><strong>二叉搜索树中序遍历是个有序数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个最小值</span><br><span class="hljs-type">long</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><span class="hljs-comment">// 默认是二叉搜索树</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    isValidBST(root.left);<br>    <span class="hljs-comment">// 根据二叉搜索树中序遍历是个有序数组的性质，可以在遍历过程中比较是否有序来判断</span><br>    <span class="hljs-keyword">if</span> (tmp &gt;= root.val) &#123;<br>        res = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将当前值保留与下一次比较</span><br>    tmp = root.val;<br>    isValidBST(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a>剑指 Offer 55 - II. 平衡二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/">https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/</a></p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108655.png" alt="image-20230514185146136"></p></blockquote><h4 id="题解：递归-2"><a href="#题解：递归-2" class="headerlink" title="题解：递归"></a>题解：递归</h4><p><strong>思路</strong>：主要思路就是判断左右子树深度相差值是否大于1，遍历每个节点，获取该节点左右子树的深度比较，如果小于等于1，则继续遍历该节点子树判断是否左右子树节点都满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果当前节点左右子树深度相差小于等于1，则说明是平衡二叉树</span><br>    <span class="hljs-keyword">if</span> (Math.abs(getHeight(root.left) - getHeight(root.right)) &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 接着递归遍历子节点, 并且左右子节点都要满足条件</span><br>        <span class="hljs-keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取左右子树中最大深度</span><br><span class="hljs-comment">     * 跳出递归条件: root=null, 深度返回0</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取当前节点左右子树深度最大值</span><br>    <span class="hljs-keyword">return</span> Math.max(getHeight(root.left) + <span class="hljs-number">1</span>, getHeight(root.right) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108209.png" alt="image-20230514185512678"></p></blockquote><h4 id="题解：递归-3"><a href="#题解：递归-3" class="headerlink" title="题解：递归"></a>题解：递归</h4><p><strong>思路</strong>：</p><ul><li>二叉搜索树性质: 左子树都小于root, 右子树都大于root</li><li>根据上面性质，如果要找最近公共祖先节点，则该节点一定大于左子树，小于右子树<ul><li>如果两个节点都大于root节点，则说明公共祖先在右子树，递归右子树即可</li><li>如果两个节点都小于root节点，则说明公共祖先在左子树，递归左子树即可</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 当前节点值大于p、q，说明公共节点在左子树</span><br>    <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>    &#125;<br><br>    <span class="hljs-comment">// // 当前节点值小于p、q，说明公共节点在右子树</span><br>    <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a>剑指 Offer 37. 序列化二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/">https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/</a></p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示：</strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode-cn.com/hc/kb/article/1567641/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p> <img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108752.png" alt="image-20230514185732869"></p></blockquote><h4 id="题解：构建二叉树"><a href="#题解：构建二叉树" class="headerlink" title="题解：构建二叉树"></a>题解：构建二叉树</h4><p><strong>思路</strong>：这道题挺开放的，序列化方法可以自定义一个，感觉<strong>主要考点是如何构造树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Encodes a tree to a single string. 递归将数节点转为string</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 遇到空节点存为&quot;null&quot;</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null,&quot;</span>;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> root.val + <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-comment">// 递归前序遍历</span><br>    res += serialize(root.left);<br>    res += serialize(root.right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// Decodes your encoded data to tree.</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>    <span class="hljs-comment">// 先将节点解析出来存到队列中</span><br>    String[] split = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String str : split) &#123;<br>        queue.offer(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> deserialize(queue);<br>&#125;<br><br><br><span class="hljs-comment">// 主要方法在这里，如何构造树</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Queue&lt;String&gt; queue)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> queue.poll();<br>    <span class="hljs-comment">// &quot;null&quot;节点对应数的空节点，所以返回null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;null&quot;</span>.equals(val)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先序构造一颗树</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(val));<br>    treeNode.left = deserialize(queue);<br>    treeNode.right = deserialize(queue);<br>    <span class="hljs-keyword">return</span> treeNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109837.png" alt="image-20230514190009364"></p></blockquote><h4 id="题解：根据先序和中序构建二叉树"><a href="#题解：根据先序和中序构建二叉树" class="headerlink" title="题解：根据先序和中序构建二叉树"></a>题解：根据先序和中序构建二叉树</h4><p><strong>思路</strong>：</p><p>preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</p><ol><li><p>先从前序遍历获取树的根节点，在中序遍历中根据根节点可以判断该根节点的左右子树节点以及个数</p></li><li><p>根据上一步获得的左右子树个数，可以获取前序遍历中该根节点的左右子树个数</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> preorder.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        map.put(inorder[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buildTree(preorder, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, map);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> preorder 前序遍历数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startPreOrder 当前根节点对应的子树节点在前序数组中的起始下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endPreOrder 当前根节点对应的子树节点在前序数组中的终止下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inorder 中序遍历数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startInOrder 当前根节点对应的子树节点在中序数组中的起始下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endInOrder 当前根节点对应的子树节点在中序数组中的终止下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 中序数组节点和下标映射关系，方便获取节点在中序中的位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> startPreOrder, <span class="hljs-type">int</span> endPreOrder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> startInOrder, <span class="hljs-type">int</span> endInOrder, Map&lt;Integer, Integer&gt; map)</span> &#123;<br>    <span class="hljs-comment">// 判断边界</span><br>    <span class="hljs-keyword">if</span> (startPreOrder &gt; endPreOrder) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从先序遍历中获取根节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[startPreOrder];<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>    <span class="hljs-comment">// 如果先序遍历节点是最后一个</span><br>    <span class="hljs-keyword">if</span> (startPreOrder != endPreOrder) &#123;<br>        <span class="hljs-comment">// 获取根节点在中序遍历中的下标index</span><br>        <span class="hljs-comment">// [startInOrder, index-1]是当前root的左子树</span><br>        <span class="hljs-comment">// [index+1, endInOrder]是当前root的右子树</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(rootVal);<br>        <span class="hljs-comment">// 计算前序遍历中左右子树分界线</span><br>        <span class="hljs-comment">// 根据节点在中序遍历中的位置可以确定该节点左右子树的节点个数</span><br>        <span class="hljs-comment">// 然后在前序遍历中根据左右子树个数把前序遍历分成左右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNodes</span> <span class="hljs-operator">=</span> index - startInOrder;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightNodes</span> <span class="hljs-operator">=</span> endInOrder - index - <span class="hljs-number">1</span>;<br>        root.left = buildTree(preorder, startPreOrder + <span class="hljs-number">1</span>, startPreOrder + leftNodes, inorder, startInOrder, index - <span class="hljs-number">1</span>, map);<br>        root.right = buildTree(preorder, endPreOrder - rightNodes, endPreOrder, inorder, index + <span class="hljs-number">1</span>, endInOrder, map);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-046-二叉树的右侧视图"><a href="#剑指-Offer-II-046-二叉树的右侧视图" class="headerlink" title="剑指 Offer II 046. 二叉树的右侧视图"></a>剑指 Offer II 046. 二叉树的右侧视图</h2><blockquote><p><a href="https://leetcode.cn/problems/WNC0Lk/">https://leetcode.cn/problems/WNC0Lk/</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109027.png" alt="image-20230515125911354" style="zoom:50%;" /></blockquote><h4 id="题解：层序遍历"><a href="#题解：层序遍历" class="headerlink" title="题解：层序遍历"></a>题解：层序遍历</h4><p><strong>思路</strong>：层序遍历每层最后一个节点就是右视图看到的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-comment">// 如果是队列最后一个则添加到结果集中</span><br>            <span class="hljs-keyword">if</span> (i == size - <span class="hljs-number">1</span>) &#123;<br>                res.add(node.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h2><blockquote><p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/?favorite=xb9nqhhg</a></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong>2 &lt;&#x3D; n &lt;&#x3D; 100000</p></blockquote><h3 id="题解一：-集合Set"><a href="#题解一：-集合Set" class="headerlink" title="题解一： 集合Set"></a>题解一： 集合Set</h3><p>使用集合记录数组各个数字，遇到重复数字直接返回。</p><blockquote><p>时间复杂度：O(n)，Set查找元素O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(num)) &#123;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：-原地交换数字"><a href="#题解二：-原地交换数字" class="headerlink" title="题解二： 原地交换数字"></a>题解二： 原地交换数字</h3><ol><li><p>遍历数组 nums ，设索引初始值为 i&#x3D;0 :</p><ul><li><p>若 <code>nums[i]=i</code>，说明此数字已在对应索引位置，无需交换，因此跳过；</p></li><li><p>若 <code>nums[nums[i]]=nums[i]</code>， 说明索引<code>nums[i]</code>处和索引<code>i</code>处的元素值都为<code>nums[i]</code>，即找到一组重复值；</p></li><li><p>否则，交换索引<code>i</code>和索引<code>nums[i]</code>的元素值，将此数字交换置对应索引位置。</p></li></ul></li><li><p>若遍历完未返回，返回-1.</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == i) &#123;<br>            i++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i]]) &#123;<br>            <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 交换位置，直到nums[i] = i</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[tmp];<br>        nums[tmp] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h2><blockquote><p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg</a></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,   4,  7, 11, 15]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,   5,  8, 12, 19]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[3,   6,  9, 16, 22]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[10, 13, 14, 17, 24]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[18, 21, 23, 26, 30]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。</p><p>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p></blockquote><h3 id="题解一：二分查找"><a href="#题解一：二分查找" class="headerlink" title="题解一：二分查找"></a>题解一：二分查找</h3><p>由于矩阵的行和列都是有序的，所以可以遍历行或者列使用二分查找来判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = ints.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (ints[index] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ints[index] &lt; target) &#123;<br>                l++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ints[index] &gt; target) &#123;<br>                r--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：-二叉搜索树思想（消去行列）"><a href="#题解二：-二叉搜索树思想（消去行列）" class="headerlink" title="题解二： 二叉搜索树思想（消去行列）"></a>题解二： 二叉搜索树思想（消去行列）</h3><p>如下图所示：将矩阵逆时针旋转，可以发现其类似于<strong>二叉搜索树</strong>。即每个元素，左分支元素更小，右分支元素更大。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110518.png" alt="image-20230316132855942" style="zoom:50%;" /><p>因此，以左下角元素或者右上角元素为基础<code>flag</code>，则有：</p><ul><li>若<code>target &lt; flag</code>：则<code>target</code>一定在<code>flag</code>所在行的上面，这样<code>flag</code>所在<strong>行</strong>就可以消除。</li><li>若<code>target &gt; flag</code>：则<code>target</code>一定在<code>flag</code>所在列的右方，这样<code>flag</code>所在<strong>列</strong>就可以消除。</li></ul><p>复杂度分析：</p><ul><li>时间复杂度：<code>O(M + N)</code>，M和N为矩阵行数和列数</li><li>空间复杂度：<code>O(1)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 从左下角元素开始</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) &#123;<br>            <span class="hljs-comment">// target一定在matrix[i][j]上方，消除行</span><br>            i--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;<br>            <span class="hljs-comment">// target一定在matrix[i][j]右方，消除列</span><br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/?favorite=xb9nqhhg</a></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p>【示例】：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：s = <span class="hljs-string">&quot;We are happy.&quot;</span><br>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：直接调用replace方法"><a href="#题解一：直接调用replace方法" class="headerlink" title="题解一：直接调用replace方法"></a>题解一：直接调用replace方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解二：遍历替换"><a href="#题解二：遍历替换" class="headerlink" title="题解二：遍历替换"></a>题解二：遍历替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sb.append(ch);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><blockquote><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/?favorite=xb9nqhhg</a></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：普通遍历"><a href="#题解：普通遍历" class="headerlink" title="题解：普通遍历"></a>题解：普通遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        res.add(head.val);<br>        head = head.next;<br>    &#125;<br>    Collections.reverse(res);<br>    <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a>剑指 Offer 51. 数组中的逆序对</h2><blockquote><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/</a></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,5,6,4]</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：归并排序"><a href="#题解一：归并排序" class="headerlink" title="题解一：归并排序"></a>题解一：归并排序</h3><p><strong>思路</strong>：求逆序对跟归并排序有啥关系？？？</p><p><strong>归并排序和逆序对关系</strong>，比如下面例子：</p><p>假设有两个已排序的序列等待合并，<code>L=&#123;8,12,16,22,100&#125;  R=&#123;9,26,55,64,91&#125;</code>。开始我们用指针 <code>lPtr = 0</code> 指向 L 的首部，<code>rPtr = 0</code> 指向 R 的头部。记已经合并好的部分为M。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">L = [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>, <span class="hljs-number">100</span>]   R = [<span class="hljs-number">9</span>, <span class="hljs-number">26</span>, <span class="hljs-number">55</span>, <span class="hljs-number">64</span>, <span class="hljs-number">91</span>]  M = []<br>     |                          |<br>   lPtr                       rPtr<br></code></pre></td></tr></table></figure><p>发现<code>lPtr</code>指向的元素小于<code>rPtr</code>指向的元素，于是把<code>lPtr</code>指向的元素放入M，并把<code>lPtr</code>向后移一位。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">L = [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>, <span class="hljs-number">100</span>]   R = [<span class="hljs-number">9</span>, <span class="hljs-number">26</span>, <span class="hljs-number">55</span>, <span class="hljs-number">64</span>, <span class="hljs-number">91</span>]  M = [<span class="hljs-number">8</span>]<br>        |                       |<br>      lPtr                     rPtr<br></code></pre></td></tr></table></figure><p>这时把8放入答案，但是发现右边没有数比8小，所以8对逆序对总数【贡献】为0。</p><p>继续合并，<strong>此时发现<code>lPtr</code>所指的位置比<code>rPtr</code>大，由于归并排序每个子数组都是有序的，则对于<code>rPtr</code>而言，<code>lPtr</code>右侧的所有数都比它大，即<code>lPtr</code>右侧每个数都能和<code>rPtr</code>构成一个逆序对。贡献为<code>mid - lPtr + 1</code>。</strong></p><hr><p>利用上述思路，可以在归并的过程中计算逆序对的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.res = <span class="hljs-number">0</span>;<br>        mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            mergeSort(nums, left, mid);<br>            mergeSort(nums, mid + <span class="hljs-number">1</span>, right);<br>            merge(nums, left, mid, right);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                tmp[k++] = nums[j++];<br>                <span class="hljs-comment">// 右边当前值比左边当前值都要小，则右边当前值对于左边剩余部分的mid-i+1个数都是逆序</span><br>                res += (mid - i + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 左边当前值小于右边当前值, 不是逆序</span><br>                tmp[k++] = nums[i++];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            tmp[k++] = nums[i++];<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            tmp[k++] = nums[j++];<br>        &#125;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; t &lt; tmp.length; t++)&#123;<br>            nums[left + t] = tmp[t];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 </p><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解：二分查找"><a href="#题解：二分查找" class="headerlink" title="题解：二分查找"></a>题解：二分查找</h3><p><strong>思路</strong>:</p><p>以数组最右侧的元素x为参考比较：<strong>在最小值右侧的元素，一定小于等于x；在最小值左侧的元素，一定大于等于x。</strong></p><p>以<code>mid</code>为中点，左边界为<code>low</code>，右边界为<code>high</code>。然后将中值元素和<code>nums[high]</code>比较：</p><ul><li>如果<code>nums[mid] &lt; nums[high]</code>：则<code>nums[mid]</code>是最小值右侧元素，二分查找可以忽略右边部分，即<code>right = mid</code>；</li><li>如果<code>nums[mid] &gt; nums[high]</code>：则<code>nums[mid]</code>是最小值左侧元素，二分查找可以忽略左侧部分，即<code>left = mid + 1</code>；</li><li>如果<code>nums[mid] == nums[high]</code>：则不能判断<code>nums[mid]</code>在最小值左侧还是右侧，但不管<code>nums[high]</code>是不是最小值，都有一个值替代它，所以忽略该值即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> numbers.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 为什么以right处元素为参考？</span><br>        <span class="hljs-comment">// right处元素一定小于或等于0位置元素, 比right处还小的元素一定在最小值和right处元素之间，比right处大的元素一定在0到最小值之间</span><br>        <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;<br>            <span class="hljs-comment">// 说明nums[mid]在最小值右侧, 则right-mid这部分可以丢弃</span><br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right])&#123;<br>            <span class="hljs-comment">// 说明nums[mid]在最小值左侧, 则left~mid这部分可以丢弃</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果相等，则不能确定在最小值左侧还是右侧，但是可以忽略这个相等值</span><br>            right -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numbers[right];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h2><blockquote><p><a href="https://leetcode.cn/problems/compare-version-numbers/description/">https://leetcode.cn/problems/compare-version-numbers/description/</a></p><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.01&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.001&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：忽略前导零，<span class="hljs-string">&quot;01&quot;</span> 和 <span class="hljs-string">&quot;001&quot;</span> 都表示相同的整数 <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.0&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.0.0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：versio<span class="hljs-symbol">n1</span> 没有指定下标为 <span class="hljs-number">2</span> 的修订号，即视为 <span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;0.1&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.1&quot;</span><br>输出：<span class="hljs-number">-1</span><br>解释：versio<span class="hljs-symbol">n1</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;0&quot;</span>，versio<span class="hljs-symbol">n2</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;1&quot;</span> 。<span class="hljs-number">0</span> &lt; <span class="hljs-number">1</span>，所以 versio<span class="hljs-symbol">n1</span> &lt; versio<span class="hljs-symbol">n2</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="题解一：字符串分割"><a href="#题解一：字符串分割" class="headerlink" title="题解一：字符串分割"></a>题解一：字符串分割</h3><p><strong>思路</strong>：</p><ul><li>由于需要忽略前导零，所以以<code>.</code>为分隔符拆分，利用<code>Integer.parseInt()</code>的特性可以直接将前导零消除，将字符串转为数字。</li><li>为了优化代码结构，初始默认值设为0，这样后面不用再分别判断某一边剩余情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareVersion</span><span class="hljs-params">(String version1, String version2)</span> &#123;<br>    String[] split1 = version1.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    String[] split2 = version2.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; split1.length || j &lt; split2.length) &#123;<br>        <span class="hljs-comment">// 这里赋默认值为0：当某一version分割后数组长度短时，需要继续对另一个version进行判断，就和0比较</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, v2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; split1.length) &#123;<br>            v1 = Integer.parseInt(split1[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j &lt; split2.length) &#123;<br>            v2 = Integer.parseInt(split2[j]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (v1 &gt; v2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1 &lt; v2) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用算法积累</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="排序算法时间复杂度"><a href="#排序算法时间复杂度" class="headerlink" title="排序算法时间复杂度"></a>排序算法时间复杂度</h2><ul><li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107305.png" alt="img"></p><p><strong>图片名词解释：</strong></p><ul><li><code>n</code>: 数据规模</li><li><code>k</code>: “桶”的个数</li><li><code>In-place</code>: 占用常数内存，不占用额外内存</li><li><code>Out-place</code>: 占用额外内存</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107123.jpg" alt="img"></p><h1 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h2><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 冒泡排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-keyword">if</span> (array.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> array;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)<br>                <span class="hljs-keyword">if</span> (array[j + <span class="hljs-number">1</span>] &lt; array[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>                    array[j + <span class="hljs-number">1</span>] = array[j];<br>                    array[j] = temp;<br>                &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-算法分析"><a href="#2-3-算法分析" class="headerlink" title="2.3 算法分析"></a>2.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：当输入的数据是反序时</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：当输入的数据已经有序时，只需遍历一遍用于确认数据已有序。</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h1><p>工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-算法分析"><a href="#3-3-算法分析" class="headerlink" title="3.3 算法分析"></a>3.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最坏时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最好时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>不稳定</code></strong></li></ul><h1 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h1><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h2><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        arr[preIndex + <span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-算法分析"><a href="#4-3-算法分析" class="headerlink" title="4.3 算法分析"></a>4.3 算法分析</h2><ul><li><strong>-平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：输入数组按降序排列（完全逆序）</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：输入数组按升序排列（基本有序）</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性：<code>稳定</code></strong></li></ul><h2 id="4-4-改进方法"><a href="#4-4-改进方法" class="headerlink" title="4.4 改进方法"></a>4.4 改进方法</h2><p>改进思路一：查找插入位置时使用二分查找的方式，减少比较次数。</p><h1 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h1><p><strong>该方法实质上是一种分组插入方法</strong>，希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ul><h2 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107634.png" alt="img"></p><h2 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            temp = arr[i];<br>            <span class="hljs-comment">// 寻找前面已排序队列中比temp大的，向后移动，这里和插入排序一直，只是间距不一样</span><br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; temp) &#123;<br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap; <br>            &#125;<br>            arr[preIndex + gap] = temp;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-算法分析"><a href="#5-2-算法分析" class="headerlink" title="5.2 算法分析"></a>5.2 算法分析</h2><ul><li><p><strong>平均时间复杂度：<code>T(n) = O(n^1.5)</code></strong></p></li><li><p><strong>最坏时间复杂度：<code>T(n) = O(nlog²n）</code></strong></p></li><li><p><strong>空间复杂度: <code>O(1)</code></strong></p></li><li><p>**稳定性: <code>不稳定</code>**，由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p></li></ul><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h2 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h2><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>        mergeSort(arr, low, mid);<br>        mergeSort(arr, mid + <span class="hljs-number">1</span>, high);<br>        merge(arr, low, mid, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high - low + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> low;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= high) &#123;<br>        <span class="hljs-keyword">if</span> (arr[left] &lt; arr[right]) &#123;<br>            help[index++] = arr[left++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            help[index++] = arr[right++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= mid) &#123;<br>        help[index++] = arr[left++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (right &lt;= high) &#123;<br>        help[index++] = arr[right++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>        arr[low + i] = help[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-算法分析"><a href="#6-3-算法分析" class="headerlink" title="6.3 算法分析"></a>6.3 算法分析</h2><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(n)</code></strong></li><li>**空间复杂度: <code>O(n)</code>**，归并排序需要一个与原数组相同长度的数组做辅助来排序</li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7. 快速排序"></a>7. 快速排序</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h2 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h2 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> partition(arr, low, high);<br>        quickSort(arr, low, mid - <span class="hljs-number">1</span>);<br>        quickSort(arr, mid + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= key) &#123;<br>            high--;<br>        &#125;<br>        swap(arr, low, high);<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= key) &#123;<br>            low++;<br>        &#125;<br>        swap(arr, low, high);<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-算法分析"><a href="#7-3-算法分析" class="headerlink" title="7.3 算法分析"></a>7.3 算法分析</h2><ul><li>**最佳情况：<code>T(n) = O(nlogn)</code>**，快速排序最优的情况就是每一次取到的元素都刚好平分整个数组</li><li>**最差情况：<code>T(n) = O(n²)</code>**，最差的情况就是每一次取到的元素就是数组中最小&#x2F;最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)</li><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8. 堆排序"></a>8. 堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h2 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h2><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h2 id="8-2-代码实现"><a href="#8-2-代码实现" class="headerlink" title="8.2 代码实现"></a>8.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (arr.length / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        adjust(arr, i, arr.length);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        swap(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> -i);<br>        adjust(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> - i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjust</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bigIndex</span> <span class="hljs-operator">=</span> index;<br><br>    <span class="hljs-keyword">if</span> (leftIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[leftIndex]) &#123;<br>        bigIndex = leftIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (rightIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[rightIndex]) &#123;<br>        bigIndex = rightIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bigIndex != index) &#123;<br>        swap(arr, index, bigIndex);<br>        adjust(arr, bigIndex, len);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-算法分析"><a href="#8-3-算法分析" class="headerlink" title="8.3 算法分析"></a>8.3 算法分析</h2><p><strong>调堆：O(h)</strong><br><strong>建堆：O(n)</strong><br><strong>循环调堆：O(nlogn)</strong><br>总运行时间<code>T(n) = O(nlogn) + O(n) = O(nlogn)</code>。对于堆排序的最好情况与最坏情况的运行时间，因为最坏与最好的输入都只是影响建堆的运行时间O(1)或者O(n)，而在总体时间中占重要比例的是循环调堆的过程，即O(nlogn) + O(1) &#x3D;O(nlogn) + O(n) &#x3D; O(nlogn)。因此最好或者最坏情况下，堆排序的运行时间都是O(nlogn)。而且堆排序还是 <a href="http://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地算法（in-place algorithm）</a> 。</p><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>空间复杂度：<code>O(1)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="9-计数排序"><a href="#9-计数排序" class="headerlink" title="9. 计数排序"></a>9. 计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h2 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h2><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h2 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] countSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>            max = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>            min = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - min + <span class="hljs-number">1</span>];<br>    Arrays.fill(bucket, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> - min;      <span class="hljs-comment">// 防止数组中有负数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        bucket[arr[i] + ans]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; arr.length) &#123;<br>        <span class="hljs-keyword">if</span> (bucket[i] != <span class="hljs-number">0</span>) &#123;<br>            arr[index] = i - ans;<br>            bucket[i]--;    <span class="hljs-comment">// 该数值个数减1</span><br>            index++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-3-算法分析"><a href="#9-3-算法分析" class="headerlink" title="9.3 算法分析"></a>9.3 算法分析</h2><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k)  **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n+k)</strong></p></li></ul><h1 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10. 桶排序"></a>10. 桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h2 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h2><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize&#x3D;&#x3D;5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092107423.png" alt="img"></p><h2 id="10-2-代码实现"><a href="#10-2-代码实现" class="headerlink" title="10.2 代码实现"></a>10.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 桶排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketSize</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">BucketSort</span><span class="hljs-params">(ArrayList&lt;Integer&gt; array, <span class="hljs-type">int</span> bucketSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.size() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>), min = array.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 找到最大值最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (array.get(i) &gt; max)<br>            max = array.get(i);<br>        <span class="hljs-keyword">if</span> (array.get(i) &lt; min)<br>            min = array.get(i);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(bucketCount);<br>    ArrayList&lt;Integer&gt; resultArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (bucketSize == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketArr.get(i).size(); j++)<br>                resultArr.add(bucketArr.get(i).get(j));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (bucketCount == <span class="hljs-number">1</span>)<br>                bucketSize--;<br>            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; temp.size(); j++)<br>                resultArr.add(temp.get(j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultArr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-3-算法分析"><a href="#10-3-算法分析" class="headerlink" title="10.3 算法分析"></a>10.3 算法分析</h2><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k) **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n2)</strong></p></li></ul><p>　　</p><h1 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11. 基数排序"></a>11. 基数排序</h1><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h2 id="11-1-算法描述"><a href="#11-1-算法描述" class="headerlink" title="11.1 算法描述"></a>11.1 算法描述</h2><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h2 id="11-2-代码实现"><a href="#11-2-代码实现" class="headerlink" title="11.2 代码实现"></a>11.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基数排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] RadixSort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-comment">// 1.先算出最大数的位数；</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>        max = Math.max(max, array[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDigit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>        max /= <span class="hljs-number">10</span>;<br>        maxDigit++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, div = <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        bucketList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigit; i++, mod *= <span class="hljs-number">10</span>, div *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (array[j] % mod) / div;<br>            bucketList.get(num).add(array[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketList.size(); j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; bucketList.get(j).size(); k++)<br>                array[index++] = bucketList.get(j).get(k);<br>            bucketList.get(j).clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-3-算法分析"><a href="#11-3-算法分析" class="headerlink" title="11.3 算法分析"></a>11.3 算法分析</h2><p><strong>最佳情况：T(n) &#x3D; O(n * k)  最差情况：T(n) &#x3D; O(n * k)  平均情况：T(n) &#x3D; O(n * k)</strong></p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序 LSD 从低位开始进行排序 </p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h1><p><strong>稳定</strong>的排序：<strong>冒泡排序，插入排序，归并排序</strong><br><strong>不稳定</strong>的排序：<strong>选择排序，堆排序，快速排序，希尔排序</strong></p><p><strong>平均</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>希尔排序，归并排序，快速排序，堆排序</strong><br><strong>平均</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序</strong></p><p><strong>最好</strong>时间复杂度<code>T(n) = O(n)</code>：<strong>冒泡排序，插入排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，快速排序，堆排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>简单选择排序</strong></p><p><strong>最坏</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，堆排序</strong><br><strong>最坏</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序，快速排序</strong></p><p>空间复杂度<code>O(1)</code>：<strong>冒泡排序，简单选择排序，插入排序，希尔排序，堆排序</strong><br>空间复杂度<code>O(n)</code>：<strong>归并排序</strong><br>空间复杂度<code>O(nlogn)</code>：<strong>快速排序</strong></p><h1 id="13-参考资料"><a href="#13-参考资料" class="headerlink" title="13. 参考资料"></a>13. 参考资料</h1><ul><li><a href="https://segmentfault.com/a/1190000021638663">https://segmentfault.com/a/1190000021638663</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法及其时间复杂度</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-排序算法时间复杂度"><a href="#1-排序算法时间复杂度" class="headerlink" title="1. 排序算法时间复杂度"></a>1. 排序算法时间复杂度</h1><ul><li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111128.png" alt="image-20230316225544936"></p><p><strong>图片名词解释：</strong></p><ul><li><code>n</code>: 数据规模</li><li><code>k</code>: “桶”的个数</li><li><code>In-place</code>: 占用常数内存，不占用额外内存</li><li><code>Out-place</code>: 占用额外内存</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111912.png" alt="image-20230316225626782"></p><h1 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h2><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 冒泡排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-keyword">if</span> (array.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> array;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)<br>                <span class="hljs-keyword">if</span> (array[j + <span class="hljs-number">1</span>] &lt; array[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>                    array[j + <span class="hljs-number">1</span>] = array[j];<br>                    array[j] = temp;<br>                &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-算法分析"><a href="#2-3-算法分析" class="headerlink" title="2.3 算法分析"></a>2.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：当输入的数据是反序时</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：当输入的数据已经有序时，只需遍历一遍用于确认数据已有序。</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h1><p>工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-算法分析"><a href="#3-3-算法分析" class="headerlink" title="3.3 算法分析"></a>3.3 算法分析</h2><ul><li><strong>平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最坏时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>最好时间复杂度: <code>T(n) = O(n²)</code></strong></li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性: <code>不稳定</code></strong></li></ul><h1 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h1><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h2><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        arr[preIndex + <span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-算法分析"><a href="#4-3-算法分析" class="headerlink" title="4.3 算法分析"></a>4.3 算法分析</h2><ul><li><strong>-平均时间复杂度: <code>T(n) = O(n²)</code></strong></li><li>**最坏时间复杂度: <code>T(n) = O(n²)</code>**：输入数组按降序排列（完全逆序）</li><li>**最好时间复杂度: <code>T(n) = O(n)</code>**：输入数组按升序排列（基本有序）</li><li><strong>空间复杂度: <code>O(1)</code></strong></li><li><strong>稳定性：<code>稳定</code></strong></li></ul><h2 id="4-4-改进方法"><a href="#4-4-改进方法" class="headerlink" title="4.4 改进方法"></a>4.4 改进方法</h2><p>改进思路一：查找插入位置时使用二分查找的方式，减少比较次数。</p><h1 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h1><p><strong>该方法实质上是一种分组插入方法</strong>，希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ul><h2 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111680.png" alt="img"></p><h2 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            temp = arr[i];<br>            <span class="hljs-comment">// 寻找前面已排序队列中比temp大的，向后移动，这里和插入排序一直，只是间距不一样</span><br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; temp) &#123;<br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap; <br>            &#125;<br>            arr[preIndex + gap] = temp;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-算法分析"><a href="#5-2-算法分析" class="headerlink" title="5.2 算法分析"></a>5.2 算法分析</h2><ul><li><p><strong>平均时间复杂度：<code>T(n) = O(n^1.5)</code></strong></p></li><li><p><strong>最坏时间复杂度：<code>T(n) = O(nlog²n）</code></strong></p></li><li><p><strong>空间复杂度: <code>O(1)</code></strong></p></li><li><p>**稳定性: <code>不稳定</code>**，由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p></li></ul><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h2 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h2><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>        mergeSort(arr, low, mid);<br>        mergeSort(arr, mid + <span class="hljs-number">1</span>, high);<br>        merge(arr, low, mid, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high - low + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> low;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= high) &#123;<br>        <span class="hljs-keyword">if</span> (arr[left] &lt; arr[right]) &#123;<br>            help[index++] = arr[left++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            help[index++] = arr[right++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= mid) &#123;<br>        help[index++] = arr[left++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (right &lt;= high) &#123;<br>        help[index++] = arr[right++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>        arr[low + i] = help[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-算法分析"><a href="#6-3-算法分析" class="headerlink" title="6.3 算法分析"></a>6.3 算法分析</h2><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(n)</code></strong></li><li>**空间复杂度: <code>O(n)</code>**，归并排序需要一个与原数组相同长度的数组做辅助来排序</li><li><strong>稳定性: <code>稳定</code></strong></li></ul><h1 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7. 快速排序"></a>7. 快速排序</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h2 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h2 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low 传入数组起始下标，一般为0</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 传入数组终止下标，一般为 arr.length - 1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> partition(arr, low, high);<br>        quickSort(arr, low, mid - <span class="hljs-number">1</span>);<br>        quickSort(arr, mid + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= key) &#123;<br>            high--;<br>        &#125;<br>        swap(arr, low, high);<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= key) &#123;<br>            low++;<br>        &#125;<br>        swap(arr, low, high);<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-算法分析"><a href="#7-3-算法分析" class="headerlink" title="7.3 算法分析"></a>7.3 算法分析</h2><ul><li>**最佳情况：<code>T(n) = O(nlogn)</code>**，快速排序最优的情况就是每一次取到的元素都刚好平分整个数组</li><li>**最差情况：<code>T(n) = O(n²)</code>**，最差的情况就是每一次取到的元素就是数组中最小&#x2F;最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)</li><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8. 堆排序"></a>8. 堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h2 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h2><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h2 id="8-2-代码实现"><a href="#8-2-代码实现" class="headerlink" title="8.2 代码实现"></a>8.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (arr.length / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        adjust(arr, i, arr.length);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        swap(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> -i);<br>        adjust(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> - i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjust</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bigIndex</span> <span class="hljs-operator">=</span> index;<br><br>    <span class="hljs-keyword">if</span> (leftIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[leftIndex]) &#123;<br>        bigIndex = leftIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (rightIndex &lt; len &amp;&amp; arr[bigIndex] &lt; arr[rightIndex]) &#123;<br>        bigIndex = rightIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bigIndex != index) &#123;<br>        swap(arr, index, bigIndex);<br>        adjust(arr, bigIndex, len);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-算法分析"><a href="#8-3-算法分析" class="headerlink" title="8.3 算法分析"></a>8.3 算法分析</h2><p><strong>调堆：O(h)</strong><br><strong>建堆：O(n)</strong><br><strong>循环调堆：O(nlogn)</strong><br>总运行时间<code>T(n) = O(nlogn) + O(n) = O(nlogn)</code>。对于堆排序的最好情况与最坏情况的运行时间，因为最坏与最好的输入都只是影响建堆的运行时间O(1)或者O(n)，而在总体时间中占重要比例的是循环调堆的过程，即O(nlogn) + O(1) &#x3D;O(nlogn) + O(n) &#x3D; O(nlogn)。因此最好或者最坏情况下，堆排序的运行时间都是O(nlogn)。而且堆排序还是 <a href="http://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地算法（in-place algorithm）</a> 。</p><ul><li><strong>平均情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最差情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>最佳情况：<code>T(n) = O(nlogn)</code></strong></li><li><strong>空间复杂度：<code>O(1)</code></strong></li><li><strong>稳定性：<code>不稳定</code></strong></li></ul><h1 id="9-计数排序"><a href="#9-计数排序" class="headerlink" title="9. 计数排序"></a>9. 计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h2 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h2><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h2 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] countSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>            max = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>            min = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - min + <span class="hljs-number">1</span>];<br>    Arrays.fill(bucket, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> - min;      <span class="hljs-comment">// 防止数组中有负数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        bucket[arr[i] + ans]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; arr.length) &#123;<br>        <span class="hljs-keyword">if</span> (bucket[i] != <span class="hljs-number">0</span>) &#123;<br>            arr[index] = i - ans;<br>            bucket[i]--;    <span class="hljs-comment">// 该数值个数减1</span><br>            index++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-3-算法分析"><a href="#9-3-算法分析" class="headerlink" title="9.3 算法分析"></a>9.3 算法分析</h2><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k)  **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n+k)</strong></p></li></ul><h1 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10. 桶排序"></a>10. 桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h2 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h2><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize&#x3D;&#x3D;5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111683.png" alt="img"></p><h2 id="10-2-代码实现"><a href="#10-2-代码实现" class="headerlink" title="10.2 代码实现"></a>10.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 桶排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketSize</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">BucketSort</span><span class="hljs-params">(ArrayList&lt;Integer&gt; array, <span class="hljs-type">int</span> bucketSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.size() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>), min = array.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 找到最大值最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (array.get(i) &gt; max)<br>            max = array.get(i);<br>        <span class="hljs-keyword">if</span> (array.get(i) &lt; min)<br>            min = array.get(i);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(bucketCount);<br>    ArrayList&lt;Integer&gt; resultArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (bucketSize == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketArr.get(i).size(); j++)<br>                resultArr.add(bucketArr.get(i).get(j));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (bucketCount == <span class="hljs-number">1</span>)<br>                bucketSize--;<br>            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; temp.size(); j++)<br>                resultArr.add(temp.get(j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultArr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-3-算法分析"><a href="#10-3-算法分析" class="headerlink" title="10.3 算法分析"></a>10.3 算法分析</h2><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><ul><li><p>**最佳情况：T(n) &#x3D; O(n+k) **</p></li><li><p>**最差情况：T(n) &#x3D; O(n+k)  **</p></li><li><p><strong>平均情况：T(n) &#x3D; O(n2)</strong></p></li></ul><p>　　</p><h1 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11. 基数排序"></a>11. 基数排序</h1><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h2 id="11-1-算法描述"><a href="#11-1-算法描述" class="headerlink" title="11.1 算法描述"></a>11.1 算法描述</h2><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h2 id="11-2-代码实现"><a href="#11-2-代码实现" class="headerlink" title="11.2 代码实现"></a>11.2 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基数排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] RadixSort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-comment">// 1.先算出最大数的位数；</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>        max = Math.max(max, array[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDigit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>        max /= <span class="hljs-number">10</span>;<br>        maxDigit++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, div = <span class="hljs-number">1</span>;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        bucketList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigit; i++, mod *= <span class="hljs-number">10</span>, div *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (array[j] % mod) / div;<br>            bucketList.get(num).add(array[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketList.size(); j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; bucketList.get(j).size(); k++)<br>                array[index++] = bucketList.get(j).get(k);<br>            bucketList.get(j).clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-3-算法分析"><a href="#11-3-算法分析" class="headerlink" title="11.3 算法分析"></a>11.3 算法分析</h2><p><strong>最佳情况：T(n) &#x3D; O(n * k)  最差情况：T(n) &#x3D; O(n * k)  平均情况：T(n) &#x3D; O(n * k)</strong></p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序 LSD 从低位开始进行排序 </p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h1><p><strong>稳定</strong>的排序：<strong>冒泡排序，插入排序，归并排序</strong><br><strong>不稳定</strong>的排序：<strong>选择排序，堆排序，快速排序，希尔排序</strong></p><p><strong>平均</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>希尔排序，归并排序，快速排序，堆排序</strong><br><strong>平均</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序</strong></p><p><strong>最好</strong>时间复杂度<code>T(n) = O(n)</code>：<strong>冒泡排序，插入排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，快速排序，堆排序</strong><br><strong>最好</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>简单选择排序</strong></p><p><strong>最坏</strong>时间复杂度<code>T(n) = O(nlogn)</code>：<strong>归并排序，堆排序</strong><br><strong>最坏</strong>时间复杂度<code>T(n) = O(n²)</code>：<strong>冒泡排序，简单选择排序，插入排序，快速排序</strong></p><p>空间复杂度<code>O(1)</code>：<strong>冒泡排序，简单选择排序，插入排序，希尔排序，堆排序</strong><br>空间复杂度<code>O(n)</code>：<strong>归并排序</strong><br>空间复杂度<code>O(nlogn)</code>：<strong>快速排序</strong></p><h1 id="13-参考资料"><a href="#13-参考资料" class="headerlink" title="13. 参考资料"></a>13. 参考资料</h1><ul><li><a href="https://segmentfault.com/a/1190000021638663">https://segmentfault.com/a/1190000021638663</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><blockquote><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/">https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/</a></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：两个栈"><a href="#题解：两个栈" class="headerlink" title="题解：两个栈"></a>题解：两个栈</h4><p>初始化两个栈<code>inStack</code>和<code>outStack</code>：</p><ul><li>入栈操作：直接丢进<code>inStack</code>中</li><li>出栈操作：如果<code>outStack</code>为空，则将<code>inStack</code>元素<code>pop</code>到<code>outStack</code>中，然后从<code>outStack</code>中出栈。如果<code>outStack</code>不为空，直接出栈。因为如果<code>outStack</code>不为空，则说明上一次队列元素还没有完全出栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出栈，出队使用</span><br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; outStack;<br><span class="hljs-comment">// 输入栈，当做进入队列使用</span><br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; inStack;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>    outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-comment">// 入队直接操作入栈即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    inStack.push(value);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出队时, 如果outStack为空，则把inStack里面元素pop出放入outStack中</span><br><span class="hljs-comment">     * 如果outStack不为空，则说明上一次队列元素还没有完全出栈</span><br><span class="hljs-comment">     * 如果inStack和outStack都为空，说明队内没有元素</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (inStack.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> outStack.pop();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><blockquote><p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MinStack minStack <span class="hljs-operator">=</span> new MinStack()<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>minStack.push(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -3.</span><br>minStack.pop()<span class="hljs-comment">;</span><br>minStack.top()<span class="hljs-comment">;      --&gt; 返回 0.</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -2.</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：两个栈-1"><a href="#题解：两个栈-1" class="headerlink" title="题解：两个栈"></a>题解：两个栈</h4><p>初始化两个栈：<code>minStack</code>最小值栈，<code>stack</code>存储栈</p><ul><li>入栈时：如果最小值栈为空或者新入栈元素小于等于最小值栈顶元素，则把新元素放入最小值栈<code>minStack</code>中</li><li>出栈时：如果<code>stack</code>出栈元素刚好是最小值元素，则需要把<code>minStack</code>中的元素也出栈，保证栈一致性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">// 正常元素栈</span><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack;<br><br>    <span class="hljs-comment">// 存放最小值的栈</span><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stack.push(x);<br>        <span class="hljs-comment">// 如果最小值栈为空或者新入栈的值x比最小值栈顶元素小，将x入站</span><br>        <span class="hljs-keyword">if</span> (minStack.isEmpty() || x &lt;= minStack.peek()) &#123;<br>            minStack.push(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-comment">// 如果出栈元素是最小值元素，则minStack也需要出栈删除该最小值</span><br>        <span class="hljs-keyword">if</span> (minStack.peek() == pop) &#123;<br>            minStack.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><blockquote><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：一个栈"><a href="#题解：一个栈" class="headerlink" title="题解：一个栈"></a>题解：一个栈</h4><p>遇到<code>(, &#123;, [</code>直接入栈，遇到<code>], &#125;, )</code>出栈一个元素，然后比较看是否匹配。</p><p>为了方便获取对应括号，初始化一个<code>map</code>存储括号的映射关系。</p><p>最后返回栈是否为空，因为如果括号都是匹配的，栈最后一定为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span> || ch == <span class="hljs-string">&#x27;[&#x27;</span> || ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>            stack.push(ch);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果执行到此处, stack是空, 则说明肯定是]&#125;)其中之一, 前面没有[&#123;(, 就不能匹配</span><br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span> (map.get(top) != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后避免只有[(&#123;的情况, 判断stack是否为空</span><br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h2><blockquote><p><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列大顶堆"><a href="#题解：优先队列大顶堆" class="headerlink" title="题解：优先队列大顶堆"></a>题解：优先队列大顶堆</h4><ul><li>创建一个大顶堆，用于获取滑动窗口最大值。</li><li>遍历元素，维护滑动窗口内的大顶堆状态。</li><li>大顶堆比较规则：<ul><li>如果数值相等比较下标，下标大的交换位置，因为下标小的元素可能不在本次窗口中，下标大的元素一定在本次窗口。</li><li>如果数值不等比较数值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 创建一个大顶堆，规则如下：</span><br>    <span class="hljs-comment">// 如果数值相等，则比较下标，下标大的交换位置</span><br>    <span class="hljs-comment">// 如果数值不等，则比较数值，数值大的交换位置</span><br>    <span class="hljs-comment">// int[0]表示数值，int[1]表示下标</span><br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">1</span>] : o2[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 先将前k个元素放入大顶堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i], i&#125;);<br>    &#125;<br>    <span class="hljs-comment">// 初始化返回数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 将第一个窗口k的最大值放入返回窗口</span><br>    res[<span class="hljs-number">0</span>] = priorityQueue.peek()[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 从第k个元素开始遍历，获取后面窗口最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 把新元素加入滑动窗口, 构造新的大顶堆</span><br>        <span class="hljs-comment">// 这里可能会遇到值相等但下标不同的元素，所以在初始化大顶堆时比较器要筛选下标大的那个元素</span><br>        <span class="hljs-comment">// 因为滑动窗口向后移，新加入元素下标肯定比之前大</span><br>        priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i], i&#125;);<br>        <span class="hljs-comment">// 先把大顶堆中下标小于等于i-k的清除，因为这部分元素不再滑动窗口内部</span><br>        <span class="hljs-keyword">while</span> (priorityQueue.peek()[<span class="hljs-number">1</span>] &lt;= i - k) &#123;<br>            priorityQueue.poll();<br>        &#125;<br>        <span class="hljs-comment">// 接下来大顶堆里面元素都是滑动窗口内部元素, 获取最大值即可</span><br>        res[i - k + <span class="hljs-number">1</span>] = priorityQueue.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h2><blockquote><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/</a></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[3,2,1]</span>, k = 2<br>输出：<span class="hljs-comment">[1,2]</span> 或者 <span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列小顶堆"><a href="#题解：优先队列小顶堆" class="headerlink" title="题解：优先队列小顶堆"></a>题解：优先队列小顶堆</h4><p>遍历元素放入小顶堆中，然后去前k个元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 默认创建小顶堆</span><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        pq.offer(arr[i]);<br>    &#125;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        res[i] = pq.poll();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-076-数组中的第-k-大的数字"><a href="#剑指-Offer-II-076-数组中的第-k-大的数字" class="headerlink" title="剑指 Offer II 076. 数组中的第 k 大的数字"></a>剑指 Offer II 076. 数组中的第 k 大的数字</h2><blockquote><p><a href="https://leetcode.cn/problems/xx4gT2/">https://leetcode.cn/problems/xx4gT2/</a></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列大顶堆-1"><a href="#题解：优先队列大顶堆-1" class="headerlink" title="题解：优先队列大顶堆"></a>题解：优先队列大顶堆</h4><p>将元素放入优先队列中，先<code>poll</code>出前<code>k-1</code>个元素，然后下一个元素就是第<code>k</code>大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// 建立大顶堆</span><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; (o2 - o1));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        pq.offer(num);<br>    &#125;<br>    <span class="hljs-comment">// 把前k大剔除</span><br>    <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">1</span>) &#123;<br>        pq.poll();<br>    &#125;<br>    <span class="hljs-comment">// 返回第k大</span><br>    <span class="hljs-keyword">return</span> pq.poll();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a>剑指 Offer 41. 数据流中的中位数</h2><blockquote><p><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,null,<span class="hljs-number">1.50000</span>,null,<span class="hljs-number">2.00000</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：优先队列大顶堆-小顶堆"><a href="#题解：优先队列大顶堆-小顶堆" class="headerlink" title="题解：优先队列大顶堆+小顶堆"></a>题解：优先队列大顶堆+小顶堆</h4><ul><li>创建一个大顶堆，一个小顶堆</li><li>大顶堆负责存储排序后列表的前半部分值，因为这样能直接获取前半部分最大值。</li><li>小顶堆负责存储排序后列表的后半部分值，因为这样能直接获取后半部分最小值。</li><li>添加元素时保证大顶堆元素个数和小顶堆元素个数相差不超过1。这样如果列表元素个数是奇数，则直接获取小顶堆最小值就是中位数；如果是偶数，则大小顶堆最值平均。</li><li>添加元素时要先添加到大顶堆中，然后大顶堆<code>poll</code>出的元素再添加到小顶堆中。这样保证小顶堆一定是有序列表后半部分元素，大顶堆一定是有序列表前半部分元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    PriorityQueue&lt;Integer&gt; small;<br>    PriorityQueue&lt;Integer&gt; big;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 将排序后的数据流分为两部分</span><br>        <span class="hljs-comment">// 小顶堆存储排序后大的那部分值, 这样小顶堆能直接获取大的那部分最小值</span><br>        <span class="hljs-comment">// 大顶堆存储排序后小的那部分值, 这样大顶堆能直接获取小的那部分最大值</span><br>        small = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        big = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; (o2 - o1));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        big.offer(num);<br>        small.offer(big.poll());<br>        <span class="hljs-keyword">if</span> (big.size() + <span class="hljs-number">1</span> &lt; small.size()) &#123;<br>            <span class="hljs-comment">// 如果大顶堆元素比小顶堆的少两个，则把小顶堆元素poll出来一个放入大顶堆</span><br>            <span class="hljs-comment">// 永远保证大顶堆和小顶堆元素最接近中位数</span><br>            big.offer(small.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 说明是奇数</span><br>        <span class="hljs-keyword">if</span> (small.size() &gt; big.size()) <span class="hljs-keyword">return</span> small.peek();<br>        <span class="hljs-comment">// 偶数直接去平均值</span><br>        <span class="hljs-keyword">return</span> (small.peek() + big.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-036-后缀表达式"><a href="#剑指-Offer-II-036-后缀表达式" class="headerlink" title="剑指 Offer II 036. 后缀表达式"></a>剑指 Offer II 036. 后缀表达式</h2><blockquote><p><a href="https://leetcode.cn/problems/8Zf90G/">https://leetcode.cn/problems/8Zf90G/</a></p><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求该后缀表达式的计算结果。</p><p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>]<br>输出：<span class="hljs-number">9</span><br>解释：该算式转化为常见的中缀算术表达式为：((<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：栈"><a href="#题解：栈" class="headerlink" title="题解：栈"></a>题解：栈</h4><ul><li>遇到数值则入栈</li><li>遇到操作数则出栈两个数值，然后根据操作数计算，结果再入栈</li><li>出栈两个元素后计算时注意顺序，对于<code>+和/</code>来说，后出栈在前</li><li>最后返回栈最后一个值即结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>    <span class="hljs-comment">// 数字入栈</span><br>    Stack&lt;Integer&gt; val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String str : tokens) &#123;<br>        <span class="hljs-comment">// 如果是数字则直接入栈</span><br>        <span class="hljs-keyword">if</span> (isNumber(str)) &#123;<br>            val.push(Integer.parseInt(str));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 遇到操作数则出栈两个元素</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> val.pop();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> val.pop();<br>            <span class="hljs-comment">// 记录结果值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 注意计算对于/和-来说是v2在前，v1在后，因为v2先入栈</span><br>            <span class="hljs-keyword">switch</span> (str) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                    res = v2 + v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                    res = v2 - v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                    res = v2 * v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                    res = v2 / v1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br>            val.push(res);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val.pop();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈、队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-红黑树的性质"><a href="#1-红黑树的性质" class="headerlink" title="1. 红黑树的性质"></a>1. 红黑树的性质</h1><ul><li>性质1：每个节点要么是黑色，要么是红色</li><li>性质2：根节点是黑色</li><li>性质3：每个叶子节点（NIL）是黑色</li><li>性质4：每个红色节点的两个子节点一定都是黑色</li><li>性质5：<strong>任意一个节点到每个叶子节点的路径都包含相同数量的黑色节点</strong></li></ul><p>从性质5又可以推出：</p><ul><li>性质5.1：如果一个节点存在黑色子节点，那么该节点一定有两个子节点</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109210.png" alt="image-20210405215250763"></p><h1 id="2-红黑树的自平衡"><a href="#2-红黑树的自平衡" class="headerlink" title="2. 红黑树的自平衡"></a>2. 红黑树的自平衡</h1><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其<strong>右子结点</strong>变为旋转结点的父结点，<strong>右子结点的左子结点</strong>变为旋转结点的<strong>右子结点</strong>，<strong>左子结点</strong>保持不变。如图3：</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109762.png" alt="image-20210405215348761"></p><ul><li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其<strong>左子结点</strong>变为旋转结点的父结点，<strong>左子结点的右子结点</strong>变为旋转结点的<strong>左子结点</strong>，<strong>右子结点</strong>保持不变。如图4。</li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109185.png" alt="image-20210405215541157"></p><ul><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul><p><strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。</p><p><strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><h1 id="3-红黑树的查找"><a href="#3-红黑树的查找" class="headerlink" title="3. 红黑树的查找"></a>3. 红黑树的查找</h1><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li><p>从根结点开始查找，把根结点设置为当前结点；</p></li><li><p>若当前结点为空，返回null；</p></li><li><p>若当前结点不为空，用当前结点的key跟查找key作比较；</p></li><li><p>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</p></li><li><p>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</p></li><li><p>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</p></li></ol><h1 id="4-红黑树的插入"><a href="#4-红黑树的插入" class="headerlink" title="4. 红黑树的插入"></a>4. 红黑树的插入</h1><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109815.png" alt="image-20210405221428584"></p><h2 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h2><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。</p><p><strong>处理：把插入结点作为根结点，并把结点设置为黑色</strong>。</p><h2 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h2><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p><strong>处理：</strong></p><ul><li><strong>把I设为当前结点的颜色</strong></li><li><strong>更新当前结点的值为插入结点的值</strong></li></ul><h2 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h2><p>由于插入的结点是红色的，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p><strong>处理：直接插入</strong>。</p><h2 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h2><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。</p><p><strong>插入情景4.1：叔叔结点存在并且为红结点</strong><br> 从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图9和图10所示。</p><p><strong>处理：</strong></p><ul><li><strong>将P和S设置为黑色</strong></li><li><strong>将PP设置为红色</strong></li><li><strong>把PP设置为当前插入结点</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109201.png" alt="image-20210405221635975"></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109762.png" alt="image-20210405221646435"></p><p>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><p>我们还可以总结出另外一个经验：<strong>红黑树的生长是自底向上的</strong>。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</p><p><strong>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</strong><br> 单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><p><strong>插入情景4.2.1：插入结点是其父结点的左子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行右旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109246.png" alt="image-20210405221717510"></p><p>由图11可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。</p><p>咦，可以把P设为红色，I和PP设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把P设为红色，I和PP设为黑色。但把P设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</p><p><strong>插入情景4.2.2：插入结点是其父结点的右子结点</strong><br> 这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。</p><p><strong>处理：</strong></p><ul><li><strong>对P进行左旋</strong></li><li><strong>把P设置为插入结点，得到情景4.2.1</strong></li><li><strong>进行情景4.2.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092109857.png" alt="image-20210405221738803"></p><p><strong>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</strong><br> 该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><p><strong>插入情景4.3.1：插入结点是其父结点的右子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行左旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110655.png" alt="image-20210405221924516"></p><p><strong>插入情景4.3.2：插入结点是其父结点的左子结点</strong><br><strong>处理：</strong></p><ul><li><strong>对P进行右旋</strong></li><li><strong>把P设置为插入结点，得到情景4.3.1</strong></li><li><strong>进行情景4.3.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110359.png" alt="image-20210405222000297"></p><h1 id="5-红黑树的删除"><a href="#5-红黑树的删除" class="headerlink" title="5. 红黑树的删除"></a>5. 红黑树的删除</h1><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。</p><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong>。如图16所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110521.png" alt="image-20210405222107739"></p><p>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong>话很苍白，我们看图17。在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110880.png" alt="image-20210405222125858"></p><p>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图18所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110062.png" alt="image-20210405222153108"></p><p>综上所述，<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</strong>有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如图19所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110464.png" alt="image-20210405222242793"></p><p>即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。同样的，我们还是来约定下，如图20所示。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110087.png" alt="image-20210405222307463"></p><p>图20的字母并不代表结点Key的大小。R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。</p><p>值得特别提醒的是，<strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</strong></p><p>万事具备，我们进入最后的也是最难的讲解。</p><h2 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h2><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p><strong>处理：颜色变为删除结点的颜色</strong></p><h2 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h2><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><p><strong>删除情景2.1：替换结点是其父结点的左子结点</strong><br> <strong>删除情景2.1.1：替换结点的兄弟结点是红结点</strong><br> 若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行左旋，得到情景2.1.2.3</strong></li><li><strong>进行情景2.1.2.3的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110730.png" alt="image-20210405222346902"></p><p><strong>删除情景2.1.2：替换结点的兄弟结点是黑结点</strong><br> 当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。</p><p><strong>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</strong><br> 即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如图22所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对P进行左旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110873.png" alt="image-20210405222406585"></p><p>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。</p><p><strong>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</strong><br> 兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。图如23所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对S进行右旋，得到情景2.1.2.1</strong></li><li><strong>进行情景2.1.2.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110170.png" alt="image-20210405222429123"></p><p><strong>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br> 好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110391.png" alt="image-20210405222449127"></p><p><strong>删除情景2.2：替换结点是其父结点的右子结点</strong><br> 好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。</p><p><strong>删除情景2.2.1：替换结点的兄弟结点是红结点</strong><br> 处理：</p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行右旋，得到情景2.2.2.3</strong></li><li><strong>进行情景2.2.2.3的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110512.png" alt="image-20210405222508495"></p><p><strong>删除情景2.2.2：替换结点的兄弟结点是黑结点</strong><br> <strong>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</strong><br> <strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对P进行右旋</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110727.png" alt="image-20210405222534331"></p><p><strong>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对S进行左旋，得到情景2.2.2.1</strong></li><li><strong>进行情景2.2.2.1的处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110898.png" alt="image-20210405222551805"></p><p><strong>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110196.png" alt="image-20210405222621855"></p><p>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><h1 id="资料来自"><a href="#资料来自" class="headerlink" title="资料来自"></a>资料来自</h1><ul><li><a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归回溯专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-083-没有重复元素集合的全排列"><a href="#剑指-Offer-II-083-没有重复元素集合的全排列" class="headerlink" title="剑指 Offer II 083. 没有重复元素集合的全排列"></a>剑指 Offer II 083. 没有重复元素集合的全排列</h2><blockquote><p><a href="https://leetcode.cn/problems/VvJkup/description/">https://leetcode.cn/problems/VvJkup/description/</a></p><p>给定一个不含重复数字的整数数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：回溯"><a href="#题解：回溯" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p><strong>可以将此问题看作有<code>n</code>个排列成一行的空格，需要从左往右依次填入题目给定的<code>n</code>个数，每个数只能用一次。</strong></p><p>定义递归函数<code>backTrack(res, tmp n, first)</code>表示从左往右填到第<code>first</code>个位置，当前排列为<code>tmp</code>，递归分下面两种情况：</p><ul><li>如果<code>first==n</code>说明已经填完了<code>n</code>个位置（下标从0开始），找到一个可行的解，将<code>tmp</code>放入答案中。</li><li>如果<code>first &lt; n</code>，需要考虑第<code>first</code>个位置需要填哪个数。题目要求不能填重复的数，所以需要把填过的数和未填过的数区分开。</li></ul><p>如何区分填过的数和未填过的数？</p><p>假设已经填到第<code>first</code>个位置，则<code>nums</code>数组中<code>[0, first-1]</code>是已经填过的数的集合，<code>[first, n-1]</code>是待填的数的集合。所以肯定用<code>[first, n-1]</code>里面的数去填第<code>first</code>个数。假设待填的数下标为<code>i</code>，填完后将第<code>i</code>个数和第<code>first</code>个数交换，即能使得在填第 <code>first+1</code>个数的时候 <code>nums</code>数组的<code>[0,first]</code> 部分为已填过的数，<code>[first+1,n−1]</code> 为待填的数，回溯的时候交换回来即能完成撤销操作。</p><p>举个简单的例子，假设我们有<code>[2,5,8,9,10]</code> 这 5 个数要填入，已经填到第 3个位置，已经填了 <code>[8,9]</code> 两个数，那么这个数组目前为 <code>[8,9 ∣ 2,5,10]</code> 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填<code>[8,9,10 ∣ 2,5]</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        tmp.add(num);<br>    &#125;<br>    backTrack(res, tmp, nums.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> first)</span> &#123;<br>    <span class="hljs-keyword">if</span> (first == n) &#123;<br>        <span class="hljs-comment">// 这里需要拷贝一份，否则后面修改会改变tmp数组的值</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> first; i &lt;= n; i++) &#123;<br>            Collections.swap(tmp, first, i);<br>            backTrack(res, tmp, n, first + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 这里需要还原现场，否则first位只交换一次</span><br>            Collections.swap(tmp, first, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-084-含有重复元素集合的全排列"><a href="#剑指-Offer-II-084-含有重复元素集合的全排列" class="headerlink" title="剑指 Offer II 084. 含有重复元素集合的全排列"></a>剑指 Offer II 084. 含有重复元素集合的全排列</h2><blockquote><p><a href="https://leetcode.cn/problems/7p8L0Z/">https://leetcode.cn/problems/7p8L0Z/</a></p><p>给定一个可包含重复数字的整数集合 <code>nums</code> ，<strong>按任意顺序</strong> 返回它所有不重复的全排列。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：回溯-1"><a href="#题解：回溯-1" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p>定义递归函数 <code>backtrack(idx,perm)</code>表示当前排列为 <code>perm</code>，下一个待填入的位置是第 <code>idx</code>个位置（下标从 0 开始）。那么整个递归函数分为两个情况：</p><ul><li>如果<code>idx == n</code>，说明已经填完第<code>n</code>个位置，找到一个可行的解。</li><li>如果<code>idx &lt; n</code>，需要考虑第<code>idx</code>填哪一个数，题目要求不能填已经填过的数，所以需要一个标记数组<code>visited</code>标记已经填过的数。在填第<code>idx</code>个数的时候遍历题目给的<code>n</code>个数，如果没有被标记则填入，然后继续尝试下一个位置，即<code>backTrack(perm, idx + 1)</code>。回溯时要撤销该位置填的数和标记。</li><li>为了解决重复填值的问题，设定一个规则：保证在填第<code>idx</code>个数的时候重复数字只填入一次。对原数组进行排序，保证相同数字相邻，然后每次填入的数一定是从左往右第一个未被填过的数字。即<code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 先把数组排序，这样在回溯中可以防止重复元素</span><br>    Arrays.sort(nums);<br>    <span class="hljs-comment">// 递归过程中标记该位置元素是否已经使用过</span><br>    <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>    <span class="hljs-comment">// idx：当前填充的元素位置</span><br>    backTrack(nums, res, tmp, visited, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-comment">// 此时说明得到一个结果</span><br>    <span class="hljs-keyword">if</span> (idx == nums.length) &#123;<br>        <span class="hljs-comment">// 拷贝一份是因为tmp在递归过程中可能会变</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 如果i位置元素已经被访问到 或者 nums[i] == nums[i - 1]并且前一个数未被访问 直接跳过</span><br>            <span class="hljs-comment">// 第二个条件：保证每次填入的数是从左到右第一个未被填入的数字</span><br>            <span class="hljs-keyword">if</span> (visited[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 将通过条件的元素添加</span><br>            tmp.add(nums[i]);<br>            <span class="hljs-comment">// 标记已访问</span><br>            visited[i] = <span class="hljs-literal">true</span>;<br>            backTrack(nums, res, tmp, visited, idx + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 回溯嘛，，需要还原现场，比如获取到一个数组[1,2,3], 还有[1,3,2]，这个2后面可能再用</span><br>            visited[i] = <span class="hljs-literal">false</span>;<br>            tmp.remove(idx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><blockquote><p><a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：网格回溯模板"><a href="#题解：网格回溯模板" class="headerlink" title="题解：网格回溯模板"></a>题解：网格回溯模板</h4><blockquote><p>参考答案：<a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</a></p></blockquote><p>主要思路：在递归过程中对每次递归走到的点位赋值，最后统计有多少个岛屿点位即可。例如：每次递归都将能走过的点位置2，这样每次退出递归时该次递归寻找的岛屿都是2（同时原来矩阵中数值也变成2），所以最后只需要统计原来矩阵有多少个1开始遍历的次数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-comment">// 从陆地开始递归，</span><br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                dfs(grid, i, j);<br>                <span class="hljs-comment">// 因为在递归过程中已经访问过的点标记为2，所以每次递归都会把岛屿的点都变成2，这里使用统计剩下1的数量即可</span><br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">// 网格递归遍历基本模板</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-comment">// 如果超出网格边界，直接返回</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不是陆地, 结束递归</span><br>    <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将递归后的陆地标记一下，不然会循环递归</span><br>    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    dfs(grid, i - <span class="hljs-number">1</span>, j);<br>    dfs(grid, i + <span class="hljs-number">1</span>, j);<br>    dfs(grid, i, j - <span class="hljs-number">1</span>);<br>    dfs(grid, i, j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h2><blockquote><p><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解-回溯"><a href="#题解-回溯" class="headerlink" title="题解: 回溯"></a>题解: 回溯</h4><blockquote><p>题解一样：剑指 Offer II 084. 含有重复元素集合的全排列 <a href="https://leetcode.cn/problems/7p8L0Z/">https://leetcode.cn/problems/7p8L0Z/</a></p></blockquote><p>只是将数字换成了字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()];<br>    <span class="hljs-comment">// 将字符串转为数组，这样就和整数数组全排列一致</span><br>    <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-comment">// 排序是为了后面去重</span><br>    Arrays.sort(chars);<br>    backTrack(res, visited, sb, chars, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;&#125;);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(List&lt;String&gt; res, <span class="hljs-type">boolean</span>[] visited, StringBuilder sb, <span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-comment">// 填充元素的下标满足个数后，获取当前结果</span><br>    <span class="hljs-keyword">if</span> (idx == chars.length) &#123;<br>        <span class="hljs-comment">// 这里sb.toString()里面已经拷贝了一份</span><br>        res.add(sb.toString());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-comment">// 如果i位置元素已经被访问到 或者 chars[i] == chars[i - 1]并且前一个数未被访问 直接跳过</span><br>            <span class="hljs-comment">// 第二个条件：保证每次填入的数是从左到右第一个未被填入的字符</span><br>            <span class="hljs-keyword">if</span> (visited[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; chars[i] == chars[i - <span class="hljs-number">1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 标记已经被访问</span><br>            visited[i] = <span class="hljs-literal">true</span>;<br>            sb.append(chars[i]);<br>            backTrack(res, visited, sb, chars, idx + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 回溯嘛，，需要还原现场，比如获取到一个数组[1,2,3], 还有[1,3,2]，这个2后面可能再用</span><br>            sb.deleteCharAt(idx);<br>            visited[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><blockquote><p><a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：回溯-2"><a href="#题解：回溯-2" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p>只在序列有效时才添加<code>(</code>或<code>)</code>：</p><ul><li>如果左括号数量不大于<code>n</code>，则添加一个左括号。</li><li>如果右括号数量小于左括号数量，可以添加一个右括号。</li><li>在每次添加完递归出来需要删除进行回溯。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dfs(res, n, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;String&gt; res, <span class="hljs-type">int</span> n, StringBuilder sb, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sb.length() == <span class="hljs-number">2</span> * n) &#123;<br>        res.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先添加左括号</span><br>    <span class="hljs-keyword">if</span> (open &lt; n) &#123;<br>        sb.append(<span class="hljs-string">&quot;(&quot;</span>);<br>        dfs(res, n, sb, open + <span class="hljs-number">1</span>, close);<br>        <span class="hljs-comment">// 删除完右括号后, 会退出到这里, 删除一个左括号</span><br>        <span class="hljs-comment">// 然后又进入dfs递归, 这时close &lt; open, 就会添加), 即(()</span><br>        sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 左括号满后, 添加对应数量的右括号</span><br>    <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>        sb.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        dfs(res, n, sb, open, close + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 右括号满后, 会从这里开始出栈, 逐步删除右括号</span><br>        sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-112-最长递增路径"><a href="#剑指-Offer-II-112-最长递增路径" class="headerlink" title="剑指 Offer II 112. 最长递增路径"></a>剑指 Offer II 112. 最长递增路径</h2><blockquote><p><a href="https://leetcode.cn/problems/fpTFWP/description/">https://leetcode.cn/problems/fpTFWP/description/</a></p><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092108737.png" alt="image-20230528200917267"></p></blockquote><h4 id="题解：回溯-3"><a href="#题解：回溯-3" class="headerlink" title="题解：回溯"></a>题解：回溯</h4><p>使用记忆化深度优先搜索，当访问到一个单元格 <code>(i,j)</code> 时，如果<code>memo[i][j] !=0 </code>，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果<code> memo[i][j] ==0</code>，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</p><ul><li><code>memo[i][j]</code>存储当前点位最大路径值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 四个方向</span><br>    &#123;% raw %&#125;<span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;&#123;% endraw %&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rows, cols;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        rows = matrix.length;<br>        cols = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 记忆矩阵: 记录遍历当前点位时最大路径</span><br>        <span class="hljs-type">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rows][cols];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-comment">// 遍历每个矩阵点位</span><br>                ans = Math.max(ans, dfs(matrix, i, j, memo));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] memo)</span> &#123;<br>        <span class="hljs-comment">// 如果当前点位已经遍历过，返回当前点位时路径长度</span><br>        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i][j];<br>        &#125;<br>        <span class="hljs-comment">// 遍历到当前定位, 则路径+1</span><br>        <span class="hljs-comment">// 这里先把当前这个点路长度算出来，最短就只包含当前点长度1，下面那个dfs中的+1不一定能走的到，不满足递增的话就不走那里了，这样当前点局部最长路径长度依旧要赋值为1</span><br>        memo[i][j]++;<br>        <span class="hljs-comment">// 遍历四个方向</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newI</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newJ = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 1. 判断是否越界</span><br>            <span class="hljs-comment">// 2. 判断下一步遍历的点位值是否比当前值大(贪心)</span><br>            <span class="hljs-keyword">if</span> (newI &gt;= <span class="hljs-number">0</span> &amp;&amp; newI &lt; rows &amp;&amp; newJ &gt;= <span class="hljs-number">0</span> &amp;&amp; newJ &lt; cols &amp;&amp; matrix[newI][newJ] &gt; matrix[i][j]) &#123;<br>                <span class="hljs-comment">// 每次递归路径值+1, 最后获取最大值</span><br>                memo[i][j] = Math.max(memo[i][j], dfs(matrix, newI, newJ, memo) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][j];<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-079-所有子集"><a href="#剑指-Offer-II-079-所有子集" class="headerlink" title="剑指 Offer II 079. 所有子集"></a>剑指 Offer II 079. 所有子集</h2><blockquote><p><a href="https://leetcode.cn/problems/TVdhkn/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/TVdhkn/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：二进制序列"><a href="#题解：二进制序列" class="headerlink" title="题解：二进制序列"></a>题解：二进制序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 初始化2^len个序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; len; i++) &#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 针对每个序列都是一种结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-comment">// 如果该序位置是1，则添加到子集中</span><br>            <span class="hljs-comment">// 例如len=3，</span><br>            <span class="hljs-comment">// 1 &lt;&lt; 0 -&gt; 1</span><br>            <span class="hljs-comment">// 1 &lt;&lt; 1 -&gt; 10</span><br>            <span class="hljs-comment">// 1 &lt;&lt; 2 -&gt; 100</span><br>            <span class="hljs-comment">// 用(1 &lt;&lt; j)和i相与就可以得到序列中哪些位置是1了</span><br>            <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span> )&#123;<br>                tmp.add(nums[j]);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解：dfs递归"><a href="#题解：dfs递归" class="headerlink" title="题解：dfs递归"></a>题解：dfs递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dfs(nums, <span class="hljs-number">0</span>, tmp);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求子集模版一</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, List&lt;Integer&gt; tmp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 选第index个元素</span><br>    tmp.add(nums[index]);<br>    dfs(nums, index + <span class="hljs-number">1</span>, tmp);<br>    <span class="hljs-comment">// 恢复现场</span><br>    tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>    dfs(nums, index + <span class="hljs-number">1</span>, tmp);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求子集模板二</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, List&lt;Integer&gt; tmp)</span> &#123;<br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>    <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>        tmp.add(nums[i]);<br>        dfs(nums, i + <span class="hljs-number">1</span>, tmp);<br>        tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-080-含有-k-个元素的组合"><a href="#剑指-Offer-II-080-含有-k-个元素的组合" class="headerlink" title="剑指 Offer II 080. 含有 k 个元素的组合"></a>剑指 Offer II 080. 含有 k 个元素的组合</h2><blockquote><p><a href="https://leetcode.cn/problems/uUsW3B/description/?envType=study-plan-v2&envId=coding-interviews-special">https://leetcode.cn/problems/uUsW3B/description/?envType=study-plan-v2&amp;envId=coding-interviews-special</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: n = 4, k = 2<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：dfs递归-1"><a href="#题解：dfs递归-1" class="headerlink" title="题解：dfs递归"></a>题解：dfs递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    dfs(<span class="hljs-number">1</span>, k, n);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 递归结束条件：当前tmp元素个数=k</span><br>    <span class="hljs-keyword">if</span> (tmp.size() == k) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 什么情况下递归？当i&lt;=n时</span><br>    <span class="hljs-keyword">if</span> (i &lt;= n) &#123;<br>        <span class="hljs-comment">// 选择i</span><br>        tmp.add(i);<br>        <span class="hljs-comment">// 继续递归</span><br>        dfs(i + <span class="hljs-number">1</span>, k, n);<br>        <span class="hljs-comment">// 为什么要回溯？当选了[1,2]时，还有[1,3]等需要选，所以需要把3回退</span><br>        tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>        dfs(i + <span class="hljs-number">1</span>, k, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表专题</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><blockquote><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110833.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span><br>输出：<span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：穿针引线"><a href="#题解：穿针引线" class="headerlink" title="题解：穿针引线"></a>题解：穿针引线</h4><p>思路很简单，分两步：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110158.png" alt="image-20230328124651700" style="zoom:50%;" /><ol><li>先将区间部分链表反转</li><li>把<code>pre.next</code>的<code>next</code>指向反转以后的链表头结点，把反转以后的链表尾结点 <code>next</code>指针指向<code>succ</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">header</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        header.next = head;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> header;<br>        <span class="hljs-comment">// 寻找到left的前一个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>            rightNode = rightNode.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记录区间左节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-comment">// 记录区间右节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tailNode</span> <span class="hljs-operator">=</span> rightNode.next;<br>        <span class="hljs-comment">// 切断链表关系</span><br>        pre.next = <span class="hljs-literal">null</span>;<br>        rightNode.next = <span class="hljs-literal">null</span>;<br>        <br>        reverseLink(leftNode);<br>        <br>        <span class="hljs-comment">// 经过反转后, rightNode变成了头结点</span><br>        pre.next = rightNode;<br>        <span class="hljs-comment">// 尾结点变成了头结点</span><br>        leftNode.next = tailNode;<br>        <span class="hljs-keyword">return</span> header.next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseLink</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 先将下一个节点保存</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-comment">// 当前节点的next指向尾结点</span><br>            cur.next = pre;<br>            <span class="hljs-comment">// pre指向当前节点, 作为尾结点</span><br>            pre = cur;<br>            <span class="hljs-comment">// 当前指针后移一个节点</span><br>            cur = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><blockquote><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110295.png" alt="image-20230328210057463" style="zoom:50%;" /><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092110585.png" alt="image-20230328210121946" style="zoom:50%;" /><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：寻找区间后反转区间链表"><a href="#题解：寻找区间后反转区间链表" class="headerlink" title="题解：寻找区间后反转区间链表"></a>题解：寻找区间后反转区间链表</h4><p><strong>思路</strong>：</p><ul><li>初始需要两个变量<code>pre</code>和<code>end</code>：<code>pre</code>记录每次需要反转链表的前一个节点，<code>end</code>记录每次反转链表的尾结点。</li><li>每次寻找k个节点，<code>end</code>指向每次反转链表的尾结点。如果<code>end</code>为<code>null</code>，说明不足k个。</li><li><code>next</code>指向<code>end.next</code>：目的是为了反转后将链表接回到原链表。</li><li><code>end.next = null</code>：每次反转前要断开与原链表的联系。</li><li><code>start</code>指向反转链表头结点：目的是为了反转链表和将反转链表链接回原链表。</li><li>一次反转后，连接反转链表注意：原来的<code>next</code>变成了头结点；原来的<code>start</code>变成了尾结点。</li><li>一次反转后，<code>pre</code>和<code>end</code>指向<code>start</code>，即下一次反转链表的前一个节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 构建一个假节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <br>        <span class="hljs-comment">// 指向每次要反转链表的头结点的上一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-comment">// 指向每次要反转链表的尾结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (end.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 循环k次, 找到需要反转的链表的结尾, 需要判断end是否为空, 不然end.next会报错</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k &amp;&amp; end != <span class="hljs-literal">null</span>; i++) &#123;<br>                end = end.next;<br>            &#125;<br>            <span class="hljs-comment">// end为null则说明反转的链表的节点数小于k, 不执行反转</span><br>            <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 记录需要反转的链表的下一个节点</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> end.next;<br>            <span class="hljs-comment">// 断开要反转的链表</span><br>            end.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 记录要反转的链表的头结点</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pre.next;<br>            <span class="hljs-comment">// 反转链表, pre.next指向反转后的链表</span><br>            pre.next = reverse(start);<br>            <span class="hljs-comment">// 反转后, 原来的链表头结点变成了尾结点, 需要链接到之前的next</span><br>            start.next = next;<br>            <span class="hljs-comment">// pre和end指向下一次要反转链表的前一个节点</span><br>            pre = start;<br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 要求背诵</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h2><blockquote><p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/">https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/</a></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：归并排序思路"><a href="#题解：归并排序思路" class="headerlink" title="题解：归并排序思路"></a>题解：归并排序思路</h4><p>设置一个虚拟头结点，遍历比较两个链表，最后记得将剩余链表直接添加上去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> l1, cur2 = l2, cur = dummy;<br>        <span class="hljs-keyword">while</span> (cur1 != <span class="hljs-literal">null</span> &amp;&amp; cur2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur1.val &lt; cur2.val) &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur1.val);<br>                cur1 = cur1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur2.val);<br>                cur2 = cur2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (cur1 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = cur1;<br>            cur1 = cur1.next;<br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (cur2 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = cur2;<br>            cur2 = cur2.next;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-078-合并排序链表"><a href="#剑指-Offer-II-078-合并排序链表" class="headerlink" title="剑指 Offer II 078. 合并排序链表"></a>剑指 Offer II 078. 合并排序链表</h2><blockquote><p><a href="https://leetcode.cn/problems/vvXgSW/description/">https://leetcode.cn/problems/vvXgSW/description/</a></p><p>给定一个链表数组，每个链表都已经按升序排列。</p><p>请将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解一：遍历-两个有序链表合并"><a href="#题解一：遍历-两个有序链表合并" class="headerlink" title="题解一：遍历+两个有序链表合并"></a>题解一：遍历+两个有序链表合并</h4><ul><li>已经有两个有序链表合并的算法，所以直接遍历这个链表数组进行合并即可。</li><li>初始化一个空链表，让它与第一个链表合并。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个空链表，用来和第一个链表合并</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (ListNode list : lists) &#123;<br>            <span class="hljs-comment">// 用每次合并后的链表去和下一个链表合并</span><br>            ans = mergTwoList(ans, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个有序链表</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergTwoList</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a == <span class="hljs-literal">null</span> ? b : a;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (a.val &lt; b.val) &#123;<br>                head.next = a;<br>                a = a.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head.next = b;<br>                b = b.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-comment">// 注意这里处理，直接将剩余链表连接即可</span><br>        head.next = a == <span class="hljs-literal">null</span> ? b : a;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：归并"><a href="#题解二：归并" class="headerlink" title="题解二：归并"></a>题解二：归并</h4><ul><li>既然每个数组都是有序，那自然可以想到归并的思路来解。</li><li>归并排序到最后也是合并两个链表，所以核心算法还是合并两个有序链表（已有）</li><li>分而治之：考虑将k个链表配对，每两个合并，这就使用到递归分治。</li><li>递归退出的条件：参考归并排序<ul><li>当<code>left &lt; right</code>：继续递归。</li><li>当<code>left &gt; right</code>：范围不对，直接返回<code>null</code>。</li><li>当<code>left == right</code>： 说明两个链表一样，此时直接返回任意一个即可。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> mergeSort(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(ListNode[] list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// 边界出错，直接返回null</span><br>        <span class="hljs-keyword">if</span> (i &gt; j) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 两个链表一样，此时直接返回任意一个即可</span><br>        <span class="hljs-keyword">if</span> (i == j) &#123;<br>            <span class="hljs-keyword">return</span> list[i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> mergeSort(list, i, mid);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> mergeSort(list, mid + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-comment">// 两两合并</span><br>        <span class="hljs-keyword">return</span> mergeTwoList(l1, l2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoList</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a == <span class="hljs-literal">null</span> ? b : a;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (a.val &lt; b.val) &#123;<br>                head.next = a;<br>                a = a.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head.next = b;<br>                b = b.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        head.next = a == <span class="hljs-literal">null</span> ? b : a;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-022-链表中环的入口节点"><a href="#剑指-Offer-II-022-链表中环的入口节点" class="headerlink" title="剑指 Offer II 022. 链表中环的入口节点"></a>剑指 Offer II 022. 链表中环的入口节点</h2><blockquote><p><a href="https://leetcode.cn/problems/c32eOV/description/">https://leetcode.cn/problems/c32eOV/description/</a></p><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111315.png" alt="image-20230406224639579"></p></blockquote><h4 id="题解：快慢指针"><a href="#题解：快慢指针" class="headerlink" title="题解：快慢指针"></a>题解：快慢指针</h4><p>快慢指针找到相遇位置并且同时能够判断是否有环。</p><p><strong>关键点</strong>： 在相等节点处, 相遇指针继续向下走的距离就等于起始指针走到环入口的距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 定义一个快慢指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = head;<br>        <span class="hljs-comment">// 遇到节点为空说明没有环</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 快指针每次走两步</span><br>            fast = fast.next.next;<br>            <span class="hljs-comment">// 慢指针每次走一步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// 如果两个指针相等，说明有环</span><br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                <span class="hljs-comment">// 在相等节点处, 相遇指针继续向下走的距离就等于起始指针走到环入口的距离</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-keyword">while</span> (res != slow) &#123;<br>                    res = res.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><blockquote><p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/</a></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：遍历"><a href="#题解：遍历" class="headerlink" title="题解：遍历"></a>题解：遍历</h4><p>先求链表长度，然后再计算走到k需要几步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 先求链表长度, 这里是0，因为结束条件是cur!=null, 会多遍历一次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            len++;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-comment">// 计算从头到k需要走几步: len - k</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len - k; i++) &#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-021-删除链表的倒数第-n-个结点"><a href="#剑指-Offer-II-021-删除链表的倒数第-n-个结点" class="headerlink" title="剑指 Offer II 021. 删除链表的倒数第 n 个结点"></a>剑指 Offer II 021. 删除链表的倒数第 n 个结点</h2><blockquote><p><a href="https://leetcode.cn/problems/SLwz0R/description/">https://leetcode.cn/problems/SLwz0R/description/</a></p><p>给定一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,4,5]</span>, n = 2<br>输出：<span class="hljs-comment">[1,2,3,5]</span><br><br>输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br><br>输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：寻找待删除节点的前一个节点"><a href="#题解：寻找待删除节点的前一个节点" class="headerlink" title="题解：寻找待删除节点的前一个节点"></a>题解：寻找待删除节点的前一个节点</h4><ul><li>链表删除节点，必须之前待删除节点的前一个节点。</li><li>删除节点操作：<code>pre.next = cur.next;</code>注意判空。</li><li>为了方便处理一个节点和空链表的情况，初始化一个虚拟节点作为<code>pre</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            len++;<br>        &#125;<br><br>        <span class="hljs-comment">// 方便处理一个节点的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dumy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dumy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dumy;<br>        <span class="hljs-comment">// 寻找到要删除节点的前一个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len - n; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-comment">// 得到要删除的节点</span><br>        cur = pre.next;<br>        <span class="hljs-comment">// 这里需要判空</span><br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            pre.next = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dumy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h2><blockquote><p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/description/">https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/description/</a></p><p>输入两个链表，找出它们的第一个公共节点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111816.png" alt="image-20230418232817164"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Reference of the node with value = <span class="hljs-number">8</span><br>输入解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111800.png" alt="image-20230418232839444"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>输入解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul></blockquote><h4 id="题解：双指针"><a href="#题解：双指针" class="headerlink" title="题解：双指针"></a>题解：双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>        <span class="hljs-comment">// 这里如果对pA.next进行判空，就会进入无限循环出不来</span><br>        <span class="hljs-comment">// 假设链表如下：</span><br>        <span class="hljs-comment">// 1 -&gt; 3 -&gt; 5 -&gt; null</span><br>        <span class="hljs-comment">//      2 -&gt; 4 -&gt; null</span><br>        <span class="hljs-comment">// 如果对pA.next判空，则每次指针到5或4都会跳转到2或1,</span><br>        <span class="hljs-comment">// 但如果对pA本身判空，则总会存在一个null相等跳出循环</span><br>        <span class="hljs-comment">// pA = pA.next == null ? headB : pA.next;</span><br>        <span class="hljs-comment">// pB = pB.next == null ? headA : pB.next;</span><br>        pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>        pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-077-链表排序"><a href="#剑指-Offer-II-077-链表排序" class="headerlink" title="剑指 Offer II 077. 链表排序"></a>剑指 Offer II 077. 链表排序</h2><blockquote><p>给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111945.png" alt="image-20230426124533401" style="zoom:50%;" /><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [-<span class="hljs-number">1,5,3,4</span>,<span class="hljs-number">0</span>]<br>输出：[-<span class="hljs-number">1,0,3,4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="题解一：自定向下归并排序"><a href="#题解一：自定向下归并排序" class="headerlink" title="题解一：自定向下归并排序"></a>题解一：自定向下归并排序</h4><p><strong>思路</strong>：</p><ol><li>找到链表中点，以中点为分界。找链表中点方法：快慢指针，快指针每次移2步、慢指针每次移1步，当快指针到达链表末尾时，慢指针到达链表中点</li><li>对两个子链表进行排序</li><li>将两个排序后的子链表合并，得到排序后的链表</li></ol><blockquote><p>时间复杂度：nlog(n)，空间复杂度：log(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> sortList(head, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head, ListNode tail)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (head.next == tail) &#123;<br>            head.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 快慢指针寻找链表中间节点</span><br>        <span class="hljs-comment">// fast速度是slow两倍, 所以当fast到tail节点时, slow在中间节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>        <span class="hljs-keyword">while</span> (fast != tail) &#123;<br>            <span class="hljs-comment">// 慢指针走一步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// 快指针走两步</span><br>            fast = fast.next;<br>            <span class="hljs-keyword">if</span> (fast != tail) &#123;<br>                fast = fast.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> slow;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> sortList(head, mid);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> sortList(mid, tail);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> merge(l1, l2);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &gt; l2.val) &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：-自底向上归并排序"><a href="#题解二：-自底向上归并排序" class="headerlink" title="题解二： 自底向上归并排序"></a>题解二： 自底向上归并排序</h4><p><strong>思路</strong>：每次将链表分成子链表进行两两合并排序，最初是1, 后面依次为[2, 4, 8, …]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> dummy.next, prev = dummy;<br>            <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 寻找一个链表头结点head1</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">head1</span> <span class="hljs-operator">=</span> curr;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr.next != <span class="hljs-literal">null</span>; i++) &#123;<br>                    curr = curr.next;<br>                &#125;<br>                <span class="hljs-comment">// 寻找另一个链表头结点</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">head2</span> <span class="hljs-operator">=</span> curr.next;<br>                <span class="hljs-comment">// 剪断第一个链表head1与原始链表关系</span><br>                curr.next = <span class="hljs-literal">null</span>;<br>                curr = head2;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="hljs-literal">null</span> &amp;&amp; curr.next != <span class="hljs-literal">null</span>; i++) &#123;<br>                    curr = curr.next;<br>                &#125;<br>                <span class="hljs-comment">// 先记录第二个链表head2的下一个节点, 然后减掉第二个链表head2与原始链表关系</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                    next = curr.next;<br>                    curr.next = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 合并两个子链表</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">merge</span> <span class="hljs-operator">=</span> merge(head1, head2);<br>                <span class="hljs-comment">// 将合并后的新链表接到结果链表上</span><br>                prev.next = merge;<br>                <span class="hljs-keyword">while</span> (prev.next != <span class="hljs-literal">null</span>) &#123;<br>                    prev = prev.next;<br>                &#125;<br>                <span class="hljs-comment">// 重新赋值curr，准备开始当前长度subLength的下一次链表排序合并</span><br>                curr = next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &gt; l2.val) &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-027-回文链表"><a href="#剑指-Offer-II-027-回文链表" class="headerlink" title="剑指 Offer II 027. 回文链表"></a>剑指 Offer II 027. 回文链表</h2><blockquote><p><a href="https://leetcode.cn/problems/aMhZSa/">https://leetcode.cn/problems/aMhZSa/</a></p><p>给定一个链表的 <strong>头节点</strong> <code>head</code> <strong>，</strong>请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111747.png" alt="image-20230428154907613" style="zoom:50%;" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <span class="hljs-built_in">head</span> = [1,2,3,3,2,1]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：中点后反转链表"><a href="#题解：中点后反转链表" class="headerlink" title="题解：中点后反转链表"></a>题解：中点后反转链表</h4><p><strong>思路</strong>：</p><ul><li>快慢指针寻找链表中点</li><li>反转中点后面的链表，然后和中点前链表对比，判断值是否一样</li></ul><blockquote><p><strong>注意</strong>：</p><p>这题不能直接将整个链表反转然后比较，因为反转整个链表后head指针就变了（即原链表就变了）</p><p>例如： 1-&gt;2-&gt;3-&gt;4， 反转后：1&lt;-2&lt;-3&lt;-4，反转后head指向1，但是head.next为空了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 找中点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>        <span class="hljs-keyword">while</span> (slow != <span class="hljs-literal">null</span> &amp;&amp; fast != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>            <span class="hljs-keyword">if</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>                fast = fast.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 反转中点以后的链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverseLink</span> <span class="hljs-operator">=</span> reverseLink(slow);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, reverseCur = reverseLink;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; reverseCur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val != reverseCur.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.next;<br>            reverseCur = reverseCur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseLink</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h2><blockquote><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307092111082.png" alt="image-20230428155628067" style="zoom:50%;" /><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出: <span class="hljs-string">[1,3,5,2,4]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：正常思路"><a href="#题解：正常思路" class="headerlink" title="题解：正常思路"></a>题解：正常思路</h4><ul><li>一次遍历链表，分别将奇数偶数挑出来存储到新链表中</li><li>将偶数链表接到奇数链表后面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">oddEvenList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">// 存储奇数链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 存储偶数链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 判断当前是奇数索引节点还是偶数索引节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// cur: 遍历链表; oddRes: 接收奇数节点; evenRes: 接收偶数节点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, oddRes = odd, evenRes = even;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        index++;<br>        <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果是奇数索引节点, 连接到奇数链表中</span><br>            oddRes.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur.val);<br>            oddRes = oddRes.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是偶数索引节点, 连接到偶数链表中</span><br>            evenRes.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur.val);<br>            evenRes = evenRes.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">// 最后将偶数结果链表接到奇数结果链表中返回</span><br>    oddRes.next = even.next;<br>    <span class="hljs-keyword">return</span> odd.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><blockquote><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/</a></p><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2,3,3]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解：Set集合-链表删除"><a href="#题解：Set集合-链表删除" class="headerlink" title="题解：Set集合+链表删除"></a>题解：Set集合+链表删除</h4><ul><li>删除链表元素需要一个前置指针<code>pre</code></li><li>遍历判断元素是否在集合中，在就删除元素，不再则添加到集合中，把当前元素作为前置节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-comment">// cur: 遍历指针; pre: 因为要删除元素，所以需要一个前置指针指向第一个不重复元素, 如: [1, 1, 1] pre指向第一个1</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = cur;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(cur.val)) &#123;<br>            <span class="hljs-comment">// 遇到重复元素, 直接删除</span><br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 遇到不重复元素, 将pre指针指向当前</span><br>            set.add(cur.val);<br>            pre = cur;<br>        &#125;<br>        <span class="hljs-comment">// 遍历</span><br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h2><blockquote><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</a></p><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,3,4,4,5]</span><br>输出：<span class="hljs-comment">[1,2,5]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题解一：遍历两次删除两遍"><a href="#题解一：遍历两次删除两遍" class="headerlink" title="题解一：遍历两次删除两遍"></a>题解一：遍历两次删除两遍</h4><p>在<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">删除排序链表中的重复元素</a>中是留下一个重复元素，可以在此基础上再把剩下的重复元素删除。</p><ul><li>两个<code>set</code>，第一个<code>set</code>用于删除重复节点，保留一个。第二个<code>set</code>用于存储重复的节点，用在第二次遍历中删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-comment">// 先去一遍重: 例如原链表: [1, 1, 1, 2, 2, 3, 4, 5]</span><br>    <span class="hljs-comment">// 第一遍去重后: [1, 2, 3, 4, 5], 同时将重复元素记录到tSet中</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy.next, pre = cur;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    Set&lt;Integer&gt; tSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(cur.val)) &#123;<br>            pre.next = cur.next;<br>            tSet.add(cur.val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            set.add(cur.val);<br>            pre = cur;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">// 第二遍去重: 遍历第一遍去重后链表判断元素是否在tSet中, 有则需要再去掉该元素</span><br>    <span class="hljs-comment">// 由于链表第一个元素有可能需要去掉, 所以需要记录-1节点位置</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> dummy, pro = ptr;<br>    <span class="hljs-keyword">while</span> (ptr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tSet.contains(ptr.val)) &#123;<br>            pro.next = ptr.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pro = ptr;<br>        &#125;<br>        ptr = ptr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解二：遍历一次删除"><a href="#题解二：遍历一次删除" class="headerlink" title="题解二：遍历一次删除"></a>题解二：遍历一次删除</h4><ul><li>每次遍历<code>cur</code>指向留下的节点并表示前置节点。</li><li>比较cur.next和cur.next.next值是否相等：相等就说明这是个重复节点，需要删除，但需要寻找出所有等于该值的节点全部删除，所以再加个<code>while</code>循环遍历寻找相等的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 关键点: cur指针始终指向前置元素</span><br><span class="hljs-comment">         * 由于是升序链表, 设当前节点是cur, 直接比较cur.next和cur.next.next值是否相等即可确定是否需要删除</span><br><span class="hljs-comment">         *      -1 -&gt; 1 -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 3</span><br><span class="hljs-comment">         *      cur  ptr ...........ptr</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.next.val == cur.next.next.val) &#123;<br>            <span class="hljs-comment">// 遍历指针, 跳出循环指向下一个不重复元素</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-keyword">while</span> (ptr != <span class="hljs-literal">null</span> &amp;&amp; ptr.val == cur.next.val) &#123;<br>                ptr = ptr.next;<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 考虑到下面这种情况, 下一次循环仍需要丢弃2元素</span><br><span class="hljs-comment">                 *      -1 -&gt; 1 -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 2</span><br><span class="hljs-comment">                 *      cur  ptr ...........ptr</span><br><span class="hljs-comment">                 */</span><br>            cur.next = ptr;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不是重复元素, cur后移</span><br>            cur = cur.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel基础概念</title>
    <link href="/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><blockquote><p><strong>任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的</strong>。需要根据系统的处理能力对流量进行控制</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307021350271.png" alt="image-20230702135042339"></p><p>流量控制有下面几个角度：</p><ul><li><strong>资源的调用关系</strong>。比如：资源调用链路、资源和资源的关系。</li><li><strong>运行的指标</strong>。比如：QPS、线程池、系统负载。</li><li><strong>控制的效果</strong>。比如：直接限流、冷启动、排队。</li></ul><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>在资源调用过程中，如果某个资源出现了不稳定，最终会导致堆积发生。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022000526.png" alt="image-20230702135741629"></p><p>Sentinel 和 Hystrix 的原则是一致的：当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候。则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p><h3 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h3><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>的方式：</p><ul><li>好处：资源和资源之间做到了最彻底的隔离。</li><li>缺点：除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。</li></ul><p>Sentinel 对这个问题采取了两种手段：</p><ol><li><strong>通过并发线程数进行限制</strong></li></ol><p>这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。<strong>当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝</strong>。堆积的线程完成任务后才开始继续接收请求。</p><ol start="2"><li><strong>通过响应时间对资源进行降级</strong></li></ol><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。<strong>当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复</strong>。</p><h2 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h2><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><h2 id="Sentinel主流程"><a href="#Sentinel主流程" class="headerlink" title="Sentinel主流程"></a>Sentinel主流程</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称以及一个 Entry。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 API 显式创建；每一个 Entry 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:、</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p>总体的框架如下：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001521.png" alt="image-20230702154412159"></p><p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001747.png" alt="image-20230702154750154"></p><h2 id="Sentinal各个Slot功能"><a href="#Sentinal各个Slot功能" class="headerlink" title="Sentinal各个Slot功能"></a>Sentinal各个Slot功能</h2><h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><blockquote><p> 这个 slot 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p></blockquote><p>使用下面代码可以创建一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextUtil.enter(<span class="hljs-string">&quot;entrance1&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> <span class="hljs-type">Entry</span> <span class="hljs-variable">nodeA</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br><br> ContextUtil.enter(<span class="hljs-string">&quot;entrance2&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> nodeA = SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001547.png" alt="image-20230702160008744"></p><h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><blockquote><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。</p></blockquote><p>存储的信息示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>: nodeA<br>idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total <br>1   caller1 0         0         0          0        0     0         0          0        <br>2   caller2 0         0         0          0        0     0         0          0        <br></code></pre></td></tr></table></figure><h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><blockquote><p><code>StatisticSlot</code> 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</p></blockquote><ul><li><code>clusterNode</code>：资源唯一标识的 ClusterNode 的 runtime 统计</li><li><code>origin</code>：根据来自不同调用者的统计信息</li><li><code>defaultnode</code>: 根据上下文条目名称和资源 ID 的 runtime 统计</li><li>入口的统计</li></ul><p>Sentinel 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001258.png" alt="image-20230702160429033"></p><h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>这个 slot 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p><ul><li>指定应用生效的规则，即针对调用方限流的；</li><li>调用方为 other 的规则；</li><li>调用方为 default 的规则。</li></ul><h3 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h3><p>这个 slot 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p><h3 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h3><p>这个 slot 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p><p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">核心类解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel流量控制</title>
    <link href="/Sentinel/Sentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/Sentinel/Sentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p><p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p><p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>count</code>: 限流阈值</li><li><code>grade</code>: 限流阈值类型，QPS 或线程数</li><li><code>strategy</code>: 根据调用关系选择策略</li></ul><h2 id="基于QPS-x2F-并发数的流量控制"><a href="#基于QPS-x2F-并发数的流量控制" class="headerlink" title="基于QPS&#x2F;并发数的流量控制"></a>基于QPS&#x2F;并发数的流量控制</h2><p>流量控制主要有两种统计类型，一种是<strong>统计线程数</strong>，另外一种则是统计 QPS。类型由 <code>FlowRule.grade</code> 字段来定义。其中，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。其中线程数、QPS 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p><p>内容格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">idx</span> id   thread  pass  blocked   success  total Rt   <span class="hljs-number">1</span>m-pass   <span class="hljs-number">1</span>m-block   <span class="hljs-number">1</span>m-<span class="hljs-literal">all</span>   exeption<br><span class="hljs-attribute">2</span>   abc647 <span class="hljs-number">0</span>     <span class="hljs-number">46</span>     <span class="hljs-number">0</span>           <span class="hljs-number">46</span>     <span class="hljs-number">46</span>   <span class="hljs-number">1</span>       <span class="hljs-number">2763</span>      <span class="hljs-number">0</span>         <span class="hljs-number">2763</span>     <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>thread： 代表当前处理该资源的线程数；</li><li>pass： 代表一秒内到来到的请求；</li><li>blocked： 代表一秒内被流量控制的请求数量；</li><li>success： 代表一秒内成功处理完的请求；</li><li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li><li>RT： 代表一秒内该资源的平均响应时间；</li><li>1m-pass： 则是一分钟内到来的请求；</li><li>1m-block： 则是一分钟内被阻止的请求；</li><li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li><li>exception： 则是一秒内业务本身异常的总和。</li></ul><h3 id="2-1-并发线程数流量控制"><a href="#2-1-并发线程数流量控制" class="headerlink" title="2.1 并发线程数流量控制"></a>2.1 并发线程数流量控制</h3><p>线程数限流用于保护业务线程数不被耗尽。</p><p>Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。</p><h3 id="2-2-QPS流量控制"><a href="#2-2-QPS流量控制" class="headerlink" title="2.2 QPS流量控制"></a>2.2 QPS流量控制</h3><p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p><h4 id="直接拒绝"><a href="#直接拒绝" class="headerlink" title="直接拒绝"></a>直接拒绝</h4><p>直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。</p><h4 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h4><p>冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p><h4 id="匀速排队"><a href="#匀速排队" class="headerlink" title="匀速排队"></a>匀速排队</h4><p>匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p><p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><blockquote><p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022335925.png" alt="image-20230702223524513"></p><h2 id="基于调用关系的流量控制"><a href="#基于调用关系的流量控制" class="headerlink" title="基于调用关系的流量控制"></a>基于调用关系的流量控制</h2><p>调用关系包括调用方、被调用方；一个方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterBuilderSlot</code> 记录每个资源的实时统计信息。</p><h3 id="3-1-根据调用方限流"><a href="#3-1-根据调用方限流" class="headerlink" title="3.1 根据调用方限流"></a>3.1 根据调用方限流</h3><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。</p><p>调用数据示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>: nodeA<br>idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total <br>1   caller1 0         0         0          0        0     0         0          0<br>2   caller2 0         0         0          0        0     0         0          0<br></code></pre></td></tr></table></figure><p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p><p>流控规则中的 <code>limitApp</code> 字段用于根据调用来源进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p><ul><li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li><li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li><li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li></ul><p>同一个资源名可以配置多条规则，规则的生效顺序为：**{some_origin_name}&gt;other&gt;default**</p><blockquote><p>注意：调用来源的数目不要太多（一般不要超过几百个），否则内存占用会非常多（调用来源的统计节点最大数目&#x3D;资源数目*来源数目）。</p></blockquote><h3 id="3-2-根据调用链路入口限流：链路限流"><a href="#3-2-根据调用链路入口限流：链路限流" class="headerlink" title="3.2 根据调用链路入口限流：链路限流"></a>3.2 根据调用链路入口限流：链路限流</h3><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p><p>一棵典型的调用树如下图所示：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">          machine-root<br>              /       <span class="hljs-string">\</span><br>             /         <span class="hljs-string">\</span><br>       Entrance1     Entrance2<br>          /             <span class="hljs-string">\</span><br>         /               <span class="hljs-string">\</span><br>DefaultNode(nodeA)   DefaultNode(nodeA)<br></code></pre></td></tr></table></figure><p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_CHAIN</code>，同时设置 <code>refResource</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而不关心经 <code>Entrance2</code> 到来的调用。</p><p>调用链的入口（上下文）是通过 API 方法 <code>ContextUtil.enter(contextName)</code> 定义的，其中 contextName 即对应调用链路入口名称。</p><h3 id="3-3-具有关系的资源流量控制：关联流量控制"><a href="#3-3-具有关系的资源流量控制：关联流量控制" class="headerlink" title="3.3 具有关系的资源流量控制：关联流量控制"></a>3.3 具有关系的资源流量控制：关联流量控制</h3><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们<strong>可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_RELATE</code> 同时设置 <code>refResource</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel集群流控（未完待续）</title>
    <link href="/Sentinel/Sentinel%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7/"/>
    <url>/Sentinel/Sentinel%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p><p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p><p>集群流控中共有两种身份：</p><ul><li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li><li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li></ul><h2 id="此处先省略"><a href="#此处先省略" class="headerlink" title="此处先省略"></a>此处先省略</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">集群流控官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
