<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Sentinel限流原理</title>
    <link href="/Sentinel/Sentinel%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86/"/>
    <url>/Sentinel/Sentinel%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="SphU-entry-入口"><a href="#SphU-entry-入口" class="headerlink" title="SphU.entry 入口"></a>SphU.entry 入口</h2><p>从<code>SphU.entry()</code>方法向下执行，会进入到下面这个方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">entryWithPriority</span><span class="hljs-params">(ResourceWrapper resourceWrapper, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>       <span class="hljs-keyword">throws</span> BlockException &#123;<br>       <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> ContextUtil.getContext();<br>       <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> NullContext) &#123;<br>           <span class="hljs-comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span><br>           <span class="hljs-comment">// so here init the entry only. No rule checking will be done.</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// Using default context.</span><br>           context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);<br>       &#125;<br><br>       <span class="hljs-comment">// Global switch is close, no rule checking will do.</span><br>       <span class="hljs-comment">// 1. 全局开关关闭，说明没有规则检查，直接返回一个CtEntry对象，不再进行后续的限流检测</span><br>       <span class="hljs-keyword">if</span> (!Constants.ON) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-comment">// 2. 根据包装过的资源获取对应的SlotChain</span><br>       ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;,</span><br><span class="hljs-comment">        * so no rule checking will be done.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>       &#125;<br><br>       <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, chain, context, count, args);<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 3. 执行SlotChain的entry方法，如果SlotChain的entry方法抛出了BlockException，则将该异常继续向上抛出，如果SlotChain的entry方法正常执行了，则最后会将该entry对象返回</span><br>           chain.entry(context, resourceWrapper, <span class="hljs-literal">null</span>, count, prioritized, args);<br>       &#125; <span class="hljs-keyword">catch</span> (BlockException e1) &#123;<br>           e.exit(count, args);<br>           <span class="hljs-comment">// 4. 如果上层方法捕获了BlockException，则说明请求被限流了，否则请求能正常执行</span><br>           <span class="hljs-keyword">throw</span> e1;<br>       &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br>           <span class="hljs-comment">// This should not happen, unless there are errors existing in Sentinel internal.</span><br>           RecordLog.info(<span class="hljs-string">&quot;Sentinel unexpected exception&quot;</span>, e1);<br>       &#125;<br>       <span class="hljs-keyword">return</span> e;<br>   &#125;<br></code></pre></td></tr></table></figure><p>该方法主要实现了下面几点：</p><ol><li>全局开关关闭，说明没有规则检查，直接返回一个 CtEntry 对象，不再进行后续的限流检测。</li><li>根据包装过的资源获取对应的 SlotChain。</li><li>执行 SlotChain 的 entry 方法，如果 SlotChain 的 entry 方法抛出了 BlockException，则将该异常继续向上抛出，如果 SlotChain 的 entry 方法正常执行了，则最后会将该 entry 对象返回。</li><li>如果上层方法捕获了 BlockException，则说明请求被限流了，否则请求能正常执行。</li></ol><h2 id="SlotChain-的链路获取"><a href="#SlotChain-的链路获取" class="headerlink" title="SlotChain 的链路获取"></a>SlotChain 的链路获取</h2><p>重点关注一下<strong>SlotChain</strong>链路的获取逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java">ProcessorSlot&lt;Object&gt; <span class="hljs-title function_">lookProcessChain</span><span class="hljs-params">(ResourceWrapper resourceWrapper)</span> &#123;<br>    <span class="hljs-comment">// 这里使用两次判断为null(双重检查锁或缓存机制)的原因如下：</span><br>    <span class="hljs-comment">// 假设有两个线程A，B同时到达第一个if，都为null，此时A线程进入synchronized</span><br>    <span class="hljs-comment">// 遇到第二个if，当然还是null，A线程就会执行第二个if里面的语句，创建一个chain，然后存到缓存中，退出synchronized</span><br>    <span class="hljs-comment">// B线程进入synchronized，获取chain，但此时缓存命中，就不用再执行第二个if里面的语句了，减少了synchronized锁的时间</span><br>    <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> chainMap.get(resourceWrapper);<br>    <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>            chain = chainMap.get(resourceWrapper);<br>            <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Entry size limit.</span><br>                <span class="hljs-keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br><span class="hljs-comment">// 构造SlotChain</span><br>                chain = SlotChainProvider.newSlotChain();<br><br>               <span class="hljs-comment">// map扩容</span><br>                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;ResourceWrapper, ProcessorSlotChain&gt;(<br>                    chainMap.size() + <span class="hljs-number">1</span>);<br>                newMap.putAll(chainMap);<br>                <span class="hljs-comment">// 将资源和slot-chain映射</span><br>                newMap.put(resourceWrapper, chain);<br>                chainMap = newMap;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> chain;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessorSlotChain <span class="hljs-title function_">newSlotChain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (slotChainBuilder != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> slotChainBuilder.build();<br>    &#125;<br><br>    <span class="hljs-comment">// Resolve the slot chain builder SPI.</span><br>    <span class="hljs-comment">// 从com.alibaba.csp.sentinel.slotchain.ProcessorSlot文件中读取slot构建slot chain</span><br>    slotChainBuilder = SpiLoader.of(SlotChainBuilder.class).loadFirstInstanceOrDefault();<br><br>    <span class="hljs-comment">// 确保slotChainBuilder不为null</span><br>    <span class="hljs-keyword">if</span> (slotChainBuilder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Should not go through here.</span><br>        RecordLog.warn(<span class="hljs-string">&quot;[SlotChainProvider] Wrong state when resolving slot chain builder, using default&quot;</span>);<br>        slotChainBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSlotChainBuilder</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        RecordLog.info(<span class="hljs-string">&quot;[SlotChainProvider] Global slot chain builder resolved: &#123;&#125;&quot;</span>,<br>                       slotChainBuilder.getClass().getCanonicalName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> slotChainBuilder.build();<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSlotChainBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SlotChainBuilder</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ProcessorSlotChain <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultProcessorSlotChain</span>();<br><br>        List&lt;ProcessorSlot&gt; sortedSlotList = SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted();<br>        <span class="hljs-keyword">for</span> (ProcessorSlot slot : sortedSlotList) &#123;<br>            <span class="hljs-keyword">if</span> (!(slot <span class="hljs-keyword">instanceof</span> AbstractLinkedProcessorSlot)) &#123;<br>                RecordLog.warn(<span class="hljs-string">&quot;The ProcessorSlot(&quot;</span> + slot.getClass().getCanonicalName() + <span class="hljs-string">&quot;) is not an instance of AbstractLinkedProcessorSlot, can&#x27;t be added into ProcessorSlotChain&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            chain.addLast((AbstractLinkedProcessorSlot&lt;?&gt;) slot);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> chain;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Sentinel 里面，所有的资源都对应一个资源名称（<code>resourceName</code>），每次资源调用都会创建一个 <code>Entry</code> 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>SphU</code> API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p><ul><li>**<code>NodeSelectorSlot</code>**：收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</li><li><strong><code>ClusterBuilderSlot</code></strong> ：用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><strong><code>StatisticSlot</code></strong> ：用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><strong><code>SystemSlot</code></strong> ：通过系统的状态，来控制总的入口流量；</li><li><strong><code>AuthoritySlot</code></strong> ：根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><strong><code>FlowSlot</code></strong> ：用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><strong><code>DegradeSlot</code></strong> ：通过统计信息以及预设的规则，来做熔断降级；</li></ul><p>下面借用官网的图片：官方链接如下：<a href="https://sentinelguard.io/zh-cn/docs/basic-implementation.html">https://sentinelguard.io/zh-cn/docs/basic-implementation.html</a></p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906761.png" alt="image-20220801191458948"></p><p>上面 slot 的排序规则根据下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(sortedClassList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">S</span>&gt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Class&lt;? extends S&gt; o1, Class&lt;? extends S&gt; o2)</span> &#123;<br>        <span class="hljs-type">Spi</span> <span class="hljs-variable">spi1</span> <span class="hljs-operator">=</span> o1.getAnnotation(Spi.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">order1</span> <span class="hljs-operator">=</span> spi1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : spi1.order();<br><br>        <span class="hljs-type">Spi</span> <span class="hljs-variable">spi2</span> <span class="hljs-operator">=</span> o2.getAnnotation(Spi.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> spi2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : spi2.order();<br><br>        <span class="hljs-keyword">return</span> Integer.compare(order1, order2);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>其中<code>spi2.order()</code>是<code>@Spi</code>注解定义的，每个 slot 的顺序如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_NODE_SELECTOR_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_CLUSTER_BUILDER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">9000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_LOG_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_STATISTIC_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">7000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_AUTHORITY_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_SYSTEM_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_FLOW_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEFAULT_CIRCUIT_BREAKER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1500</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEGRADE_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>整个调用链中最核心的就是 **<code>StatisticSlot</code>(<strong>用于记录、统计不同纬度的 runtime 指标监控信息) 以及</strong><code>FlowSlot</code>(**根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制）</p><p>可以查看**<code>DefaultProcessorSlotChain.java</code>**类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultProcessorSlotChain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ProcessorSlotChain</span> &#123;<br><br>    <span class="hljs-comment">// 先创建头结点</span><br>    AbstractLinkedProcessorSlot&lt;?&gt; first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractLinkedProcessorSlot</span>&lt;Object&gt;() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>            <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-built_in">super</span>.fireEntry(context, resourceWrapper, t, count, prioritized, args);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, <span class="hljs-type">int</span> count, Object... args)</span> &#123;<br>            <span class="hljs-built_in">super</span>.fireExit(context, resourceWrapper, count, args);<br>        &#125;<br><br>    &#125;;<br>    <span class="hljs-comment">// 创建尾结点，直接指向头结点</span><br>    AbstractLinkedProcessorSlot&lt;?&gt; end = first;<br>    ....<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出<strong>ProcessorSlotChain</strong>是一个链表，里面有两个<strong>AbstractLinkedProcessorSlot</strong>类型的链表：first 和 end，即链表的头结点和尾结点。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906376.png" alt="image-20220801191557361"></p><p>然后添加通过<code>addLast</code>方法添加节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span> &#123;<br>    end.setNext(protocolProcessor);<span class="hljs-comment">// 由于end=first，所以是在first.next下面添加节点</span><br>    end = protocolProcessor;<span class="hljs-comment">// 然后调整end的指针指向新节点</span><br>&#125;<br><br><span class="hljs-comment">// AbstractLinkedProcessorSlot抽象类中的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(AbstractLinkedProcessorSlot&lt;?&gt; next)</span> &#123;<br>    <span class="hljs-built_in">this</span>.next = next;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906704.png" alt="image-20220801191607238"></p><p>然后依次类推，可以得到下面的链路 SlotChain：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906079.png" alt="image-20220801191620840"></p><h2 id="SlotChain-的链路执行"><a href="#SlotChain-的链路执行" class="headerlink" title="SlotChain 的链路执行"></a>SlotChain 的链路执行</h2><p><code>lookProcessChain</code>方法获得的第一个<code>ProcessorSlotChain</code>的实例是<code>DefaultProcessorSlotChain</code>，那么执行 chain.entry 方法，就会执行<code>DefaultProcessorSlotChain</code>的<code>entry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 触发下一个slot</span><br>    first.transformEntry(context, resourceWrapper, t, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着调用父类<code>AbstractLinkedProcessorSlot </code>的<code>transformEntry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 触发下一个节点entry逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireEntry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>        next.transformEntry(context, resourceWrapper, obj, count, prioritized, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transformEntry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object o, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (T)o;<br>    <span class="hljs-comment">// 触发节点entry逻辑</span><br>    entry(context, resourceWrapper, t, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟着代码<code>debug</code>可以知道，上面代码会触发第一个 slot 节点，也就是<code>NodeSelectorSlot</code>。这里先不介绍这个 slot 的具体逻辑。</p><h2 id="Slot-中的-entry-逻辑"><a href="#Slot-中的-entry-逻辑" class="headerlink" title="Slot 中的 entry 逻辑"></a>Slot 中的 entry 逻辑</h2><h3 id="滑动窗口限流原理"><a href="#滑动窗口限流原理" class="headerlink" title="滑动窗口限流原理"></a>滑动窗口限流原理</h3><h4 id="从-StatisticSlot-中的-entry-进入"><a href="#从-StatisticSlot-中的-entry-进入" class="headerlink" title="从 StatisticSlot 中的 entry 进入"></a>从 StatisticSlot 中的 entry 进入</h4><p><code>StaticSlot</code>主要是统计指标数据，用来给<code>FlowSlot</code>进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        Iterator var8;<br>        ProcessorSlotEntryCallback handler;<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// Do some checking.</span><br>            <span class="hljs-comment">// 1. 做一些检查，执行AuthoritySlot、SystemSlot、FlowSlot、DefaultCircuitBreakerSlot方法</span><br>            <span class="hljs-comment">// 如果规则不通过，就会抛出BlockException异常。反之，会在node中统计通过的请求数和线程数等信息。</span><br>            <span class="hljs-built_in">this</span>.fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>            <span class="hljs-comment">// 执行到这里表示通过了检查，没有被限流</span><br>            node.increaseThreadNum();<br>            <span class="hljs-comment">// 2. 记录通过规则的请求</span><br>            node.addPassRequest(count);<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseThreadNum();<br>                context.getCurEntry().getOriginNode().addPassRequest(count);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseThreadNum();<br>                Constants.ENTRY_NODE.addPassRequest(count);<br>            &#125;<br><br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">var13</span> <span class="hljs-operator">=</span> StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var13.hasNext()) &#123;<br>                ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler = (ProcessorSlotEntryCallback)var13.next();<br>                handler.onPass(context, resourceWrapper, node, count, args);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (PriorityWaitException var10) &#123;<br>            node.increaseThreadNum();<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseThreadNum();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseThreadNum();<br>            &#125;<br><br>            var8 = StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;<br>                handler = (ProcessorSlotEntryCallback)var8.next();<br>                handler.onPass(context, resourceWrapper, node, count, args);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException var11) &#123;<br>            <span class="hljs-type">BlockException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> var11;<br>            context.getCurEntry().setBlockError(var11);<br>            node.increaseBlockQps(count);<br>            <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>                context.getCurEntry().getOriginNode().increaseBlockQps(count);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>                Constants.ENTRY_NODE.increaseBlockQps(count);<br>            &#125;<br><br>            var8 = StatisticSlotCallbackRegistry.getEntryCallbacks().iterator();<br><br>            <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;<br>                handler = (ProcessorSlotEntryCallback)var8.next();<br>                handler.onBlocked(e, context, resourceWrapper, node, count, args);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>            context.getCurEntry().setError(var12);<br>            <span class="hljs-keyword">throw</span> var12;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><code>node.addPassRequest</code>方法是在<code>fireEntry</code>执行后才执行的，也就是说，当前请求通过了 sentinel 的流控规则，此时需要将当次请求记录下来，也就是执行<code>addPassRequest</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPassRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-built_in">super</span>.addPassRequest(count);<br>    <span class="hljs-built_in">this</span>.clusterNode.addPassRequest(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面方法在<code>DefaultNode</code>对象中。</p><ul><li><code>DefaultNode</code>：保存着某个 resource 在某个 context 中的实时指标，每个 DefaultNode 都指向一个 ClusterNode</li><li><code>ClusterNode</code>：保存着某个 resource 在所有 context 中实时指标的总和，同样的 resource 会共享同一个 ClusterNode，不管他在哪个 context 中</li></ul><p>在<code>StatisticNode</code>类中对<code>ArrayMetric</code>进行了初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.rollingCounterInSecond = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL);<br><span class="hljs-built_in">this</span>.rollingCounterInMinute = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(<span class="hljs-number">60</span>, <span class="hljs-number">60000</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPassRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-built_in">this</span>.rollingCounterInSecond.addPass(count);<br>    <span class="hljs-built_in">this</span>.rollingCounterInMinute.addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加指标用的 addPass 方法是一个<code>ArrayMetric</code>的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LeapArray&lt;MetricBucket&gt; data;<br><br><span class="hljs-comment">// SAMPLE_COUNT=2  INTERVAL=1000 上面传递的静态变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayMetric</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs)</span> &#123;<br>    <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OccupiableBucketLeapArray</span>(sampleCount, intervalInMs);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPass</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    WindowWrap&lt;MetricBucket&gt; wrap = <span class="hljs-built_in">this</span>.data.currentWindow();<br>    ((MetricBucket)wrap.value()).addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就跟窗口有关系了，这里使用<code>data</code>来获取当前窗口，窗口大小为 2。data 的类型是<code>MetricBucket</code>对象，用来保存各项指标，变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LongAdder[] counters;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> minRt;<br></code></pre></td></tr></table></figure><p><code>WindowWrap</code>对象的变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间窗口的长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowLengthInMs;<br><span class="hljs-comment">// 时间窗口的开始时间，单位是毫秒</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> windowStart;<br><span class="hljs-comment">//时间窗口的内容，在 WindowWrap 中是用泛型表示这个值的，但实际上就是 MetricBucket 类, 参考上面代码</span><br><span class="hljs-keyword">private</span> T value;<br></code></pre></td></tr></table></figure><p><code>LeapArray</code>对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeapArray</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 时间窗口的长度</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> windowLengthInMs;<br>    <span class="hljs-comment">// 采样窗口的个数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> sampleCount;<br>    <span class="hljs-comment">// 以毫秒为单位的时间间隔</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> intervalInMs;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> intervalInSecond;<br>    <span class="hljs-comment">// 采样的时间窗口数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">updateLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LeapArray</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs)</span> &#123;<br>        AssertUtil.isTrue(sampleCount &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;bucket count is invalid: &quot;</span> + sampleCount);<br>        AssertUtil.isTrue(intervalInMs &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;total time interval of the sliding window should be positive&quot;</span>);<br>        AssertUtil.isTrue(intervalInMs % sampleCount == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;time span needs to be evenly divided&quot;</span>);<br>        <span class="hljs-built_in">this</span>.windowLengthInMs = intervalInMs / sampleCount;<br>        <span class="hljs-built_in">this</span>.intervalInMs = intervalInMs;<br>        <span class="hljs-built_in">this</span>.intervalInSecond = (<span class="hljs-type">double</span>)intervalInMs / <span class="hljs-number">1000.0D</span>;<br>        <span class="hljs-comment">// 时间窗口的采样个数，默认为2个采样窗口</span><br>        <span class="hljs-built_in">this</span>.sampleCount = sampleCount;<br>        <span class="hljs-built_in">this</span>.array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceArray</span>(sampleCount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>LeapArray</code>中创建了一个<code>AtomicReferenceArray</code>数组，用来对时间窗口中的统计值进行采样。通过采样的统计值计算出平均值，即最终的实时指标的值。</p><p>重点是<code>this.data.currentWindow();</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateTimeIdx</span><span class="hljs-params">(<span class="hljs-comment">/*@Valid*/</span> <span class="hljs-type">long</span> timeMillis)</span> &#123;<br>    <span class="hljs-comment">// 获取时间窗口个数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">timeId</span> <span class="hljs-operator">=</span> timeMillis / windowLengthInMs;<br>    <span class="hljs-comment">// Calculate current index so we can map the timestamp to the leap array.</span><br>    <span class="hljs-comment">// 获取当前时间在实际窗口array数组中的索引</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(timeId % array.length());<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title function_">calculateWindowStart</span><span class="hljs-params">(<span class="hljs-comment">/*@Valid*/</span> <span class="hljs-type">long</span> timeMillis)</span> &#123;<br>    <span class="hljs-comment">// 获取时间窗口的起始时间。如下：</span><br>    <span class="hljs-comment">// 时间点：0    1    2   3   4   5   6</span><br>    <span class="hljs-comment">// 时间窗口windowLengthInMs为：2</span><br>    <span class="hljs-comment">// 当前时间为timeMillis为：5</span><br>    <span class="hljs-comment">// 当前时间所在的窗口起始时间= 5 - 5 % 2 = 4</span><br>    <span class="hljs-comment">// timeMillis % windowLengthInMs = 当前时间在当前时间窗口已经跑过的距离</span><br>    <span class="hljs-keyword">return</span> timeMillis - timeMillis % windowLengthInMs;<br>&#125;<br><br><span class="hljs-comment">// 传进来的是当前时间</span><br><span class="hljs-keyword">public</span> WindowWrap&lt;T&gt; <span class="hljs-title function_">currentWindow</span><span class="hljs-params">(<span class="hljs-type">long</span> timeMillis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (timeMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><span class="hljs-comment">// 时间窗口个数对2（假如默认值）取模</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> calculateTimeIdx(timeMillis);<br>        <span class="hljs-comment">// Calculate current bucket start time.</span><br>    <span class="hljs-comment">// 时间窗口的起始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">windowStart</span> <span class="hljs-operator">=</span> calculateWindowStart(timeMillis);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Get bucket item at given time from the array.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * (1) Bucket is absent, then just create a new bucket and CAS update to circular array.</span><br><span class="hljs-comment">         * (2) Bucket is up-to-date, then just return the bucket.</span><br><span class="hljs-comment">         * (3) Bucket is deprecated, then reset current bucket and clean all deprecated buckets.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 根据索引获取缓存的时间窗口</span><br>            WindowWrap&lt;T&gt; old = array.get(idx);<br>           <span class="hljs-comment">// 这里如果没有从缓存中取到，就会创建一个新的时间窗口，所以array的长度不能太大，不然不容易命中</span><br>            <span class="hljs-keyword">if</span> (old == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            bucket is empty, so create new and update</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the old bucket is absent, then we create a new bucket at &#123;@code windowStart&#125;,</span><br><span class="hljs-comment">                 * then try to update circular array via a CAS operation. Only one thread can</span><br><span class="hljs-comment">                 * succeed to update, while other threads yield its time slice.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-comment">// (1) 没取到缓存，则创建一个新的时间窗口</span><br>                WindowWrap&lt;T&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>                <span class="hljs-comment">// 通过CAS将新创建的窗口置换到缓存数组中去</span><br>                <span class="hljs-keyword">if</span> (array.compareAndSet(idx, <span class="hljs-literal">null</span>, window)) &#123;<br>                    <span class="hljs-comment">// 设置成功就返回该窗口</span><br>                    <span class="hljs-keyword">return</span> window;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 否则当前线程让出时间片，等待</span><br>                    Thread.<span class="hljs-keyword">yield</span>();<br>                &#125;<br>            <span class="hljs-comment">// (2) 如果当前窗口的开始时间与old的开始时间相等，则直接返回old窗口</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart == old.windowStart()) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2     B3      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            startTime of Bucket 3: 800, so it&#x27;s up-to-date</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If current &#123;@code windowStart&#125; is equal to the start timestamp of old bucket,</span><br><span class="hljs-comment">                 * that means the time is within the bucket, so directly return the bucket.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">return</span> old;<br>            <span class="hljs-comment">// 如果当前时间窗口的开始时间已经超过了old窗口的开始时间，则放弃old窗口</span><br>            <span class="hljs-comment">// 并将time设置为新的时间窗口的开始时间，此时窗口向前滑动</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &gt; old.windowStart()) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *   (old)</span><br><span class="hljs-comment">                 *             B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * |_______||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * ...    1200     1400    1600    1800    2000    2200  timestamp</span><br><span class="hljs-comment">                 *                              ^</span><br><span class="hljs-comment">                 *                           time=1676</span><br><span class="hljs-comment">                 *          startTime of Bucket 2: 400, deprecated, should be reset</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the start timestamp of old bucket is behind provided time, that means</span><br><span class="hljs-comment">                 * the bucket is deprecated. We have to reset the bucket to current &#123;@code windowStart&#125;.</span><br><span class="hljs-comment">                 * Note that the reset and clean-up operations are hard to be atomic,</span><br><span class="hljs-comment">                 * so we need a update lock to guarantee the correctness of bucket update.</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * The update lock is conditional (tiny scope) and will take effect only when</span><br><span class="hljs-comment">                 * bucket is deprecated, so in most cases it won&#x27;t lead to performance loss.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (updateLock.tryLock()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// (3) Successfully get the update lock, now we reset the bucket.</span><br>                        <span class="hljs-keyword">return</span> resetWindowTo(old, windowStart);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        updateLock.unlock();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span><br>                    Thread.<span class="hljs-keyword">yield</span>();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &lt; old.windowStart()) &#123;<br>                <span class="hljs-comment">// Should not go through here, as the provided time is already behind.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面代码实际可以分成以下几步：</p><ol><li>根据当前时间，算出该时间的 timeId，并根据 timeId 算出当前窗口在采样窗口数组中的索引 idx。</li><li>根据当前时间算出当前窗口的应该对应的开始时间 time，以毫秒为单位。</li><li>根据索引 idx，在采样窗口数组中取得一个时间窗口。</li><li>循环判断直到获取到一个当前时间窗口 old 。<ol><li>如果 old 为空，则创建一个时间窗口，并将它插入到 array 的第 idx 个位置，array 上面已经分析过了，是一个 AtomicReferenceArray。</li><li>如果当前窗口的开始时间 time 与 old 的开始时间相等，那么说明 old 就是当前时间窗口，直接返回 old。</li><li>如果当前窗口的开始时间 time 大于 old 的开始时间，则说明 old 窗口已经过时了，将 old 的开始时间更新为最新值：time，进入下一次得循环再判断当前窗口的开始时间 time 与 old 的开始时间相等的时候返回。</li><li>如果当前窗口的开始时间 time 小于 old 的开始时间，实际上这种情况是不可能存在的，因为 time 是当前时间，old 是过去的一个时间。</li></ol></li></ol><p><strong>timeId（即时间窗口的个数）是会随着时间的增长而增加，当前时间每增长一个 windowLength 的长度，timeId 就加 1。但是 idx 不会增长，只会在 0 和 1 之间变换，因为 array 数组的长度是 2，只有两个采样时间窗口。</strong></p><p>为什么默认只有两个采样窗口？可能是因为时间窗口中保存着很多统计数据，如果时间窗口过多的话，一方面会占用过多内存，另一方面时间窗口过多就意味着时间窗口的长度会变小，如果时间窗口长度变小，就会导致时间窗口过于频繁的滑动。</p><p><strong>下面看看 currentWindow 代码逻辑</strong>：</p><p>根据当前时间除于 <code>windowLength </code>得到一个 timeId，再用 timeId 跟取样窗口的长度进行一个取模，那么值一定会落在 0，1 两个位置的其中一个。然后根据当前时间算出当前窗口的应该对应的开始时间 time。由于刚刚开始的时候 array 是空的，那么获取到的 old 应当是 null，那么会创建一个新的实例，用图看一下初始化的 LeapArray：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091850289.png" alt="image-20230709184837045"></p><p>当 old 获取到的是 null，那么初始的时候 arrays 数组中只有一个窗口（可能是第一个(idx&#x3D;0)，也可能是第二个(idx&#x3D;1)），每个时间窗口的长度是 500ms，这就意味着只要当前时间与时间窗口的差值在 500ms 之内，时间窗口就不会向前滑动。例如，假如当前时间走到 300 或者 500 时，当前时间窗口仍然是相同的那个：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091854811.png" alt="image-20230709185358381"></p><p>时间继续往前走，当超过 500ms 时，时间窗口就会向前滑动到下一个，这时就会更新当前窗口的开始时间,时间继续往前走，只要不超过 1000ms，则当前窗口不会发生变化，其中代码实现是 resetWindowTo 方法：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091857034.png" alt="image-20230709185704628"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WindowWrap&lt;MetricBucket&gt; <span class="hljs-title function_">resetWindowTo</span><span class="hljs-params">(WindowWrap&lt;MetricBucket&gt; w, <span class="hljs-type">long</span> time)</span> &#123;<br>    <span class="hljs-comment">// Update the start time and reset value.</span><br>    w.resetTo(time);<br>    <span class="hljs-type">MetricBucket</span> <span class="hljs-variable">borrowBucket</span> <span class="hljs-operator">=</span> borrowArray.getWindowValue(time);<br>    <span class="hljs-keyword">if</span> (borrowBucket != <span class="hljs-literal">null</span>) &#123;<br>        w.value().reset();<br>        w.value().addPass((<span class="hljs-type">int</span>)borrowBucket.pass());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        w.value().reset();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br></code></pre></td></tr></table></figure><p>当时间继续往前走，当前时间超过 1000ms 时，就会再次进入下一个时间窗口，此时 arrays 数组中的窗口将会有一个失效，会有另一个新的窗口进行替换：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307091906190.png" alt="image-20220814153836045"></p><p>这样，在当前时间点中进入的请求，会被统计到当前时间对应的窗口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPass</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    WindowWrap&lt;MetricBucket&gt; wrap = data.currentWindow();<br>    wrap.value().addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>获得窗口后，会执行下面语句，增加当前窗口通过的请求数 QPS。这里的<code>wrap.value()</code>得到的是<code>MetricBucket</code>，在 Sentinel 中 QPS 相关数据的统计结果就维护在这个类中<code>LongAddr[]</code>中，最终由这个指标来与我们设置好的规则进行匹配，查看是否限流，也就是<code>StatisticSlot</code>的 entry 方法中的<code>fireEntry</code>，都要先进入到<code>FlowSlot</code>的<code>entry</code>方法进行限流过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 在此方法里面进行限流规则检查</span><br>    checkFlow(resourceWrapper, context, node, count, prioritized);<br><br>    fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>FlowRuleChecker</code>类中，循环规则匹配资源进行限流过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkFlow</span><span class="hljs-params">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span><br><span class="hljs-params">                      Context context, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized)</span> <span class="hljs-keyword">throws</span> BlockException &#123;<br>    <span class="hljs-keyword">if</span> (ruleProvider == <span class="hljs-literal">null</span> || resource == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());<br>    <span class="hljs-keyword">if</span> (rules != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (FlowRule rule : rules) &#123;<br>            <span class="hljs-keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowException</span>(rule.getLimitApp(), rule);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/wuzhenzhao/p/11453649.html">https://www.cnblogs.com/wuzhenzhao/p/11453649.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存一致性方案思考</title>
    <link href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、缓存的查询"><a href="#一、缓存的查询" class="headerlink" title="一、缓存的查询"></a>一、缓存的查询</h2><p>先查询缓存，如果缓存查询失败，就去查询数据库，然后重新生成缓存。</p><h2 id="二、缓存的更新"><a href="#二、缓存的更新" class="headerlink" title="二、缓存的更新"></a>二、缓存的更新</h2><p>在高并发的情况下，需要考虑下面两个问题：</p><ul><li>是先更新数据库还是先更新缓存？</li><li>是更新缓存还是删除缓存？</li></ul><h4 id="1-先更新数据库再更新缓存"><a href="#1-先更新数据库再更新缓存" class="headerlink" title="1. 先更新数据库再更新缓存"></a>1. 先更新数据库再更新缓存</h4><p>线程A：更新数据库（第1s）——&gt;  更新缓存（第10s）</p><p>线程B：更新数据库 （第3s）——&gt; 更新缓存（第5s）</p><p>上面情况，就会导致线程B的缓存值被线程A覆盖，<strong>缓存中存的是线程A的旧值</strong>，产生脏数据并且直到缓存失效（如果有过期时间）。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252234.png" alt="image-20230620164505738" style="zoom:50%;" /><h4 id="2-先更新缓存再更新数据库"><a href="#2-先更新缓存再更新数据库" class="headerlink" title="2. 先更新缓存再更新数据库"></a>2. 先更新缓存再更新数据库</h4><p>线程A：更新缓存（第1s）——&gt; 更新数据库（第10s）</p><p>线程B： 更新缓存（第3s）——&gt;  更新数据库（第5s）</p><p>和前面一种情况相反，<strong>缓存中是线程B的新值，而数据库中是线程A的旧值。</strong></p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252759.png" alt="image-20230620170050262" style="zoom:50%;" /><p>﻿前两种方式之所以会在并发场景下出现异常，<strong>本质上是因为更新缓存和更新数据库是两个操作</strong>。</p><p>如果把它化简，更新时只更新数据库，同时删除缓存。等待下一次查询时命中不到缓存，再去重建缓存，是不是就解决了这个问题？</p><h4 id="3-先删除缓存再更新数据库"><a href="#3-先删除缓存再更新数据库" class="headerlink" title="3. 先删除缓存再更新数据库"></a>3. 先删除缓存再更新数据库</h4><p>通过这种方式，两个线程都值修改数据库，不管谁先，数据库以后修改的数据为准。</p><p>但这时另一个<strong>并发场景</strong>：两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的。很显然，这种状况也不是我们想要的。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252794.png" alt="image-20230620170016670" style="zoom:50%;" /><p><strong>解决方案</strong>：</p><h5 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h5><p>对于<strong>请求</strong>A，做一下操作：</p><ol><li><p>删除缓存</p></li><li><p>更新数据库</p></li><li><p><strong>睡眠一段时间</strong></p></li><li><p><strong>再次删除缓存</strong></p></li></ol><p>添加一个睡眠时间，主要是为了确保请求A在睡眠的时候，请求B能在这段时间内完成<strong>从数据库读取数据，再把缺失的数据写入缓存</strong>的操作，然后请求A睡眠完，再删除缓存。</p><p>所以请求A的睡眠时间就需要大于请求B<strong>从数据库读取数据+写入数据</strong>的时间。<strong>但是这个时间不好评估</strong>。</p><p><strong>所以不建议这种方案</strong>。</p><h4 id="4-先更新数据库再删除缓存（cache-aside）"><a href="#4-先更新数据库再删除缓存（cache-aside）" class="headerlink" title="4. 先更新数据库再删除缓存（cache aside）"></a>4. 先更新数据库再删除缓存（cache aside）</h4><p><strong>场景</strong>：一个是查询操作，一个是更新操作的并发，我们先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，删除操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会方案3一样，后续的查询操作一直在取老的数据。如下图：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252546.png" alt="image-20230619202426780" style="zoom: 50%;" /><p>但是，这种策略也不是一定完美。看下面这个场景：</p><p>一个读操作没有命中缓存，然后就去数据库中获取数据。此时有一个写操作，写完数据库后，让缓存失效。然后之前的读操作再把老的数据写回缓存，这样就造成脏数据。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252030.png" alt="image-20230620170340552" style="zoom:50%;" /><p>上面的例子理论上会出现，但是出现概率比较低。因为条件需要读缓存时缓存正好失效，并且此时并发一个写操作。而数据库写操作比读操作慢的多，而读操作读操作必须在写操作之前，又要晚于写操作更新缓存。所有条件在一起的可能性并不大。</p><h2 id="三、操作失败如何"><a href="#三、操作失败如何" class="headerlink" title="三、操作失败如何"></a>三、操作失败如何</h2><p>在实际生产中，由于网络抖动、服务下线等原因，对数据库和缓存的操作可能失败。</p><p>举例说明：应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252746.png" alt="image-20230620170950273" style="zoom:50%;" /><p>那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有删除，所以会缓存命中，但是读到的却是旧值 1。</p><p>其实<strong>不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题</strong>。</p><p>问题原因知道了，该怎么解决呢？有两种方法：</p><ul><li>重试机制</li><li>订阅MySQL binlog，再操作缓存</li></ul><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p>举个例子，来说明重试机制的过程：</p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262252738.png" alt="image-20230620171258860" style="zoom:50%;" /><h4 id="订阅-MySQL-binlog，再操作缓存"><a href="#订阅-MySQL-binlog，再操作缓存" class="headerlink" title="订阅 MySQL binlog，再操作缓存"></a>订阅 MySQL binlog，再操作缓存</h4><p><strong>先更新数据库，再删缓存</strong>的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p><p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p><p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p><p>下图是 Canal 的工作原理：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202306262253576.png" alt="image-20230619225953489"></p><p>综上，<strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</strong></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="1-cache-aside并非万能"><a href="#1-cache-aside并非万能" class="headerlink" title="1. cache aside并非万能"></a>1. cache aside并非万能</h3><p>虽然说cache aside可以被称之为缓存使用的最佳实践，但与此同时，它引入了缓存的命中率降低的问题，（每次都删除缓存自然导致更不容易命中了），因此它更适用于对缓存命中率要求并不是特别高的场景。<strong>如果要求较高的缓存命中率，依然需要采用更新数据库后同时更新缓存的方案</strong>。</p><h3 id="2-缓存数据不一致的解决方案"><a href="#2-缓存数据不一致的解决方案" class="headerlink" title="2. 缓存数据不一致的解决方案"></a>2. 缓存数据不一致的解决方案</h3><p>在更新数据库后同时更新缓存，会在并发的场景下出现数据不一致，有下面方案：</p><h4 id="引入分布式锁"><a href="#引入分布式锁" class="headerlink" title="引入分布式锁"></a>引入分布式锁</h4><p>在更新缓存之前尝试获取锁，如果已经被占用就先阻塞住线程，等待其他线程释放锁后再尝试更新。但这会影响并发操作的性能。</p><h4 id="设置较短缓存时间"><a href="#设置较短缓存时间" class="headerlink" title="设置较短缓存时间"></a>设置较短缓存时间</h4><p>设置较短的缓存过期时间能够使得数据不一致问题存在的时间也比较短，对业务的影响相对较小。但是与此同时，其实这也使得缓存命中率降低，又回到了前面的问题里…</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li><a href="https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY">https://developer.aliyun.com/article/1240257?spm=a2c6h.14164896.0.0.619748aaOkV6SY</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel流量控制</title>
    <link href="/Sentinel/Sentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/Sentinel/Sentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p><p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p><p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>count</code>: 限流阈值</li><li><code>grade</code>: 限流阈值类型，QPS 或线程数</li><li><code>strategy</code>: 根据调用关系选择策略</li></ul><h2 id="基于QPS-x2F-并发数的流量控制"><a href="#基于QPS-x2F-并发数的流量控制" class="headerlink" title="基于QPS&#x2F;并发数的流量控制"></a>基于QPS&#x2F;并发数的流量控制</h2><p>流量控制主要有两种统计类型，一种是<strong>统计线程数</strong>，另外一种则是统计 QPS。类型由 <code>FlowRule.grade</code> 字段来定义。其中，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。其中线程数、QPS 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p><p>内容格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">idx</span> id   thread  pass  blocked   success  total Rt   <span class="hljs-number">1</span>m-pass   <span class="hljs-number">1</span>m-block   <span class="hljs-number">1</span>m-<span class="hljs-literal">all</span>   exeption<br><span class="hljs-attribute">2</span>   abc647 <span class="hljs-number">0</span>     <span class="hljs-number">46</span>     <span class="hljs-number">0</span>           <span class="hljs-number">46</span>     <span class="hljs-number">46</span>   <span class="hljs-number">1</span>       <span class="hljs-number">2763</span>      <span class="hljs-number">0</span>         <span class="hljs-number">2763</span>     <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>thread： 代表当前处理该资源的线程数；</li><li>pass： 代表一秒内到来到的请求；</li><li>blocked： 代表一秒内被流量控制的请求数量；</li><li>success： 代表一秒内成功处理完的请求；</li><li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li><li>RT： 代表一秒内该资源的平均响应时间；</li><li>1m-pass： 则是一分钟内到来的请求；</li><li>1m-block： 则是一分钟内被阻止的请求；</li><li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li><li>exception： 则是一秒内业务本身异常的总和。</li></ul><h3 id="2-1-并发线程数流量控制"><a href="#2-1-并发线程数流量控制" class="headerlink" title="2.1 并发线程数流量控制"></a>2.1 并发线程数流量控制</h3><p>线程数限流用于保护业务线程数不被耗尽。</p><p>Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。</p><h3 id="2-2-QPS流量控制"><a href="#2-2-QPS流量控制" class="headerlink" title="2.2 QPS流量控制"></a>2.2 QPS流量控制</h3><p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p><h4 id="直接拒绝"><a href="#直接拒绝" class="headerlink" title="直接拒绝"></a>直接拒绝</h4><p>直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。</p><h4 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h4><p>冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p><h4 id="匀速排队"><a href="#匀速排队" class="headerlink" title="匀速排队"></a>匀速排队</h4><p>匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p><p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><blockquote><p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022335925.png" alt="image-20230702223524513"></p><h2 id="基于调用关系的流量控制"><a href="#基于调用关系的流量控制" class="headerlink" title="基于调用关系的流量控制"></a>基于调用关系的流量控制</h2><p>调用关系包括调用方、被调用方；一个方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterBuilderSlot</code> 记录每个资源的实时统计信息。</p><h3 id="3-1-根据调用方限流"><a href="#3-1-根据调用方限流" class="headerlink" title="3.1 根据调用方限流"></a>3.1 根据调用方限流</h3><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。</p><p>调用数据示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>: nodeA<br>idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total <br>1   caller1 0         0         0          0        0     0         0          0<br>2   caller2 0         0         0          0        0     0         0          0<br></code></pre></td></tr></table></figure><p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p><p>流控规则中的 <code>limitApp</code> 字段用于根据调用来源进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p><ul><li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li><li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li><li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li></ul><p>同一个资源名可以配置多条规则，规则的生效顺序为：**{some_origin_name} &gt; other &gt; default**</p><blockquote><p>注意：调用来源的数目不要太多（一般不要超过几百个），否则内存占用会非常多（调用来源的统计节点最大数目&#x3D;资源数目*来源数目）。</p></blockquote><h3 id="3-2-根据调用链路入口限流：链路限流"><a href="#3-2-根据调用链路入口限流：链路限流" class="headerlink" title="3.2 根据调用链路入口限流：链路限流"></a>3.2 根据调用链路入口限流：链路限流</h3><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p><p>一棵典型的调用树如下图所示：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">          machine-root<br>              /       <span class="hljs-string">\</span><br>             /         <span class="hljs-string">\</span><br>       Entrance1     Entrance2<br>          /             <span class="hljs-string">\</span><br>         /               <span class="hljs-string">\</span><br>DefaultNode(nodeA)   DefaultNode(nodeA)<br></code></pre></td></tr></table></figure><p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_CHAIN</code>，同时设置 <code>refResource</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而不关心经 <code>Entrance2</code> 到来的调用。</p><p>调用链的入口（上下文）是通过 API 方法 <code>ContextUtil.enter(contextName)</code> 定义的，其中 contextName 即对应调用链路入口名称。</p><h3 id="3-3-具有关系的资源流量控制：关联流量控制"><a href="#3-3-具有关系的资源流量控制：关联流量控制" class="headerlink" title="3.3 具有关系的资源流量控制：关联流量控制"></a>3.3 具有关系的资源流量控制：关联流量控制</h3><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们<strong>可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_RELATE</code> 同时设置 <code>refResource</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel基础概念</title>
    <link href="/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/Sentinel/Sentinel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><blockquote><p><strong>任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的</strong>。需要根据系统的处理能力对流量进行控制</p></blockquote><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307021350271.png" alt="image-20230702135042339"></p><p>流量控制有下面几个角度：</p><ul><li><strong>资源的调用关系</strong>。比如：资源调用链路、资源和资源的关系。</li><li><strong>运行的指标</strong>。比如：QPS、线程池、系统负载。</li><li><strong>控制的效果</strong>。比如：直接限流、冷启动、排队。</li></ul><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>在资源调用过程中，如果某个资源出现了不稳定，最终会导致堆积发生。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022000526.png" alt="image-20230702135741629"></p><p>Sentinel 和 Hystrix 的原则是一致的：当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候。则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p><h3 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h3><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>的方式：</p><ul><li>好处：资源和资源之间做到了最彻底的隔离。</li><li>缺点：除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。</li></ul><p>Sentinel 对这个问题采取了两种手段：</p><ol><li><strong>通过并发线程数进行限制</strong></li></ol><p>这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。<strong>当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝</strong>。堆积的线程完成任务后才开始继续接收请求。</p><ol start="2"><li><strong>通过响应时间对资源进行降级</strong></li></ol><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。<strong>当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复</strong>。</p><h2 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h2><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><h2 id="Sentinel主流程"><a href="#Sentinel主流程" class="headerlink" title="Sentinel主流程"></a>Sentinel主流程</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称以及一个 Entry。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 API 显式创建；每一个 Entry 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:、</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p>总体的框架如下：</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001521.png" alt="image-20230702154412159"></p><p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001747.png" alt="image-20230702154750154"></p><h2 id="Sentinal各个Slot功能"><a href="#Sentinal各个Slot功能" class="headerlink" title="Sentinal各个Slot功能"></a>Sentinal各个Slot功能</h2><h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><blockquote><p> 这个 slot 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p></blockquote><p>使用下面代码可以创建一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextUtil.enter(<span class="hljs-string">&quot;entrance1&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> <span class="hljs-type">Entry</span> <span class="hljs-variable">nodeA</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br><br> ContextUtil.enter(<span class="hljs-string">&quot;entrance2&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>);<br> nodeA = SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>);<br> <span class="hljs-keyword">if</span> (nodeA != <span class="hljs-literal">null</span>) &#123;<br>   nodeA.exit();<br> &#125;<br> ContextUtil.exit();<br></code></pre></td></tr></table></figure><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001547.png" alt="image-20230702160008744"></p><h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><blockquote><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。</p></blockquote><p>存储的信息示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>: nodeA<br>idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total <br>1   caller1 0         0         0          0        0     0         0          0        <br>2   caller2 0         0         0          0        0     0         0          0        <br></code></pre></td></tr></table></figure><h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><blockquote><p><code>StatisticSlot</code> 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</p></blockquote><ul><li><code>clusterNode</code>：资源唯一标识的 ClusterNode 的 runtime 统计</li><li><code>origin</code>：根据来自不同调用者的统计信息</li><li><code>defaultnode</code>: 根据上下文条目名称和资源 ID 的 runtime 统计</li><li>入口的统计</li></ul><p>Sentinel 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p><p><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202307022001258.png" alt="image-20230702160429033"></p><h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>这个 slot 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p><ul><li>指定应用生效的规则，即针对调用方限流的；</li><li>调用方为 other 的规则；</li><li>调用方为 default 的规则。</li></ul><h3 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h3><p>这个 slot 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p><h3 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h3><p>这个 slot 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p><p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">核心类解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel集群流控（未完待续）</title>
    <link href="/Sentinel/Sentinel%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7/"/>
    <url>/Sentinel/Sentinel%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p><p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p><p>集群流控中共有两种身份：</p><ul><li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li><li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li></ul><h2 id="此处先省略"><a href="#此处先省略" class="headerlink" title="此处先省略"></a>此处先省略</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">集群流控官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
