<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.68" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-beta.250" />
    <style>
      html {
        background: #fff;
      }

      html[data-theme="dark"] {
        background: #1d1e1f;
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://floweryu.top/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html"><meta property="og:site_name" content="Floweryu"><meta property="og:title" content="JVM垃圾回收器"><meta property="og:description" content="串行收集器 串行收集器采用单线程 stop-the-world 的方式进行收集。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，采用单线程方式回收空间并整理内存。 特点： 单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。; 特别适合堆内..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-11-18T12:50:13.000Z"><meta property="article:author" content="Floweryu"><meta property="article:tag" content="后端"><meta property="article:tag" content="JVM"><meta property="article:published_time" content="2023-10-23T13:00:00.000Z"><meta property="article:modified_time" content="2023-11-18T12:50:13.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"JVM垃圾回收器","image":[""],"datePublished":"2023-10-23T13:00:00.000Z","dateModified":"2023-11-18T12:50:13.000Z","author":[{"@type":"Person","name":"Floweryu","url":"https://github.com/Floweryu/floweryu.github.io","email":"869830837@qq.com"}]}</script><link rel="icon" href="/logo.png"><title>JVM垃圾回收器 | Floweryu</title><meta name="description" content="串行收集器 串行收集器采用单线程 stop-the-world 的方式进行收集。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，采用单线程方式回收空间并整理内存。 特点： 单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。; 特别适合堆内...">
    <link rel="preload" href="/assets/style-97438ae4.css" as="style"><link rel="stylesheet" href="/assets/style-97438ae4.css">
    <link rel="modulepreload" href="/assets/app-1ec7133e.js"><link rel="modulepreload" href="/assets/JVM垃圾回收器.html-c783a10d.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="modulepreload" href="/assets/JVM垃圾回收器.html-24bd23e6.js">
    <link rel="prefetch" href="/assets/index.html-24ee2c98.js" as="script"><link rel="prefetch" href="/assets/LRU缓存算法.html-009cfdd0.js" as="script"><link rel="prefetch" href="/assets/二分查找专题.html-10cdd55c.js" as="script"><link rel="prefetch" href="/assets/二叉树专题.html-9ae390ea.js" as="script"><link rel="prefetch" href="/assets/剑指offer专题.html-69e0d802.js" as="script"><link rel="prefetch" href="/assets/动态规划专题.html-5109b367.js" as="script"><link rel="prefetch" href="/assets/双指针专题.html-c6a6096b.js" as="script"><link rel="prefetch" href="/assets/常用算法积累.html-c57ed3c5.js" as="script"><link rel="prefetch" href="/assets/排序专题.html-7d558620.js" as="script"><link rel="prefetch" href="/assets/排序算法及其时间复杂度.html-f953721a.js" as="script"><link rel="prefetch" href="/assets/栈和队列专题.html-ff2931a2.js" as="script"><link rel="prefetch" href="/assets/红黑树详解.html-641ceb4a.js" as="script"><link rel="prefetch" href="/assets/递归回溯专题.html-c30907b4.js" as="script"><link rel="prefetch" href="/assets/链表专题.html-f19b4d43.js" as="script"><link rel="prefetch" href="/assets/缓存一致性方案思考.html-e21cb7db.js" as="script"><link rel="prefetch" href="/assets/Dubbo超时时间原理.html-536aa9a4.js" as="script"><link rel="prefetch" href="/assets/LIMIT分页优化查询.html-4e2ffe5d.js" as="script"><link rel="prefetch" href="/assets/Redis数据结构与对象.html-77ae801a.js" as="script"><link rel="prefetch" href="/assets/Redis面试题.html-b9559ca4.js" as="script"><link rel="prefetch" href="/assets/跳表SkipList原理.html-12646f8e.js" as="script"><link rel="prefetch" href="/assets/MQ简介.html-8d824a9c.js" as="script"><link rel="prefetch" href="/assets/RocketMQ框架基础设计.html-cb1222c1.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——事务消息.html-eea5b9a1.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——服务发现.html-bba1ce28.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——消息存储.html-99b9f84b.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——通信模块.html-b7a37315.js" as="script"><link rel="prefetch" href="/assets/RocketMQ的事务消息.html-6964440b.js" as="script"><link rel="prefetch" href="/assets/RocketMQ面试题.html-3ea5ea91.js" as="script"><link rel="prefetch" href="/assets/延时发送消息.html-c5d38328.js" as="script"><link rel="prefetch" href="/assets/批量发送消息及消息列表分割.html-46f763dc.js" as="script"><link rel="prefetch" href="/assets/消息发送与消费.html-87cd85c2.js" as="script"><link rel="prefetch" href="/assets/消息类型.html-58346830.js" as="script"><link rel="prefetch" href="/assets/消息过滤.html-01511a16.js" as="script"><link rel="prefetch" href="/assets/顺序消费.html-c1dfc838.js" as="script"><link rel="prefetch" href="/assets/Sentinel基础概念.html-1190bdad.js" as="script"><link rel="prefetch" href="/assets/Sentinel流量控制.html-27c83903.js" as="script"><link rel="prefetch" href="/assets/Sentinel熔断降级.html-2e99b0e8.js" as="script"><link rel="prefetch" href="/assets/Sentinel限流原理.html-d3c164f9.js" as="script"><link rel="prefetch" href="/assets/Sentinel集群流控.html-58831333.js" as="script"><link rel="prefetch" href="/assets/ConfigurationClassPostProcessor源码理解.html-31608c23.js" as="script"><link rel="prefetch" href="/assets/Spring执行BeanFactoryPostProcessor源码理解.html-27f1759d.js" as="script"><link rel="prefetch" href="/assets/Java的__和equals()的区别.html-40726313.js" as="script"><link rel="prefetch" href="/assets/Transactional注解原理.html-302486aa.js" as="script"><link rel="prefetch" href="/assets/JVM参数详解.html-2c69481b.js" as="script"><link rel="prefetch" href="/assets/JVM垃圾回收基础.html-0615da52.js" as="script"><link rel="prefetch" href="/assets/AQS源码理解——ReentrantLock.html-3bb4866a.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal详解.html-0d70e02d.js" as="script"><link rel="prefetch" href="/assets/404.html-ee1810e3.js" as="script"><link rel="prefetch" href="/assets/index.html-e6d489bb.js" as="script"><link rel="prefetch" href="/assets/index.html-f0f13ceb.js" as="script"><link rel="prefetch" href="/assets/index.html-909c2daf.js" as="script"><link rel="prefetch" href="/assets/index.html-51fadf9d.js" as="script"><link rel="prefetch" href="/assets/index.html-0cce731a.js" as="script"><link rel="prefetch" href="/assets/index.html-14344404.js" as="script"><link rel="prefetch" href="/assets/index.html-4405c49a.js" as="script"><link rel="prefetch" href="/assets/index.html-4a49be9b.js" as="script"><link rel="prefetch" href="/assets/index.html-4719d7ea.js" as="script"><link rel="prefetch" href="/assets/index.html-412431bf.js" as="script"><link rel="prefetch" href="/assets/index.html-33d8a1ff.js" as="script"><link rel="prefetch" href="/assets/index.html-8a61036e.js" as="script"><link rel="prefetch" href="/assets/index.html-aaa01947.js" as="script"><link rel="prefetch" href="/assets/index.html-c4f6b72f.js" as="script"><link rel="prefetch" href="/assets/index.html-8343d7e7.js" as="script"><link rel="prefetch" href="/assets/index.html-123fb961.js" as="script"><link rel="prefetch" href="/assets/index.html-c0cb89e0.js" as="script"><link rel="prefetch" href="/assets/index.html-6ff0501d.js" as="script"><link rel="prefetch" href="/assets/index.html-4bd3ef9e.js" as="script"><link rel="prefetch" href="/assets/index.html-e0994330.js" as="script"><link rel="prefetch" href="/assets/index.html-93236a78.js" as="script"><link rel="prefetch" href="/assets/index.html-3293ab64.js" as="script"><link rel="prefetch" href="/assets/index.html-18d83bea.js" as="script"><link rel="prefetch" href="/assets/index.html-3474ac31.js" as="script"><link rel="prefetch" href="/assets/index.html-22528c18.js" as="script"><link rel="prefetch" href="/assets/index.html-7c89708e.js" as="script"><link rel="prefetch" href="/assets/index.html-934d8bb3.js" as="script"><link rel="prefetch" href="/assets/index.html-8b5d5571.js" as="script"><link rel="prefetch" href="/assets/index.html-b2893041.js" as="script"><link rel="prefetch" href="/assets/index.html-428cf01d.js" as="script"><link rel="prefetch" href="/assets/index.html-acdc3986.js" as="script"><link rel="prefetch" href="/assets/index.html-4ec32de7.js" as="script"><link rel="prefetch" href="/assets/index.html-5539e32a.js" as="script"><link rel="prefetch" href="/assets/index.html-7e9e6de3.js" as="script"><link rel="prefetch" href="/assets/index.html-a93fcd29.js" as="script"><link rel="prefetch" href="/assets/index.html-c9866817.js" as="script"><link rel="prefetch" href="/assets/index.html-c55efe18.js" as="script"><link rel="prefetch" href="/assets/index.html-75034533.js" as="script"><link rel="prefetch" href="/assets/index.html-f7572395.js" as="script"><link rel="prefetch" href="/assets/index.html-bbf96642.js" as="script"><link rel="prefetch" href="/assets/index.html-4861ad90.js" as="script"><link rel="prefetch" href="/assets/index.html-026e23c7.js" as="script"><link rel="prefetch" href="/assets/index.html-8e0878ce.js" as="script"><link rel="prefetch" href="/assets/index.html-a141bff8.js" as="script"><link rel="prefetch" href="/assets/index.html-467357b3.js" as="script"><link rel="prefetch" href="/assets/index.html-c7137210.js" as="script"><link rel="prefetch" href="/assets/index.html-42e1e383.js" as="script"><link rel="prefetch" href="/assets/index.html-db8e2a69.js" as="script"><link rel="prefetch" href="/assets/index.html-8ab2cc63.js" as="script"><link rel="prefetch" href="/assets/LRU缓存算法.html-c0fdd8d1.js" as="script"><link rel="prefetch" href="/assets/二分查找专题.html-9d53ed2b.js" as="script"><link rel="prefetch" href="/assets/二叉树专题.html-946ea754.js" as="script"><link rel="prefetch" href="/assets/剑指offer专题.html-05812c47.js" as="script"><link rel="prefetch" href="/assets/动态规划专题.html-29c39b68.js" as="script"><link rel="prefetch" href="/assets/双指针专题.html-f9cefc72.js" as="script"><link rel="prefetch" href="/assets/常用算法积累.html-12307df4.js" as="script"><link rel="prefetch" href="/assets/排序专题.html-a2815283.js" as="script"><link rel="prefetch" href="/assets/排序算法及其时间复杂度.html-93f67655.js" as="script"><link rel="prefetch" href="/assets/栈和队列专题.html-90e65456.js" as="script"><link rel="prefetch" href="/assets/红黑树详解.html-852513ac.js" as="script"><link rel="prefetch" href="/assets/递归回溯专题.html-f58bba5c.js" as="script"><link rel="prefetch" href="/assets/链表专题.html-3499bfb7.js" as="script"><link rel="prefetch" href="/assets/缓存一致性方案思考.html-90e01827.js" as="script"><link rel="prefetch" href="/assets/Dubbo超时时间原理.html-b5886a8e.js" as="script"><link rel="prefetch" href="/assets/LIMIT分页优化查询.html-2d2b0f88.js" as="script"><link rel="prefetch" href="/assets/Redis数据结构与对象.html-a5e704cb.js" as="script"><link rel="prefetch" href="/assets/Redis面试题.html-f9926566.js" as="script"><link rel="prefetch" href="/assets/跳表SkipList原理.html-400602d0.js" as="script"><link rel="prefetch" href="/assets/MQ简介.html-5626d7fe.js" as="script"><link rel="prefetch" href="/assets/RocketMQ框架基础设计.html-93029f79.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——事务消息.html-cfb62c25.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——服务发现.html-82e3f861.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——消息存储.html-29901f16.js" as="script"><link rel="prefetch" href="/assets/RocketMQ源码解析——通信模块.html-2233bfe6.js" as="script"><link rel="prefetch" href="/assets/RocketMQ的事务消息.html-647d7368.js" as="script"><link rel="prefetch" href="/assets/RocketMQ面试题.html-bdaf3ba2.js" as="script"><link rel="prefetch" href="/assets/延时发送消息.html-66cb20a8.js" as="script"><link rel="prefetch" href="/assets/批量发送消息及消息列表分割.html-679723f8.js" as="script"><link rel="prefetch" href="/assets/消息发送与消费.html-1eb0780b.js" as="script"><link rel="prefetch" href="/assets/消息类型.html-f5f82409.js" as="script"><link rel="prefetch" href="/assets/消息过滤.html-61b09281.js" as="script"><link rel="prefetch" href="/assets/顺序消费.html-7340c7b8.js" as="script"><link rel="prefetch" href="/assets/Sentinel基础概念.html-74eda2f6.js" as="script"><link rel="prefetch" href="/assets/Sentinel流量控制.html-9fcfef5f.js" as="script"><link rel="prefetch" href="/assets/Sentinel熔断降级.html-cd70aa60.js" as="script"><link rel="prefetch" href="/assets/Sentinel限流原理.html-45a08d50.js" as="script"><link rel="prefetch" href="/assets/Sentinel集群流控.html-67a69e2b.js" as="script"><link rel="prefetch" href="/assets/ConfigurationClassPostProcessor源码理解.html-a2aafd5f.js" as="script"><link rel="prefetch" href="/assets/Spring执行BeanFactoryPostProcessor源码理解.html-7a3a1c9e.js" as="script"><link rel="prefetch" href="/assets/Java的__和equals()的区别.html-15bd8ee7.js" as="script"><link rel="prefetch" href="/assets/Transactional注解原理.html-d5d7d1b5.js" as="script"><link rel="prefetch" href="/assets/JVM参数详解.html-7a766cde.js" as="script"><link rel="prefetch" href="/assets/JVM垃圾回收基础.html-a4777c93.js" as="script"><link rel="prefetch" href="/assets/AQS源码理解——ReentrantLock.html-1f4c9023.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal详解.html-6747e012.js" as="script"><link rel="prefetch" href="/assets/404.html-aca00358.js" as="script"><link rel="prefetch" href="/assets/index.html-d66c4b10.js" as="script"><link rel="prefetch" href="/assets/index.html-88d8dc53.js" as="script"><link rel="prefetch" href="/assets/index.html-518a0f49.js" as="script"><link rel="prefetch" href="/assets/index.html-f3657dbf.js" as="script"><link rel="prefetch" href="/assets/index.html-e32c60e0.js" as="script"><link rel="prefetch" href="/assets/index.html-e49ce572.js" as="script"><link rel="prefetch" href="/assets/index.html-2841501f.js" as="script"><link rel="prefetch" href="/assets/index.html-4b82ad8f.js" as="script"><link rel="prefetch" href="/assets/index.html-49ccfe57.js" as="script"><link rel="prefetch" href="/assets/index.html-c888fe4d.js" as="script"><link rel="prefetch" href="/assets/index.html-5c32af7f.js" as="script"><link rel="prefetch" href="/assets/index.html-ee04fb9c.js" as="script"><link rel="prefetch" href="/assets/index.html-55608593.js" as="script"><link rel="prefetch" href="/assets/index.html-16215267.js" as="script"><link rel="prefetch" href="/assets/index.html-72874403.js" as="script"><link rel="prefetch" href="/assets/index.html-1769e7aa.js" as="script"><link rel="prefetch" href="/assets/index.html-d82d2828.js" as="script"><link rel="prefetch" href="/assets/index.html-283b16cd.js" as="script"><link rel="prefetch" href="/assets/index.html-cb96c0a7.js" as="script"><link rel="prefetch" href="/assets/index.html-e28e79e4.js" as="script"><link rel="prefetch" href="/assets/index.html-3f897fc7.js" as="script"><link rel="prefetch" href="/assets/index.html-231d0343.js" as="script"><link rel="prefetch" href="/assets/index.html-1fd1f89c.js" as="script"><link rel="prefetch" href="/assets/index.html-8acaa136.js" as="script"><link rel="prefetch" href="/assets/index.html-1e2e8977.js" as="script"><link rel="prefetch" href="/assets/index.html-09b178fc.js" as="script"><link rel="prefetch" href="/assets/index.html-67122319.js" as="script"><link rel="prefetch" href="/assets/index.html-ef5b3775.js" as="script"><link rel="prefetch" href="/assets/index.html-785efe60.js" as="script"><link rel="prefetch" href="/assets/index.html-1f570675.js" as="script"><link rel="prefetch" href="/assets/index.html-61d6a204.js" as="script"><link rel="prefetch" href="/assets/index.html-a042f17b.js" as="script"><link rel="prefetch" href="/assets/index.html-96bdf45a.js" as="script"><link rel="prefetch" href="/assets/index.html-0b20d230.js" as="script"><link rel="prefetch" href="/assets/index.html-36501bdb.js" as="script"><link rel="prefetch" href="/assets/index.html-ddea2f9b.js" as="script"><link rel="prefetch" href="/assets/index.html-81feb0dc.js" as="script"><link rel="prefetch" href="/assets/index.html-7cbdf3ac.js" as="script"><link rel="prefetch" href="/assets/index.html-978619e2.js" as="script"><link rel="prefetch" href="/assets/index.html-dbc4b0de.js" as="script"><link rel="prefetch" href="/assets/index.html-79f99bbc.js" as="script"><link rel="prefetch" href="/assets/index.html-c18e2334.js" as="script"><link rel="prefetch" href="/assets/index.html-f40a459b.js" as="script"><link rel="prefetch" href="/assets/index.html-a5b98c70.js" as="script"><link rel="prefetch" href="/assets/index.html-04be576e.js" as="script"><link rel="prefetch" href="/assets/index.html-0a901214.js" as="script"><link rel="prefetch" href="/assets/index.html-3b7f2d1b.js" as="script"><link rel="prefetch" href="/assets/index.html-ff295175.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-1464cdb9.js" as="script"><link rel="prefetch" href="/assets/pageview-b24f0557.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="/logo_dark.png" alt="Floweryu"><!----><span class="vp-site-name hide-in-pad">Floweryu</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="首页" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Java" class="vp-link nav-link active nav-link active" href="/java/"><span class="font-icon icon fa-fw fa-sm fas fa-mug-saucer" style=""></span>Java<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="中间件"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-label="MySQL" class="vp-link nav-link nav-link" href="/mysql/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-signature" style=""></span>MySQL<!----></a></li><li class="dropdown-item"><a aria-label="Redis" class="vp-link nav-link nav-link" href="/redis/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-signature" style=""></span>Redis<!----></a></li><li class="dropdown-item"><a aria-label="Sentinel" class="vp-link nav-link nav-link" href="/sentinel/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-signature" style=""></span>Sentinel<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="Spring" class="vp-link nav-link nav-link" href="/spring/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-chart-simple" style=""></span>Spring<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="RocketMQ" class="vp-link nav-link nav-link" href="/rocketmq/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-chart-simple" style=""></span>RocketMQ<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Dubbo" class="vp-link nav-link nav-link" href="/dubbo/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-chart-simple" style=""></span>Dubbo<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="算法笔记" class="vp-link nav-link nav-link" href="/algorithm/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-chart-simple" style=""></span>算法笔记<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="随笔"><span class="title"><span class="font-icon icon fa-fw fa-sm fa-solid fa-chart-simple" style=""></span>随笔</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-label="分布式" class="vp-link nav-link nav-link" href="/distributed/"><span class="font-icon icon fa-fw fa-sm fa-solid fa-signature" style=""></span>分布式<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="分类" class="vp-link nav-link nav-link" href="/category/"><span class="font-icon icon fa-fw fa-sm fas fa-bookmark" style=""></span>分类<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="标签" class="vp-link nav-link nav-link" href="/tag/"><span class="font-icon icon fa-fw fa-sm fas fa-tag" style=""></span>标签<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/Floweryu/floweryu.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable"><span class="font-icon icon fa-fw fa-sm fa-solid fa-sliders" style=""></span><a aria-label="JDK基础" class="vp-link nav-link vp-sidebar-title nav-link vp-sidebar-title" href="/java/basic/"><!---->JDK基础<!----></a><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="Java的==和equals区别" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/java/basic/Java%E7%9A%84__%E5%92%8Cequals()%E7%9A%84%E5%8C%BA%E5%88%AB.html"><!---->Java的==和equals区别<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Transactional注解原理.md" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/java/basic/Transactional%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86.html"><!---->Transactional注解原理.md<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable"><span class="font-icon icon fa-fw fa-sm fa-solid fa-sliders" style=""></span><a aria-label="多线程" class="vp-link nav-link vp-sidebar-title nav-link vp-sidebar-title" href="/java/thread/"><!---->多线程<!----></a><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="AQS源码理解——ReentrantLock" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/java/thread/AQS%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94ReentrantLock.html"><!---->AQS源码理解——ReentrantLock<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="ThreadLocal详解" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/java/thread/ThreadLocal%E8%AF%A6%E8%A7%A3.html"><!---->ThreadLocal详解<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable active"><span class="font-icon icon fa-fw fa-sm fa-solid fa-sliders" style=""></span><a aria-label="JVM" class="vp-link nav-link active vp-sidebar-title nav-link active vp-sidebar-title" href="/java/jvm/"><!---->JVM<!----></a><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="JVM参数详解" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/java/jvm/JVM%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3.html"><!---->JVM参数详解<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="JVM垃圾回收器" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html"><!---->JVM垃圾回收器<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="串行收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#串行收集器"><!---->串行收集器<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Serial + Serial Old 收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#serial-serial-old-收集器"><!---->Serial + Serial Old 收集器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="并行收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#并行收集器"><!---->并行收集器<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Parallel Scavenge + Parallel Old收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#parallel-scavenge-parallel-old收集器"><!---->Parallel Scavenge + Parallel Old收集器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="并发标记清除收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#并发标记清除收集器"><!---->并发标记清除收集器<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="CMS 收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#cms-收集器"><!---->CMS 收集器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ParNew 收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#parnew-收集器"><!---->ParNew 收集器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="G1收集器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#g1收集器"><!---->G1收集器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#总结"><!---->总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="参考：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html#参考"><!---->参考：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a aria-label="JVM垃圾回收基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80.html"><!---->JVM垃圾回收基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->JVM垃圾回收器</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/Floweryu/floweryu.github.io" target="_blank" rel="noopener noreferrer">Floweryu</a></span><span property="author" content="Floweryu"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-10-23T13:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 34 分钟</span><meta property="timeRequired" content="PT34M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category4 clickable" role="navigation">Java</span><!--]--><meta property="articleSection" content="Java"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag2 clickable" role="navigation">后端</span><span class="page-tag-item tag1 clickable" role="navigation">JVM</span><!--]--><meta property="keywords" content="后端,JVM"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#串行收集器">串行收集器</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#serial-serial-old-收集器">Serial + Serial Old 收集器</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#并行收集器">并行收集器</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#parallel-scavenge-parallel-old收集器">Parallel Scavenge + Parallel Old收集器</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#并发标记清除收集器">并发标记清除收集器</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#cms-收集器">CMS 收集器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#parnew-收集器">ParNew 收集器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#g1收集器">G1收集器</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#总结">总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#参考">参考：</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h2 id="串行收集器" tabindex="-1"><a class="header-anchor" href="#串行收集器" aria-hidden="true">#</a> 串行收集器</h2><p><strong>串行收集器采用单线程 <code>stop-the-world</code> 的方式进行收集</strong>。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，<strong>采用单线程方式回收空间并整理内存</strong>。</p><p><strong>特点</strong>：</p><ul><li>单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。</li><li><strong>特别适合堆内存不高、单核甚至双核 CPU 的场合</strong>。</li></ul><h3 id="serial-serial-old-收集器" tabindex="-1"><a class="header-anchor" href="#serial-serial-old-收集器" aria-hidden="true">#</a> Serial + Serial Old 收集器</h3><blockquote><p>开启选项：-XX:+UseSerialGC 打开此开关后，使用 Serial + Serial Old 收集器组合来进行内存回收。<strong>等价于新生代用Serial GC，且老年代用Serial old GC。</strong></p></blockquote><p><strong>运行示意图</strong>：</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310231626614.png" alt="image-20231023162553675" tabindex="0" loading="lazy"><figcaption>image-20231023162553675</figcaption></figure><p>针对年轻代：<strong>Serial收集器</strong>采用<strong>复制算法</strong>，<strong>串行回收</strong>和<strong>stop-the-World</strong>机制。</p><p>针对老年代：<strong>Serial old收集器</strong>采用<strong>标记-整理算法</strong>，也采用了<strong>串行回收</strong>和<strong>stop-the-World</strong>机制。</p><p><strong>特点</strong>：</p><ul><li>简单高效：对于限定单个CPU的环境来说，Serial收集器由于<strong>没有线程交互的开销</strong></li><li>占用内存小</li></ul><p><strong>场景</strong>：</p><ul><li>对于堆内存很小的应用（几十或者一两百兆的新生代或老年代）</li><li>桌面应用（客户端模式下的默认垃圾收集器）</li><li>Serial Old在JDK 5之前的版本中和Parallel Scavenge收集器搭配使用</li><li>Serial Old作为CMS收集器发生失败时的后备预案</li></ul><h2 id="并行收集器" tabindex="-1"><a class="header-anchor" href="#并行收集器" aria-hidden="true">#</a> 并行收集器</h2><p><strong>并行收集器是 server 模式下的默认收集器。</strong></p><blockquote><p>开启选项：-XX:+UseParallelGC 打开此开关后，使用 Parallel Scavenge + Serial Old 收集器组合来进行内存回收。 开启选项：-XX:+UseParallelOldGC 打开此开关后，使用 Parallel Scavenge + Parallel Old 收集器组合来进行内存回收。</p></blockquote><p>其他收集器都是以关注停顿时间为目标，而<strong>并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器。</strong></p><ul><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；</li><li>而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li></ul><p><code>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</code></p><p><strong>特点</strong>：</p><ul><li>并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，<strong>只是暂停时并行地进行垃圾收集</strong>。</li><li>并行收集器<strong>年轻代采用复制算法</strong>，<strong>老年代采用标记-整理</strong>，在回收的同时还会<strong>对内存进行压缩</strong>。</li><li>并行收集器<strong>适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</strong></li></ul><p><strong>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。</strong></p><h3 id="parallel-scavenge-parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge-parallel-old收集器" aria-hidden="true">#</a> Parallel Scavenge + Parallel Old收集器</h3><p><strong>特点</strong>：</p><ul><li><strong>新生代</strong>使用Parallel Scavenge<strong>标记复制</strong>，<strong>老年代</strong>使用Parallel Old收集器<strong>标记整理</strong></li><li>吞吐量优先</li><li>并行收集</li></ul><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是：</p><ul><li><code>-XX:MaxGCPauseMillis</code> ：控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。</li><li><code>-XX:GCTimeRatio</code>： 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。</li><li></li></ul><p>缩短停顿时间是以牺牲<strong>吞吐量</strong>和<strong>年轻代空间</strong>来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>Parallel Scavenge 收集器还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小<code>-Xmn</code>、Eden 和 Survivor 区的比例<code>-XX:SurvivorRatio</code>、晋升老年代对象年龄<code>-XX:PretenureSizeThreshold</code>等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 <strong>GC 自适应的调节策略</strong>（GC Ergonomics）。</p><h2 id="并发标记清除收集器" tabindex="-1"><a class="header-anchor" href="#并发标记清除收集器" aria-hidden="true">#</a> 并发标记清除收集器</h2><blockquote><p>开启选项：-XX:+UseConcMarkSweepGC 打开此开关后，使用 CMS + ParNew + Serial Old 收集器组合来进行内存回收。</p></blockquote><p><strong>并发标记清除收集器是以获取最短停顿时间为目标。</strong></p><p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 Concurrent Mode Failure ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p><h3 id="cms-收集器" tabindex="-1"><a class="header-anchor" href="#cms-收集器" aria-hidden="true">#</a> CMS 收集器</h3><p><strong>CMS 收集器是一种以获取最短停顿时间为目标的收集器。JVM9移除</strong></p><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法.</p><p><strong>运行示意图</strong>：</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310231642976.png" alt="image-20231023164255376" tabindex="0" loading="lazy"><figcaption>image-20231023164255376</figcaption></figure><h4 id="cms收集器各个阶段" tabindex="-1"><a class="header-anchor" href="#cms收集器各个阶段" aria-hidden="true">#</a> CMS收集器各个阶段</h4><h5 id="阶段1-初始标记—stw" tabindex="-1"><a class="header-anchor" href="#阶段1-初始标记—stw" aria-hidden="true">#</a> 阶段1：初始标记—STW</h5><p>仅仅只是标记一下 GC Roots 能直接关联到的对象（包括根对象直接引用的对象，以及被年轻代中所有存活的对象所引用的老年代对象），速度很快，需要停顿。</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310241124055.png" alt="image-20231024112453873" tabindex="0" loading="lazy"><figcaption>image-20231024112453873</figcaption></figure><h5 id="阶段2-并发标记—并发" tabindex="-1"><a class="header-anchor" href="#阶段2-并发标记—并发" aria-hidden="true">#</a> 阶段2：并发标记—并发</h5><p>遍历所有的对象，标记存活的对象，从前一阶段“初始标记”找到的根元素开始算起。</p><p>此阶段由于与用户线程并发执行，对象的状态可能会发生变化，如下：</p><ul><li>年轻代的对象从年轻代晋升到老年代</li><li>有些对象被直接分配到老年代</li><li>老年代和年轻代的对象引用关系变化</li></ul><p>JVM会通过<code>Card(卡片)</code>的方式将发生改变的老年代区域标记为“脏”区，这就是所谓的<code>卡片标记（Card Marking）</code></p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310241458159.png" alt="image-20231024145830642" tabindex="0" loading="lazy"><figcaption>image-20231024145830642</figcaption></figure><h5 id="阶段3-并发预清理—并发" tabindex="-1"><a class="header-anchor" href="#阶段3-并发预清理—并发" aria-hidden="true">#</a> 阶段3：并发预清理—并发</h5><p>标记老年代存活的对象，此阶段仍然是与应用线程并发执行的，不需要停止应用线程。</p><p><strong>目的：</strong> 让最终/重新标记的STW时间尽可能短</p><p><strong>标记目标：</strong></p><ul><li>老年代中在<strong>并发标记阶段</strong>中被标记为<strong>dirty</strong>的card</li><li>幸存区（from和to）中引用的老年代对象</li></ul><p><strong>关闭参数：</strong><code>-XX:-CMSPrecleaningEnabled</code>，<strong>默认开启</strong></p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310241713880.png" alt="image-20231024171341252" tabindex="0" loading="lazy"><figcaption>image-20231024171341252</figcaption></figure><h5 id="阶段4-可取消的并发预清理—并发" tabindex="-1"><a class="header-anchor" href="#阶段4-可取消的并发预清理—并发" aria-hidden="true">#</a> 阶段4：可取消的并发预清理—并发</h5><p>不停止应用程序，本阶段尝试在STW的最终标记阶段之前尽可能多做一些工作。可取消。</p><p><strong>存在价值</strong>：在进入最终标记前尽量等到一个Minor GC，尽量缩短最终标记阶段的停顿时间。</p><p><strong>触发条件：</strong> 在预清理步骤后，如果满足下面这个个条件，就会开启可中断的预清理，直接进入重新标记阶段</p><ul><li>Eden的使用空间大于<code>-XX:CMSScheduleRemarkEdenSizeThreshold</code>，这个参数的默认值是2M</li></ul><p><strong>取消条件：</strong></p><ul><li>设置了<code>CMSMaxAbortablePrecleanLoops</code>循环次数，并且执行的次数大于或者等于这个值的时候。<strong>默认为0</strong></li><li><code>CMSMaxAbortablePrecleanTime</code>，执行可中断预清理的时间超过了这个值，这个参数的<strong>默认值是5000毫秒</strong></li><li>Eden的使用率达到<code>-XX:CMSScheduleRemarkEdenPenetration</code>，<strong>这个参数的默认值是50%</strong>。</li></ul><p>CMS提供了参数<code>CMSScavengeBeforeRemark</code>在执行remark操作之前先做一次<code>Young GC</code>，目的在于减少年轻代对老年代的无效引用，降低remark时的开销。</p><h5 id="阶段5-最终标记-重标记—stw" tabindex="-1"><a class="header-anchor" href="#阶段5-最终标记-重标记—stw" aria-hidden="true">#</a> 阶段5：最终标记/重标记—STW</h5><p>第二次（也是最后一次）STW停顿。</p><p><strong>作用：</strong> 重新扫描堆中的对象，因为之前的预清理阶段是并发执行的，有可能GC线程跟不上应用程序的修改速度。</p><p><strong>扫描范围：</strong> 新生代对象+GC Roots+被标记为<strong>脏区</strong>的对象。<strong>如果预清理阶段没有做好，这一步扫描新生代的时候就会花很多时间。</strong></p><h5 id="阶段6-并发清除-concurrent-sweep" tabindex="-1"><a class="header-anchor" href="#阶段6-并发清除-concurrent-sweep" aria-hidden="true">#</a> 阶段6：并发清除 Concurrent Sweep</h5><p><strong>作用</strong>：JVM在此阶段删除不再使用的对象，并回收他们占用的内存空间。</p><h5 id="阶段7-并发重置-concurrent-reset" tabindex="-1"><a class="header-anchor" href="#阶段7-并发重置-concurrent-reset" aria-hidden="true">#</a> 阶段7：并发重置 Concurrent Reset</h5><p><strong>作用</strong>：重置CMS算法相关的内部数据，为下一次GC循环做准备</p><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点：</h4><ul><li><strong>吞吐量降低</strong>：对处理器资源敏感，执行垃圾收集时会占用一部分线程导致程序吞吐量降低。</li><li><strong>占用CPU资源，与CPU核数挂钩</strong>：CMS默认启动的回收线程是（CPU核心数 +3）/4，当CPU核数越多，垃圾回收线程占用的资源就越少，反正CPU核数越少，占用资源就越多。</li><li><strong>内存碎片问题</strong>：CMS使用的是标记-清除算法，这种算法的弊端就是会产生内存碎片，导致大对象无法分配，就会触发Full GC。 <ul><li>CMS收集器提供了一个参数<code>-XX:+UseCMSCompactAtFullCollection(默认开启,JDK9废弃)</code>，在进行Full GC之前进行一次内存整理（<strong>无法并发，Shenandoah和ZGC可以</strong>）。</li><li>CMS还提供了一个参数<code>-XX:CMSFullGCsBeforeCompaction=n（默认为0，表示每次进入Full GC时都进行碎片整理）</code>，参数作用是当CMS收集器执行过n次不整理内存碎片后，下一次进入Full GC前先进行碎片整理。</li></ul></li><li><strong>无法处理浮动垃圾</strong>：在并发收集阶段时，用户线程创建了一个对象年轻代放不下，直接晋升到老年代，或者年轻代对象晋升到老年代时老年代。因此CMS垃圾收集器必须要预留一部分空间给用户线程（需要更大的堆空间），不能等到老年代满了才收集（JDK5及之前是68%，JDK6之后调整为92%，可通过 <code>-XX:CMSInitiatingOccupancyFraction_=数值</code>+ <code>-XX:+UseCMSInitiatingOccupancyOnly</code>来设置） <ul><li>当设置<code>-XX:CMSInitiatingOccupancyFraction</code>过大时，就可能会出现垃圾收集过程中无法分配对象的问题，导致<strong>并发失败</strong>（Concurrent Mode Failure），此时会临时启用Serial Old收集器来重新进行老年代收集，这会导致停顿时间更长。</li></ul></li></ul><h3 id="parnew-收集器" tabindex="-1"><a class="header-anchor" href="#parnew-收集器" aria-hidden="true">#</a> ParNew 收集器</h3><blockquote><p>开启选项：-XX:+UseParNewGC</p></blockquote><p>ParNew 收集器其实是 Serial 收集器的多线程版本。主要是为了配合 CSM 的垃圾收集而提供的年轻代的垃圾收集器，其只有年轻代的收集版本。</p><p>Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>ParNew 收集器也是使用 <code>-XX:+UseConcMarkSweepGC</code> 后的默认年轻代收集器。</p><p>ParNew 收集器默认开启的线程数量与 CPU 数量相同，可以使用 <code>-XX:ParallelGCThreads</code> 参数来设置线程数。</p><h3 id="g1收集器" tabindex="-1"><a class="header-anchor" href="#g1收集器" aria-hidden="true">#</a> G1收集器</h3><blockquote><p>开启选项：-XX:+UseG1GC</p><p>Garbage First：每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。</p></blockquote><p>前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 <strong>G1 是一种兼顾吞吐量和停顿时间的 GC 收集器</strong>。G1 是 Oracle JDK9 以后的默认 GC 收集器。<strong>G1 可以直观的设定停顿时间的目标</strong>，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p><p>G1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷</p><h4 id="分区region" tabindex="-1"><a class="header-anchor" href="#分区region" aria-hidden="true">#</a> 分区Region</h4><p>G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。<strong>通过记录每个 Region 垃圾回收时间以及回收所获得的空间</strong>（这两个值是通过过去回收的经验获得），<strong>并维护一个优先列表</strong>，<strong>每次根据允许的收集时间</strong>，<strong>优先回收价值最大的 Region</strong>。</p><p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可。</p><p>启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小(1MB~32MB，且<strong>必须是2的幂</strong>)，默认将整堆划分为2048个分区。</p><h4 id="卡片card" tabindex="-1"><a class="header-anchor" href="#卡片card" aria-hidden="true">#</a> 卡片Card</h4><p>在每个分区内部又被分成了若干个大小为512 Byte<strong>卡片(Card)</strong>，标识堆内存最小可用粒度。</p><p>所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。</p><p>每次对内存的回收，都是对指定分区的卡片进行处理。</p><h4 id="堆heap" tabindex="-1"><a class="header-anchor" href="#堆heap" aria-hidden="true">#</a> 堆Heap</h4><p>G1同样可以通过<code>-Xms/-Xmx</code>来指定堆空间大小。</p><p>如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低。</p><p>目标参数<code>-XX:GCTimeRatio</code>即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。</p><p>当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起Full GC。Full GC后，也会调整堆空间。</p><p><strong>G1分区示意图</strong></p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252148963.png" alt="image-20231025214845362" tabindex="0" loading="lazy"><figcaption>image-20231025214845362</figcaption></figure><h4 id="分代模型" tabindex="-1"><a class="header-anchor" href="#分代模型" aria-hidden="true">#</a> 分代模型</h4><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252158432.png" alt="image-20231025215816612" tabindex="0" loading="lazy"><figcaption>image-20231025215816612</figcaption></figure><h5 id="分代垃圾回收" tabindex="-1"><a class="header-anchor" href="#分代垃圾回收" aria-hidden="true">#</a> 分代垃圾回收</h5><p>G1将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为<strong>Eden</strong>空间和<strong>Survivor</strong>空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。</p><blockquote><p>整个年轻代内存会在初始空间<code>-XX:G1NewSizePercent</code>(默认整堆5%)与最大空间(默认60%)之间动态变化，且该值由下面三个参数计算</p><ul><li>参数目标暂停时间<code>-XX:MaxGCPauseMillis</code>(默认200ms)</li><li>需要扩缩容的大小<code>-XX:G1MaxNewSizePercent</code></li><li>分区的已记忆集合(RSet)</li></ul><p>G1依然可以设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)，但同时暂停目标将失去意义。</p></blockquote><h5 id="本地分配缓冲" tabindex="-1"><a class="header-anchor" href="#本地分配缓冲" aria-hidden="true">#</a> 本地分配缓冲</h5><ul><li><p>应用线程可以独占一个**本地缓冲区(TLAB)**来创建的对象，而大部分都会落入Eden区域（巨型对象或分配失败除外）。</p></li><li><p>每次垃圾收集时，每个GC线程同样可以独占一个**本地缓冲区(GCLAB)**用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间。</p></li><li><p>对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为<strong>晋升本地缓冲区(PLAB)</strong>。</p></li></ul><h4 id="分区模型" tabindex="-1"><a class="header-anchor" href="#分区模型" aria-hidden="true">#</a> 分区模型</h4><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252203452.png" alt="image-20231025220346616" tabindex="0" loading="lazy"><figcaption>image-20231025220346616</figcaption></figure><p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p><h5 id="巨型对象humongous-region" tabindex="-1"><a class="header-anchor" href="#巨型对象humongous-region" aria-hidden="true">#</a> 巨型对象Humongous Region</h5><p>一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。</p><p>巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。</p><p>G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p><h5 id="已记忆集合remember-set-rset" tabindex="-1"><a class="header-anchor" href="#已记忆集合remember-set-rset" aria-hidden="true">#</a> 已记忆集合Remember Set (RSet)</h5><p>G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。</p><p>当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p><blockquote><p><strong>可能只有老年代分区才会有RSet记录</strong>。</p><p>下面这些情况不需要将引用记录在RSet中：</p><ul><li>一个分区确定需要扫描，引用来自该分区的对象。</li><li>引用来自年轻代的对象。（因为G1每次都会对年轻代进行整体收集）</li></ul></blockquote><h5 id="per-region-table-prt" tabindex="-1"><a class="header-anchor" href="#per-region-table-prt" aria-hidden="true">#</a> Per Region Table (PRT)</h5><p>为了降低RSet空间，使用下面三种模式记录：</p><ul><li>稀少：直接记录引用对象的卡片索引</li><li>细粒度：记录引用对象的分区索引</li><li>粗粒度：只记录引用数量，每个分区对应一个比特位，所以扫描时最慢，需要扫描整个堆</li></ul><h4 id="收集集合-cset" tabindex="-1"><a class="header-anchor" href="#收集集合-cset" aria-hidden="true">#</a> 收集集合 (CSet)</h4><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252226814.png" alt="image-20231025222635479" tabindex="0" loading="lazy"><figcaption>image-20231025222635479</figcaption></figure><p>年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p><blockquote><p>候选老年代分区的CSet准入条件：</p><ul><li><p>活跃度阈值<code>-XX:G1MixedGCLiveThresholdPercent</code>(默认85%)进行设置，从而拦截那些回收开销巨大的对象；</p></li><li><p>每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比<code>-XX:G1OldCSetRegionThresholdPercent</code>(默认10%)设置数量上限。</p></li></ul></blockquote><h5 id="年轻代收集集合-cset-of-young-collection" tabindex="-1"><a class="header-anchor" href="#年轻代收集集合-cset-of-young-collection" aria-hidden="true">#</a> 年轻代收集集合 CSet of Young Collection</h5><blockquote><p>年轻代回收大致过程：</p><ol><li><p>当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。</p></li><li><p>在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。</p></li><li><p>而原有的年轻代分区将被整体回收掉。</p></li></ol></blockquote><p>年轻代收集还负责维护对象的年龄(存活次数)，判断老化对象晋升，条件如下：</p><ul><li>年龄表</li><li>Survivor尺寸</li><li>Survivor填充容量<code>-XX:TargetSurvivorRatio</code>(默认50%)</li><li>最大年龄阈值<code>-XX:MaxTenuringThreshold</code>(默认15)</li></ul><h5 id="混合收集集合-cset-of-mixed-collection" tabindex="-1"><a class="header-anchor" href="#混合收集集合-cset-of-mixed-collection" aria-hidden="true">#</a> 混合收集集合 CSet of Mixed Collection</h5><p>当老年代占用空间超过整堆比阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(默认45%)时，G1就会启动一次混合垃圾收集周期。</p><p>为了满足暂停目标，G1可能会产生连续多次的STW混合收集与应用线程交替执行。</p><p>为了确定收集能包含到年轻代收集集合CSet的老年代分区，JVM通过下面参数：</p><ul><li>混合周期的最大总次数<code>-XX:G1MixedGCCountTarget</code>(默认8)</li><li>堆废物百分比<code>-XX:G1HeapWastePercent</code>(默认5%)</li></ul><p>通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p><h4 id="并发标记算法-三色标记法" tabindex="-1"><a class="header-anchor" href="#并发标记算法-三色标记法" aria-hidden="true">#</a> 并发标记算法（三色标记法）</h4><p>CMS和G1在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252237896.png" alt="image-20231025223728170" tabindex="0" loading="lazy"><figcaption>image-20231025223728170</figcaption></figure><p>GC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252239771.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="漏标问题" tabindex="-1"><a class="header-anchor" href="#漏标问题" aria-hidden="true">#</a> 漏标问题</h5><p>在remark过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标。会把白色D对象当作没有新引用指向从而回收掉。</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252241070.png" alt="image-20231025224130061" tabindex="0" loading="lazy"><figcaption>image-20231025224130061</figcaption></figure><p>并发标记过程中，Mutator删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收</p><p>产生漏标问题的条件有两个：</p><ul><li>黑色对象指向了白色对象</li><li>灰色对象指向白色对象的引用消失</li></ul><p>所以要解决漏标问题，打破两个条件之一即可：</p><ul><li><strong>跟踪黑指向白的增加</strong> incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法。</li><li><strong>记录灰指向白的消失</strong> SATB snapshot at the beginning：关注引用的删除，当灰–&gt;白消失时，要把这个 引用 推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。</li></ul><p><strong>为什么G1采用SATB而不用incremental update</strong>？</p><p>因为采用incremental update把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。G1有RSet与SATB相配合。Card Table里记录了RSet，RSet里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描RSet就可以了。</p><p>也就是说 灰色–&gt;白色 引用消失时，如果没有 黑色–&gt;白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。</p><h4 id="g1垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#g1垃圾回收机制" aria-hidden="true">#</a> G1垃圾回收机制</h4><p>【G1垃圾回收生命周期图】：</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252246059.png" alt="image-20231025224639513" tabindex="0" loading="lazy"><figcaption>image-20231025224639513</figcaption></figure><h5 id="rset的维护" tabindex="-1"><a class="header-anchor" href="#rset的维护" aria-hidden="true">#</a> RSet的维护</h5><p>由于不能整堆扫描，又需要计算分区确切的活跃度，因此，G1需要一个增量式的完全标记并发算法，通过维护RSet，得到准确的分区引用信息。</p><p>在G1中，RSet的维护主要来源两个方面：<strong>写栅栏(Write Barrier)<strong>和</strong>并发优化线程(Concurrence Refinement Threads)</strong></p><h5 id="栅栏barrier" tabindex="-1"><a class="header-anchor" href="#栅栏barrier" aria-hidden="true">#</a> 栅栏Barrier</h5><p>【示意图】：</p><figure><img src="https://floweryu-image.oss-cn-shanghai.aliyuncs.com/image202310252251503.png" alt="image-20231025225031116" tabindex="0" loading="lazy"><figcaption>image-20231025225031116</figcaption></figure><blockquote><p>栅栏的概念：</p><p>栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。而G1主要在赋值语句中，使用写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p></blockquote><p><strong>写前栅栏 Pre-Write Barrrier</strong>：</p><p>即将执行一段赋值语句时，等式左侧对象将修改引用到另一个对象，那么等式左侧对象原先引用的对象所在分区将因此丧失一个引用，那么<strong>JVM就需要在赋值语句生效之前，记录丧失引用的对象</strong>。JVM并不会立即维护RSet，而是通过批量处理，在将来RSet更新(见<strong>SATB</strong>)。</p><p><strong>写后栅栏 Post-Write Barrrier</strong>：</p><p>当执行一段赋值语句后，等式右侧对象获取了左侧对象的引用，那么等式右侧对象所在分区的RSet也应该得到更新。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)</p><h5 id="起始快照算法snapshot-at-the-beginning-satb" tabindex="-1"><a class="header-anchor" href="#起始快照算法snapshot-at-the-beginning-satb" aria-hidden="true">#</a> 起始快照算法Snapshot at the beginning (SATB)</h5><p>增量式完全并发标记算法起始快照算法(SATB)，主要针对标记-清除垃圾收集器的并发标记阶段，非常适合G1的分区块的堆结构，同时解决了CMS的主要烦恼：重新标记暂停时间长带来的潜在风险。</p><p>SATB会创建一个对象图，相当于堆的逻辑快照，从而确保并发标记阶段所有的垃圾对象都能通过快照被鉴别出来。当赋值语句发生时，应用将会改变了它的对象图，那么JVM需要记录被覆盖的对象。因此写前栅栏会在引用变更前，将值记录在SATB日志或缓冲区中。每个线程都会独占一个SATB缓冲区，初始有256条记录空间。当空间用尽时，线程会分配新的SATB缓冲区继续使用，而原有的缓冲去则加入全局列表中。<strong>最终在并发标记阶段，并发标记线程(Concurrent Marking Threads)在标记的同时，还会定期检查和处理全局缓冲区列表的记录，然后根据标记位图分片的标记位，扫描引用字段来更新RSet</strong>。此过程又称为并发标记/SATB写前栅栏。</p><h5 id="并发优化线程concurrence-refinement-threads" tabindex="-1"><a class="header-anchor" href="#并发优化线程concurrence-refinement-threads" aria-hidden="true">#</a> 并发优化线程Concurrence Refinement Threads</h5><p>当赋值语句发生后，写后栅栏会先通过G1的过滤技术判断是否是跨分区的引用更新，并将跨分区更新对象的卡片加入缓冲区序列，即更新日志缓冲区或脏卡片队列。与SATB类似，一旦日志缓冲区用尽，则分配一个新的日志缓冲区，并将原来的缓冲区加入全局列表中。</p><p>并发优化线程(Concurrence Refinement Threads)，只专注扫描日志缓冲区记录的卡片来维护更新RSet，线程最大数目可通过<code>-XX:G1ConcRefinementThreads</code>(默认等于<code>-XX:ParellelGCThreads</code>)设置。并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。如果记录增长很快或者来不及处理，那么通过阈值<code>-X:G1ConcRefinementGreenZone/-XX:G1ConcRefinementYellowZone/-XX:G1ConcRefinementRedZone</code>，G1会用分层的方式调度，使更多的线程处理全局列表。如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p><h5 id="并发标记周期-concurrent-marking-cycle" tabindex="-1"><a class="header-anchor" href="#并发标记周期-concurrent-marking-cycle" aria-hidden="true">#</a> 并发标记周期 Concurrent Marking Cycle</h5><p>这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成<strong>根标记</strong>、识别所有(可能**)存活对象**，并计算每个分区的活跃度，从而确定GC效率等级。</p><p>当达到IHOP阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(老年代占整堆比，默认45%)时，便会触发并发标记周期。</p><p>整个并发标记周期有下面几个阶段：</p><ul><li><strong>初始标记</strong>(Initial Mark)—STW</li><li><strong>根分区扫描</strong>(Root Region Scanning)</li><li><strong>并发标记</strong>(Concurrent Marking)</li><li><strong>重新标记</strong>(Remark)——STW</li><li><strong>清除</strong>(Cleanup)——STW</li></ul><p>其中，初始标记(随年轻代收集一起活动)、重新标记、清除是STW的，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。</p><h6 id="初始标记-initial-mark——swt" tabindex="-1"><a class="header-anchor" href="#初始标记-initial-mark——swt" aria-hidden="true">#</a> 初始标记 Initial Mark——SWT</h6><p>初始标记(Initial Mark)负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Java应用线程暂停掉，也就是需要一个STW的时间段。</p><p>事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为<strong>借道</strong>(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，分区的初始标记是并发执行，直到所有的分区处理完。</p><h6 id="根分区扫描-root-region-scanning——并发" tabindex="-1"><a class="header-anchor" href="#根分区扫描-root-region-scanning——并发" aria-hidden="true">#</a> 根分区扫描 Root Region Scanning——并发</h6><p>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。</p><p>此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为<strong>根分区扫描</strong>(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。</p><p>根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p><h6 id="并发标记-concurrent-marking——并发" tabindex="-1"><a class="header-anchor" href="#并发标记-concurrent-marking——并发" aria-hidden="true">#</a> 并发标记 Concurrent Marking——并发</h6><p>和应用线程并发执行，并发标记线程在并发标记阶段启动，由参数<code>-XX:ConcGCThreads</code>(默认GC线程数的1/4，即<code>-XX:ParallelGCThreads/4</code>)控制启动数量，每个线程每次只扫描一个分区，从而标记出存活对象图。在这一阶段会处理Previous/Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。参数<code>-XX:+ClassUnloadingWithConcurrentMark</code>会开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次年轻代收集。如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。</p><h6 id="存活数据计算-live-data-accounting" tabindex="-1"><a class="header-anchor" href="#存活数据计算-live-data-accounting" aria-hidden="true">#</a> 存活数据计算 Live Data Accounting</h6><p>存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。</p><h6 id="重新标记-remark——stw" tabindex="-1"><a class="header-anchor" href="#重新标记-remark——stw" aria-hidden="true">#</a> 重新标记 Remark——STW</h6><p>在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。前面几步是并行执行的，通过参数<code>-XX:ParallelGCThread</code>可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p><h6 id="清除-cleanup——stw" tabindex="-1"><a class="header-anchor" href="#清除-cleanup——stw" aria-hidden="true">#</a> 清除 Cleanup——STW</h6><p>主要做下面操作：</p><ul><li><p><strong>RSet梳理</strong>，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数<code>-XX:+PrintAdaptiveSizePolicy</code>可以开启打印启发式算法决策细节；</p></li><li><p><strong>整理堆分区</strong>，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；</p></li><li><p><strong>识别所有空闲分区</strong>，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期</p></li></ul><h5 id="年轻代收集-混合收集周期" tabindex="-1"><a class="header-anchor" href="#年轻代收集-混合收集周期" aria-hidden="true">#</a> 年轻代收集/混合收集周期</h5><p>当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(老年代占整堆比，默认45%)时，G1开始着手准备收集老年代空间。</p><p>首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。</p><h6 id="gc工作线程数" tabindex="-1"><a class="header-anchor" href="#gc工作线程数" aria-hidden="true">#</a> GC工作线程数</h6><p>JVM可以通过参数<code>-XX:ParallelGCThreads</code>进行指定GC工作的线程数量。</p><p>参数<code>-XX:ParallelGCThreads</code>默认值并不是固定的，而是根据当前的CPU资源进行计算。</p><p>如果用户没有指定，且CPU小于等于8，则默认与CPU核数相等；若CPU大于8，则默认JVM会经过计算得到一个小于CPU核数的线程数；也可以人工指定与CPU核数相等。</p><h6 id="年轻代收集-young-collection" tabindex="-1"><a class="header-anchor" href="#年轻代收集-young-collection" aria-hidden="true">#</a> 年轻代收集 Young Collection</h6><p><strong>并行活动</strong></p><ul><li><code>外部根分区扫描 Ext Root Scanning</code>：此活动对堆外的根(JVM系统目录、VM数据结构、JNI线程句柄、硬件寄存器、全局变量、线程对栈根)进行扫描，发现那些没有加入到暂停收集集合CSet中的对象。如果系统目录(单根)拥有大量加载的类，最终可能其他并行活动结束后，该活动依然没有结束而带来的等待时间。</li><li><code>更新已记忆集合 Update RS</code>：并发优化线程会对脏卡片的分区进行扫描更新日志缓冲区来更新RSet，但只会处理全局缓冲列表。作为补充，所有被记录但是还没有被优化线程处理的剩余缓冲区，会在该阶段处理，变成已处理缓冲区(Processed Buffers)。为了限制花在更新RSet的时间，可以设置暂停占用百分比<code>-XX:G1RSetUpdatingPauseTimePercent</code>(默认10%，即-XX:MaxGCPauseMills/10)。值得注意的是，如果更新日志缓冲区更新的任务不降低，单纯地减少RSet的更新时间，会导致暂停中被处理的缓冲区减少，将日志缓冲区更新工作推到并发优化线程上，从而增加对Java应用线程资源的争夺。</li><li><code>RSet扫描 Scan RS</code>：在收集当前CSet之前，考虑到分区外的引用，必须扫描CSet分区的RSet。如果RSet发生粗化，则会增加RSet的扫描时间。开启诊断模式<code>-XX:UnlockDiagnosticVMOptions</code>后，通过参数<code>-XX:+G1SummarizeRSetStats</code>可以确定并发优化线程是否能够及时处理更新日志缓冲区，并提供更多的信息，来帮助为RSet粗化总数提供窗口。参数<code>-XX：G1SummarizeRSetStatsPeriod=n</code>可设置RSet的统计周期，即经历多少此GC后进行一次统计</li><li><code>代码根扫描 Code Root Scanning</code>：对代码根集合进行扫描，扫描JVM编译后代码Native Method的引用信息(nmethod扫描)，进行RSet扫描。事实上，只有CSet分区中的RSet有强代码根时，才会做nmethod扫描，查找对CSet的引用。</li><li><code>转移和回收 Object Copy</code>：通过选定的CSet以及CSet分区完整的引用集，将执行暂停时间的主要部分：CSet分区存活对象的转移、CSet分区空间的回收。通过工作窃取机制来负载均衡地选定复制对象的线程，并且复制和扫描对象被转移的存活对象将拷贝到每个GC线程分配缓冲区GCLAB。G1会通过计算，预测分区复制所花费的时间，从而调整年轻代的尺寸。</li><li><code>终止 Termination</code>：完成上述任务后，如果任务队列已空，则工作线程会发起终止要求。如果还有其他线程继续工作，空闲的线程会通过工作窃取机制尝试帮助其他线程处理。而单独执行根分区扫描的线程，如果任务过重，最终会晚于终止。</li><li><code>GC外部的并行活动 GC Worker Other</code>：该部分并非GC的活动，而是JVM的活动导致占用了GC暂停时间(例如JNI编译)。</li></ul><p><strong>串行活动</strong></p><ul><li><code>代码根更新 Code Root Fixup</code>：根据转移对象更新代码根。</li><li><code>代码根清理 Code Root Purge</code>：清理代码根集合表。</li><li><code>清除全局卡片标记 Clear CT</code>：在任意收集周期会扫描CSet与RSet记录的PRT，扫描时会在全局卡片表中进行标记，防止重复扫描。在收集周期的最后将会清除全局卡片表中的已扫描标志。</li><li><code>选择下次收集集合 Choose CSet</code>：该部分主要用于并发标记周期后的年轻代收集、以及混合收集中，在这些收集过程中，由于有老年代候选分区的加入，往往需要对下次收集的范围做出界定；但单纯的年轻代收集中，所有收集的分区都会被收集，不存在选择。</li><li><code>引用处理 Ref Proc</code>：主要针对软引用、弱引用、虚引用、final引用、JNI引用。当Ref Proc占用时间过多时，可选择使用参数<code>-XX:ParallelRefProcEnabled</code>激活多线程引用处理。G1希望应用能小心使用软引用，因为软引用会一直占据内存空间直到空间耗尽时被Full GC回收掉；即使未发生Full GC，软引用对内存的占用，也会导致GC次数的增加。</li><li><code>引用排队 Ref Enq</code>：此项活动可能会导致RSet的更新，此时会通过记录日志，将关联的卡片标记为脏卡片。</li><li><code>卡片重新脏化 Redirty Cards</code>：重新脏化卡片。</li><li><code>回收空闲巨型分区 Humongous Reclaim</code>：G1做了一个优化：通过查看所有根对象以及年轻代分区的RSet，如果确定RSet中巨型对象没有任何引用，则说明G1发现了一个不可达的巨型对象，该对象分区会被回收。</li><li><code>释放分区 Free CSet</code>：回收CSet分区的所有空间，并加入到空闲分区中。</li><li><code>其他活动 Other</code>：GC中可能还会经历其他耗时很小的活动，如修复JNI句柄等</li></ul><h5 id="并发标记周期后的年轻代收集-young-collection-following-concurrent-marking-cycle" tabindex="-1"><a class="header-anchor" href="#并发标记周期后的年轻代收集-young-collection-following-concurrent-marking-cycle" aria-hidden="true">#</a> 并发标记周期后的年轻代收集 Young Collection Following Concurrent Marking Cycle</h5><h6 id="混合收集周期-mixed-collection-cycle" tabindex="-1"><a class="header-anchor" href="#混合收集周期-mixed-collection-cycle" aria-hidden="true">#</a> 混合收集周期 Mixed Collection Cycle</h6><p>单次的混合收集与年轻代收集并无二致。根据暂停目标，老年代的分区可能不能一次暂停收集中被处理完，G1会发起连续多次的混合收集，称为混合收集周期(Mixed Collection Cycle)。G1会计算每次加入到CSet中的分区数量、混合收集进行次数，并且在上次的年轻代收集、以及接下来的混合收集中，G1会确定下次加入CSet的分区集(Choose CSet)，并且确定是否结束混合收集周期。</p><h6 id="转移失败的担保机制-full-gc" tabindex="-1"><a class="header-anchor" href="#转移失败的担保机制-full-gc" aria-hidden="true">#</a> 转移失败的担保机制 Full GC</h6><p>当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p><p>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p><ul><li>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区</li><li>从老年代分区转移存活对象时，无法找到可用的空闲分区</li><li>分配巨型对象时在老年代无法找到足够的连续分区</li></ul><p>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><table><thead><tr><th>收集器</th><th>串行/并行/并发</th><th>年轻代/老年代</th><th>收集算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>年轻代</td><td>复制</td><td>响应速度优先</td><td>单 CPU 环境下的 Client 模式</td></tr><tr><td>Serial Old</td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td>ParNew</td><td>串行 + 并行</td><td>年轻代</td><td>复制算法</td><td>响应速度优先</td><td>多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td>Parallel Scavenge</td><td>串行 + 并行</td><td>年轻代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td>Parallel Old</td><td>串行 + 并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td>CMS</td><td>并行 + 并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr><tr><td>G1</td><td>并行 + 并发</td><td>年轻代 + 老年代</td><td>标记-整理 + 复制算法</td><td>响应速度优先</td><td>面向服务端应用，将来替换 CMS</td></tr></tbody></table><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考：</h2><ul><li>https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html</li></ul></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/Floweryu/floweryu.github.io/edit/main/src/java/jvm/JVM垃圾回收器.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><!----></div></footer><nav class="vp-page-nav"><a aria-label="JVM参数详解" class="vp-link nav-link prev nav-link prev" href="/java/jvm/JVM%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->JVM参数详解</div></a><a aria-label="JVM垃圾回收基础" class="vp-link nav-link next nav-link next" href="/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">JVM垃圾回收基础<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">Default footer</div><div class="vp-copyright">Copyright © 2023 Floweryu</div></footer></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-1ec7133e.js" defer></script>
  </body>
</html>
